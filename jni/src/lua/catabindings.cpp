// This file was automatically generated by lua/generate_bindings.lua
static int get_stats_damage_taken(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::push(L, instance.damage_taken);
    return 1;  // 1 return value
}
static int set_stats_damage_taken(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.damage_taken = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_stats_headshots(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::push(L, instance.headshots);
    return 1;  // 1 return value
}
static int set_stats_headshots(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.headshots = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_stats_damage_healed(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::push(L, instance.damage_healed);
    return 1;  // 1 return value
}
static int set_stats_damage_healed(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.damage_healed = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_stats_squares_walked(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::push(L, instance.squares_walked);
    return 1;  // 1 return value
}
static int set_stats_squares_walked(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.squares_walked = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_new_monster_group(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mongroup_id>::push(L, instance.new_monster_group);
    return 1;  // 1 return value
}
static int set_MonsterGroup_new_monster_group(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mongroup_id>::check(L, 2);;
    instance.new_monster_group = LuaValue<mongroup_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_name(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mongroup_id>::push(L, instance.name);
    return 1;  // 1 return value
}
static int set_MonsterGroup_name(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mongroup_id>::check(L, 2);;
    instance.name = LuaValue<mongroup_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_replace_monster_group(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<bool>::push(L, instance.replace_monster_group);
    return 1;  // 1 return value
}
static int set_MonsterGroup_replace_monster_group(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.replace_monster_group = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_monster_group_time(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<int>::push(L, instance.monster_group_time);
    return 1;  // 1 return value
}
static int set_MonsterGroup_monster_group_time(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.monster_group_time = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_defaultMonster(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mtype_id>::push(L, instance.defaultMonster);
    return 1;  // 1 return value
}
static int set_MonsterGroup_defaultMonster(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);;
    instance.defaultMonster = LuaValue<mtype_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_MonsterGroup_is_safe(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<bool>::push(L, instance.is_safe);
    return 1;  // 1 return value
}
static int set_MonsterGroup_is_safe(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.is_safe = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_quality_name(lua_State *L) {
    quality& instance = LuaReference<quality>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int get_w_point_temperature(lua_State *L) {
    w_point& instance = LuaReference<w_point>::get(L, 1);
    LuaType<float>::push(L, instance.temperature);
    return 1;  // 1 return value
}
static int get_w_point_humidity(lua_State *L) {
    w_point& instance = LuaReference<w_point>::get(L, 1);
    LuaType<float>::push(L, instance.humidity);
    return 1;  // 1 return value
}
static int get_w_point_pressure(lua_State *L) {
    w_point& instance = LuaReference<w_point>::get(L, 1);
    LuaType<float>::push(L, instance.pressure);
    return 1;  // 1 return value
}
static int get_w_point_windpower(lua_State *L) {
    w_point& instance = LuaReference<w_point>::get(L, 1);
    LuaType<float>::push(L, instance.windpower);
    return 1;  // 1 return value
}
static int get_w_point_acidic(lua_State *L) {
    w_point& instance = LuaReference<w_point>::get(L, 1);
    LuaType<bool>::push(L, instance.acidic);
    return 1;  // 1 return value
}
static int get_player_oxygen(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.oxygen);
    return 1;  // 1 return value
}
static int set_player_oxygen(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.oxygen = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_radiation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.radiation);
    return 1;  // 1 return value
}
static int set_player_radiation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.radiation = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_view_offset(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::push(L, instance.view_offset);
    return 1;  // 1 return value
}
static int set_player_view_offset(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);;
    instance.view_offset = LuaValue<tripoint>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_grab_point(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::push(L, instance.grab_point);
    return 1;  // 1 return value
}
static int set_player_grab_point(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);;
    instance.grab_point = LuaValue<tripoint>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_style_selected(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<matype_id>::push(L, instance.style_selected);
    return 1;  // 1 return value
}
static int set_player_style_selected(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<matype_id>::check(L, 2);;
    instance.style_selected = LuaValue<matype_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_tank_plut(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.tank_plut);
    return 1;  // 1 return value
}
static int set_player_tank_plut(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.tank_plut = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_blocks_left(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.blocks_left);
    return 1;  // 1 return value
}
static int set_player_blocks_left(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.blocks_left = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_power_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.power_level);
    return 1;  // 1 return value
}
static int set_player_power_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.power_level = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_last_climate_control_ret(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.last_climate_control_ret);
    return 1;  // 1 return value
}
static int set_player_last_climate_control_ret(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.last_climate_control_ret = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_volume(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.volume);
    return 1;  // 1 return value
}
static int set_player_volume(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.volume = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_next_climate_control_check(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.next_climate_control_check);
    return 1;  // 1 return value
}
static int set_player_next_climate_control_check(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.next_climate_control_check = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_scent(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.scent);
    return 1;  // 1 return value
}
static int set_player_scent(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.scent = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_focus_pool(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.focus_pool);
    return 1;  // 1 return value
}
static int set_player_focus_pool(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.focus_pool = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_reactor_plut(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.reactor_plut);
    return 1;  // 1 return value
}
static int set_player_reactor_plut(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.reactor_plut = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_start_location(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<start_location_id>::push(L, instance.start_location);
    return 1;  // 1 return value
}
static int set_player_start_location(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<start_location_id>::check(L, 2);;
    instance.start_location = LuaValue<start_location_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_stamina(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.stamina);
    return 1;  // 1 return value
}
static int set_player_stamina(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.stamina = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_recoil(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.recoil);
    return 1;  // 1 return value
}
static int set_player_recoil(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.recoil = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_controlling_vehicle(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.controlling_vehicle);
    return 1;  // 1 return value
}
static int set_player_controlling_vehicle(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.controlling_vehicle = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_lastconsumed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::push(L, instance.lastconsumed);
    return 1;  // 1 return value
}
static int set_player_lastconsumed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.lastconsumed = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_stim(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.stim);
    return 1;  // 1 return value
}
static int set_player_stim(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.stim = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_slow_rad(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.slow_rad);
    return 1;  // 1 return value
}
static int set_player_slow_rad(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.slow_rad = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_last_batch(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.last_batch);
    return 1;  // 1 return value
}
static int set_player_last_batch(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.last_batch = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_max_power_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.max_power_level);
    return 1;  // 1 return value
}
static int set_player_max_power_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.max_power_level = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_dodges_left(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.dodges_left);
    return 1;  // 1 return value
}
static int set_player_dodges_left(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.dodges_left = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_move_mode(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::push(L, instance.move_mode);
    return 1;  // 1 return value
}
static int set_player_move_mode(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.move_mode = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_lastrecipe(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::push(L, instance.lastrecipe);
    return 1;  // 1 return value
}
static int set_player_lastrecipe(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.lastrecipe = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_keep_hands_free(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.keep_hands_free);
    return 1;  // 1 return value
}
static int set_player_keep_hands_free(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.keep_hands_free = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_movecounter(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.movecounter);
    return 1;  // 1 return value
}
static int set_player_movecounter(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.movecounter = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_in_vehicle(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.in_vehicle);
    return 1;  // 1 return value
}
static int set_player_in_vehicle(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.in_vehicle = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_cash(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.cash);
    return 1;  // 1 return value
}
static int set_player_cash(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.cash = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_dex_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.dex_cur);
    return 1;  // 1 return value
}
static int set_player_dex_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.dex_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_per_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.per_max);
    return 1;  // 1 return value
}
static int set_player_per_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.per_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_int_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.int_max);
    return 1;  // 1 return value
}
static int set_player_int_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.int_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_weapon(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<item>::push(L, instance.weapon);
    return 1;  // 1 return value
}
static int set_player_weapon(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);;
    instance.weapon = LuaValueOrReference<item>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_male(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.male);
    return 1;  // 1 return value
}
static int set_player_male(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.male = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_str_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.str_cur);
    return 1;  // 1 return value
}
static int set_player_str_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.str_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_int_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.int_cur);
    return 1;  // 1 return value
}
static int set_player_int_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.int_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_str_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.str_max);
    return 1;  // 1 return value
}
static int set_player_str_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.str_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int set_player_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.name = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_nv_cached(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::push(L, instance.nv_cached);
    return 1;  // 1 return value
}
static int set_player_nv_cached(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.nv_cached = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_dex_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.dex_max);
    return 1;  // 1 return value
}
static int set_player_dex_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.dex_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_player_per_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::push(L, instance.per_cur);
    return 1;  // 1 return value
}
static int set_player_per_cur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.per_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_game_lightning_active(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<bool>::push(L, instance.lightning_active);
    return 1;  // 1 return value
}
static int set_game_lightning_active(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.lightning_active = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_point_y(lua_State *L) {
    point& instance = LuaValue<point>::get(L, 1);
    LuaType<int>::push(L, instance.y);
    return 1;  // 1 return value
}
static int set_point_y(lua_State *L) {
    point& instance = LuaValue<point>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.y = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_point_x(lua_State *L) {
    point& instance = LuaValue<point>::get(L, 1);
    LuaType<int>::push(L, instance.x);
    return 1;  // 1 return value
}
static int set_point_x(lua_State *L) {
    point& instance = LuaValue<point>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.x = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_uimenu_title(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    LuaType<std::string>::push(L, instance.title);
    return 1;  // 1 return value
}
static int set_uimenu_title(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.title = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_uimenu_selected(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    LuaType<int>::push(L, instance.selected);
    return 1;  // 1 return value
}
static int get_Character_dex_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.dex_cur);
    return 1;  // 1 return value
}
static int set_Character_dex_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.dex_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_per_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.per_max);
    return 1;  // 1 return value
}
static int set_Character_per_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.per_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_int_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.int_max);
    return 1;  // 1 return value
}
static int set_Character_int_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.int_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_weapon(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<item>::push(L, instance.weapon);
    return 1;  // 1 return value
}
static int set_Character_weapon(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);;
    instance.weapon = LuaValueOrReference<item>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_male(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::push(L, instance.male);
    return 1;  // 1 return value
}
static int set_Character_male(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.male = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_str_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.str_cur);
    return 1;  // 1 return value
}
static int set_Character_str_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.str_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_int_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.int_cur);
    return 1;  // 1 return value
}
static int set_Character_int_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.int_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_str_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.str_max);
    return 1;  // 1 return value
}
static int set_Character_str_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.str_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int set_Character_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.name = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_nv_cached(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::push(L, instance.nv_cached);
    return 1;  // 1 return value
}
static int set_Character_nv_cached(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.nv_cached = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_dex_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.dex_max);
    return 1;  // 1 return value
}
static int set_Character_dex_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.dex_max = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_Character_per_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::push(L, instance.per_cur);
    return 1;  // 1 return value
}
static int set_Character_per_cur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.per_cur = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.charges);
    return 1;  // 1 return value
}
static int set_item_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.charges = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_bday(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.bday);
    return 1;  // 1 return value
}
static int set_item_bday(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.bday = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_active(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<bool>::push(L, instance.active);
    return 1;  // 1 return value
}
static int set_item_active(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.active = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_poison(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.poison);
    return 1;  // 1 return value
}
static int set_item_poison(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.poison = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_player_id(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.player_id);
    return 1;  // 1 return value
}
static int set_item_player_id(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.player_id = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_type(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<itype>::push(L, instance.type);
    return 1;  // 1 return value
}
static int set_item_type(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<itype>::check(L, 2);;
    instance.type = LuaReference<itype>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_irridation(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.irridation);
    return 1;  // 1 return value
}
static int set_item_irridation(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.irridation = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_fridge(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.fridge);
    return 1;  // 1 return value
}
static int set_item_fridge(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.fridge = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_note(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.note);
    return 1;  // 1 return value
}
static int set_item_note(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.note = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_burnt(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.burnt);
    return 1;  // 1 return value
}
static int set_item_burnt(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.burnt = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_mission_id(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.mission_id);
    return 1;  // 1 return value
}
static int set_item_mission_id(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.mission_id = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_item_counter(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.item_counter);
    return 1;  // 1 return value
}
static int set_item_item_counter(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.item_counter = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_invlet(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.invlet);
    return 1;  // 1 return value
}
static int set_item_invlet(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.invlet = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_item_frequency(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::push(L, instance.frequency);
    return 1;  // 1 return value
}
static int set_item_frequency(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.frequency = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_trap_sym(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaType<int>::push(L, instance.sym);
    return 1;  // 1 return value
}
static int get_trap_name(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int get_trap_loadid(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<trap_id>::push(L, instance.loadid);
    return 1;  // 1 return value
}
static int get_trap_id(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<trap_str_id>::push(L, instance.id);
    return 1;  // 1 return value
}
static int get_trap_color(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaType<int>::push(L, instance.color);
    return 1;  // 1 return value
}
static int get_mongroup_population(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::push(L, instance.population);
    return 1;  // 1 return value
}
static int set_mongroup_population(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.population = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mongroup_radius(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::push(L, instance.radius);
    return 1;  // 1 return value
}
static int set_mongroup_radius(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.radius = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mongroup_diffuse(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::push(L, instance.diffuse);
    return 1;  // 1 return value
}
static int set_mongroup_diffuse(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.diffuse = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mongroup_target(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaValue<tripoint>::push(L, instance.target);
    return 1;  // 1 return value
}
static int get_mongroup_horde(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::push(L, instance.horde);
    return 1;  // 1 return value
}
static int set_mongroup_horde(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.horde = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mongroup_dying(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::push(L, instance.dying);
    return 1;  // 1 return value
}
static int set_mongroup_dying(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.dying = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mongroup_pos(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaValue<tripoint>::push(L, instance.pos);
    return 1;  // 1 return value
}
static int get_ter_t_trap(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<trap_id>::push(L, instance.trap);
    return 1;  // 1 return value
}
static int set_ter_t_trap(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<trap_id>::check(L, 2);;
    instance.trap = LuaValue<trap_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_ter_t_roof(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::push(L, instance.roof);
    return 1;  // 1 return value
}
static int set_ter_t_roof(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::check(L, 2);;
    instance.roof = LuaValue<ter_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_ter_t_name(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int get_ter_t_close(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::push(L, instance.close);
    return 1;  // 1 return value
}
static int set_ter_t_close(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::check(L, 2);;
    instance.close = LuaValue<ter_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_ter_t_id(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::push(L, instance.id);
    return 1;  // 1 return value
}
static int get_ter_t_movecost(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaType<int>::push(L, instance.movecost);
    return 1;  // 1 return value
}
static int set_ter_t_movecost(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.movecost = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_ter_t_open(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::push(L, instance.open);
    return 1;  // 1 return value
}
static int set_ter_t_open(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::check(L, 2);;
    instance.open = LuaValue<ter_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_ter_t_transforms_into(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::push(L, instance.transforms_into);
    return 1;  // 1 return value
}
static int set_ter_t_transforms_into(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    LuaValue<ter_str_id>::check(L, 2);;
    instance.transforms_into = LuaValue<ter_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_tripoint_y(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::push(L, instance.y);
    return 1;  // 1 return value
}
static int set_tripoint_y(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.y = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_tripoint_x(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::push(L, instance.x);
    return 1;  // 1 return value
}
static int set_tripoint_x(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.x = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_tripoint_z(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::push(L, instance.z);
    return 1;  // 1 return value
}
static int set_tripoint_z(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.z = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_name(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<std::string>::push(L, instance.name);
    return 1;  // 1 return value
}
static int set_furn_t_name(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.name = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_transparent(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<bool>::push(L, instance.transparent);
    return 1;  // 1 return value
}
static int set_furn_t_transparent(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.transparent = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_movecost(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<int>::push(L, instance.movecost);
    return 1;  // 1 return value
}
static int set_furn_t_movecost(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.movecost = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_close(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<furn_str_id>::push(L, instance.close);
    return 1;  // 1 return value
}
static int set_furn_t_close(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<furn_str_id>::check(L, 2);;
    instance.close = LuaValue<furn_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_id(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<furn_str_id>::push(L, instance.id);
    return 1;  // 1 return value
}
static int get_furn_t_move_str_req(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<int>::push(L, instance.move_str_req);
    return 1;  // 1 return value
}
static int set_furn_t_move_str_req(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.move_str_req = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_open(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<furn_str_id>::push(L, instance.open);
    return 1;  // 1 return value
}
static int set_furn_t_open(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<furn_str_id>::check(L, 2);;
    instance.open = LuaValue<furn_str_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_furn_t_max_volume(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<volume>::push(L, instance.max_volume);
    return 1;  // 1 return value
}
static int set_furn_t_max_volume(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    LuaValue<volume>::check(L, 2);;
    instance.max_volume = LuaValue<volume>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_min_per(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.min_per);
    return 1;  // 1 return value
}
static int set_itype_min_per(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.min_per = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_description(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::push(L, instance.description);
    return 1;  // 1 return value
}
static int set_itype_description(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.description = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_color(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.color);
    return 1;  // 1 return value
}
static int set_itype_color(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.color = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_snippet_category(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::push(L, instance.snippet_category);
    return 1;  // 1 return value
}
static int set_itype_snippet_category(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.snippet_category = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_volume(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::push(L, instance.volume);
    return 1;  // 1 return value
}
static int set_itype_volume(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::check(L, 2);;
    instance.volume = LuaValue<volume>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_magazine_well(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::push(L, instance.magazine_well);
    return 1;  // 1 return value
}
static int set_itype_magazine_well(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::check(L, 2);;
    instance.magazine_well = LuaValue<volume>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_min_dex(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.min_dex);
    return 1;  // 1 return value
}
static int set_itype_min_dex(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.min_dex = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_integral_volume(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::push(L, instance.integral_volume);
    return 1;  // 1 return value
}
static int set_itype_integral_volume(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaValue<volume>::check(L, 2);;
    instance.integral_volume = LuaValue<volume>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_stack_size(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.stack_size);
    return 1;  // 1 return value
}
static int set_itype_stack_size(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.stack_size = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_phase(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaEnum<phase_id>::push(L, instance.phase);
    return 1;  // 1 return value
}
static int set_itype_phase(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaEnum<phase_id>::check(L, 2);;
    instance.phase = LuaEnum<phase_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_explode_in_fire(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<bool>::push(L, instance.explode_in_fire);
    return 1;  // 1 return value
}
static int set_itype_explode_in_fire(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.explode_in_fire = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_min_int(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.min_int);
    return 1;  // 1 return value
}
static int set_itype_min_int(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.min_int = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_weight(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.weight);
    return 1;  // 1 return value
}
static int set_itype_weight(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.weight = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_rigid(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<bool>::push(L, instance.rigid);
    return 1;  // 1 return value
}
static int set_itype_rigid(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.rigid = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_sym(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::push(L, instance.sym);
    return 1;  // 1 return value
}
static int set_itype_sym(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.sym = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_price_post(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.price_post);
    return 1;  // 1 return value
}
static int set_itype_price_post(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.price_post = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_light_emission(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.light_emission);
    return 1;  // 1 return value
}
static int set_itype_light_emission(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.light_emission = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_default_container(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::push(L, instance.default_container);
    return 1;  // 1 return value
}
static int set_itype_default_container(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.default_container = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_price(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.price);
    return 1;  // 1 return value
}
static int set_itype_price(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.price = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_min_str(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.min_str);
    return 1;  // 1 return value
}
static int set_itype_min_str(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.min_str = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_itype_m_to_hit(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::push(L, instance.m_to_hit);
    return 1;  // 1 return value
}
static int set_itype_m_to_hit(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.m_to_hit = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_anger(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.anger);
    return 1;  // 1 return value
}
static int set_monster_anger(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.anger = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_type(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<mtype>::push(L, instance.type);
    return 1;  // 1 return value
}
static int get_monster_no_extra_death_drops(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::push(L, instance.no_extra_death_drops);
    return 1;  // 1 return value
}
static int set_monster_no_extra_death_drops(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.no_extra_death_drops = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_wandf(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.wandf);
    return 1;  // 1 return value
}
static int set_monster_wandf(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.wandf = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_wander_pos(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::push(L, instance.wander_pos);
    return 1;  // 1 return value
}
static int set_monster_wander_pos(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);;
    instance.wander_pos = LuaValue<tripoint>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_friendly(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.friendly);
    return 1;  // 1 return value
}
static int set_monster_friendly(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.friendly = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_hallucination(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::push(L, instance.hallucination);
    return 1;  // 1 return value
}
static int set_monster_hallucination(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.hallucination = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_last_updated(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.last_updated);
    return 1;  // 1 return value
}
static int set_monster_last_updated(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.last_updated = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_mission_id(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.mission_id);
    return 1;  // 1 return value
}
static int set_monster_mission_id(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.mission_id = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_staircount(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.staircount);
    return 1;  // 1 return value
}
static int set_monster_staircount(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.staircount = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_morale(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.morale);
    return 1;  // 1 return value
}
static int set_monster_morale(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.morale = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_unique_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::push(L, instance.unique_name);
    return 1;  // 1 return value
}
static int set_monster_unique_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.unique_name = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_ignoring(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::push(L, instance.ignoring);
    return 1;  // 1 return value
}
static int set_monster_ignoring(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.ignoring = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_no_corpse_quiet(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::push(L, instance.no_corpse_quiet);
    return 1;  // 1 return value
}
static int set_monster_no_corpse_quiet(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.no_corpse_quiet = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_monster_made_footstep(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::push(L, instance.made_footstep);
    return 1;  // 1 return value
}
static int set_monster_made_footstep(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.made_footstep = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_encumbrance_data_armor_encumbrance(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::push(L, instance.armor_encumbrance);
    return 1;  // 1 return value
}
static int set_encumbrance_data_armor_encumbrance(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_encumbrance = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_encumbrance_data_layer_penalty(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::push(L, instance.layer_penalty);
    return 1;  // 1 return value
}
static int set_encumbrance_data_layer_penalty(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.layer_penalty = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_encumbrance_data_encumbrance(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::push(L, instance.encumbrance);
    return 1;  // 1 return value
}
static int set_encumbrance_data_encumbrance(lua_State *L) {
    encumbrance_data& instance = LuaValue<encumbrance_data>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.encumbrance = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_melee_sides(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.melee_sides);
    return 1;  // 1 return value
}
static int set_mtype_melee_sides(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.melee_sides = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_description(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::push(L, instance.description);
    return 1;  // 1 return value
}
static int set_mtype_description(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.description = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_armor_stab(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.armor_stab);
    return 1;  // 1 return value
}
static int set_mtype_armor_stab(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_stab = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_armor_bash(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.armor_bash);
    return 1;  // 1 return value
}
static int set_mtype_armor_bash(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_bash = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_melee_skill(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.melee_skill);
    return 1;  // 1 return value
}
static int set_mtype_melee_skill(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.melee_skill = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_hp(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.hp);
    return 1;  // 1 return value
}
static int set_mtype_hp(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.hp = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_vision_day(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.vision_day);
    return 1;  // 1 return value
}
static int set_mtype_vision_day(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.vision_day = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_attack_cost(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.attack_cost);
    return 1;  // 1 return value
}
static int set_mtype_attack_cost(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.attack_cost = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_half_life(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.half_life);
    return 1;  // 1 return value
}
static int set_mtype_half_life(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.half_life = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_armor_cut(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.armor_cut);
    return 1;  // 1 return value
}
static int set_mtype_armor_cut(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_cut = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_armor_fire(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.armor_fire);
    return 1;  // 1 return value
}
static int set_mtype_armor_fire(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_fire = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_speed(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.speed);
    return 1;  // 1 return value
}
static int set_mtype_speed(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.speed = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_death_drops(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::push(L, instance.death_drops);
    return 1;  // 1 return value
}
static int set_mtype_death_drops(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.death_drops = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_luminance(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<float>::push(L, instance.luminance);
    return 1;  // 1 return value
}
static int set_mtype_luminance(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<float>::check(L, 2);;
    instance.luminance = LuaType<float>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_size(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaEnum<m_size>::push(L, instance.size);
    return 1;  // 1 return value
}
static int set_mtype_size(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaEnum<m_size>::check(L, 2);;
    instance.size = LuaEnum<m_size>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_upgrades(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<bool>::push(L, instance.upgrades);
    return 1;  // 1 return value
}
static int set_mtype_upgrades(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<bool>::check(L, 2);;
    instance.upgrades = LuaType<bool>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_upgrade_group(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<mongroup_id>::push(L, instance.upgrade_group);
    return 1;  // 1 return value
}
static int set_mtype_upgrade_group(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<mongroup_id>::check(L, 2);;
    instance.upgrade_group = LuaValue<mongroup_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_id(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<mtype_id>::push(L, instance.id);
    return 1;  // 1 return value
}
static int get_mtype_sk_dodge(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.sk_dodge);
    return 1;  // 1 return value
}
static int set_mtype_sk_dodge(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.sk_dodge = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_armor_acid(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.armor_acid);
    return 1;  // 1 return value
}
static int set_mtype_armor_acid(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.armor_acid = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_upgrade_into(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<mtype_id>::push(L, instance.upgrade_into);
    return 1;  // 1 return value
}
static int set_mtype_upgrade_into(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);;
    instance.upgrade_into = LuaValue<mtype_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_melee_dice(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.melee_dice);
    return 1;  // 1 return value
}
static int set_mtype_melee_dice(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.melee_dice = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_phase(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaEnum<phase_id>::push(L, instance.phase);
    return 1;  // 1 return value
}
static int set_mtype_phase(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaEnum<phase_id>::check(L, 2);;
    instance.phase = LuaEnum<phase_id>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_def_chance(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.def_chance);
    return 1;  // 1 return value
}
static int set_mtype_def_chance(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.def_chance = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_sym(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::push(L, instance.sym);
    return 1;  // 1 return value
}
static int set_mtype_sym(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.sym = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_vision_night(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.vision_night);
    return 1;  // 1 return value
}
static int set_mtype_vision_night(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.vision_night = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_morale(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.morale);
    return 1;  // 1 return value
}
static int set_mtype_morale(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.morale = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_agro(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.agro);
    return 1;  // 1 return value
}
static int set_mtype_agro(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.agro = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_difficulty(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.difficulty);
    return 1;  // 1 return value
}
static int set_mtype_difficulty(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.difficulty = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_color(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::push(L, instance.color);
    return 1;  // 1 return value
}
static int set_mtype_color(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<int>::check(L, 2);;
    instance.color = LuaType<int>::get(L, 2);
    return 0;  // 0 return values
}
static int get_mtype_revert_to_itype(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::push(L, instance.revert_to_itype);
    return 1;  // 1 return value
}
static int set_mtype_revert_to_itype(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);;
    instance.revert_to_itype = LuaType<std::string>::get(L, 2);
    return 0;  // 0 return values
}
static int func_stats_reset(lua_State *L) {
    stats& instance = LuaReference<stats>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset, expected only 1, got %d", lua_gettop(L));
    }
    instance.reset();
    return 0; // 0 return values
}
static int func_MonsterGroup_IsMonsterInGroup(lua_State *L) {
    MonsterGroup& instance = LuaReference<MonsterGroup>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to IsMonsterInGroup, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.IsMonsterInGroup(parameter1));
    return 1; // 1 return values
}
static int func_ammotype_str(lua_State *L) {
    ammotype& instance = LuaValue<ammotype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_ammotype_is_valid(lua_State *L) {
    ammotype& instance = LuaValue<ammotype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_ammotype_obj(lua_State *L) {
    ammotype& instance = LuaValue<ammotype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<ammunition_type>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_ammotype(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ammotype::ammotype, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ammotype>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<ammotype>::has(L, 2)) {
        auto && parameter1 = LuaValue<ammotype>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ammotype::ammotype, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ammotype>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to ammotype::ammotype, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<ammotype>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or ammotype or nothing at all");
}
static int op_ammotype_eq(lua_State *L) {
    const ammotype &lhs = LuaValue<ammotype>::get(L, 1);
    const ammotype &rhs = LuaValue<ammotype>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_item_location_obtain(lua_State *L) {
    item_location& instance = LuaValue<item_location>::get(L, 1);
    LuaReference<Character>::check(L, 2);
    auto && parameter1 = LuaReference<Character>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to obtain, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.obtain(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to obtain, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.obtain(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_item_location_describe(lua_State *L) {
    item_location& instance = LuaValue<item_location>::get(L, 1);
    if(LuaReference<Character>::has(L, 2)) {
        auto && parameter1 = LuaReference<Character>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to describe, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.describe(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to describe, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.describe());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are Character or nothing at all");
}
static int func_item_location_obtain_cost(lua_State *L) {
    item_location& instance = LuaValue<item_location>::get(L, 1);
    LuaReference<Character>::check(L, 2);
    auto && parameter1 = LuaReference<Character>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to obtain_cost, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.obtain_cost(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to obtain_cost, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.obtain_cost(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_item_location_remove_item(lua_State *L) {
    item_location& instance = LuaValue<item_location>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to remove_item, expected only 1, got %d", lua_gettop(L));
    }
    instance.remove_item();
    return 0; // 0 return values
}
static int func_item_location_get_item(lua_State *L) {
    item_location& instance = LuaValue<item_location>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_item, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.get_item());
    return 1; // 1 return values
}
static int func_skill_id_str(lua_State *L) {
    skill_id& instance = LuaValue<skill_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_skill_id_is_valid(lua_State *L) {
    skill_id& instance = LuaValue<skill_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_skill_id_obj(lua_State *L) {
    skill_id& instance = LuaValue<skill_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Skill>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_skill_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to skill_id::skill_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<skill_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<skill_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<skill_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to skill_id::skill_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<skill_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to skill_id::skill_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<skill_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or skill_id or nothing at all");
}
static int op_skill_id_eq(lua_State *L) {
    const skill_id &lhs = LuaValue<skill_id>::get(L, 1);
    const skill_id &rhs = LuaValue<skill_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_quality_id_str(lua_State *L) {
    quality_id& instance = LuaValue<quality_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_quality_id_is_valid(lua_State *L) {
    quality_id& instance = LuaValue<quality_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_quality_id_obj(lua_State *L) {
    quality_id& instance = LuaValue<quality_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<quality>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_quality_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to quality_id::quality_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<quality_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<quality_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<quality_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to quality_id::quality_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<quality_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to quality_id::quality_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<quality_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or quality_id or nothing at all");
}
static int op_quality_id_eq(lua_State *L) {
    const quality_id &lhs = LuaValue<quality_id>::get(L, 1);
    const quality_id &rhs = LuaValue<quality_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_mtype_id_str(lua_State *L) {
    mtype_id& instance = LuaValue<mtype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_mtype_id_is_valid(lua_State *L) {
    mtype_id& instance = LuaValue<mtype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_mtype_id_obj(lua_State *L) {
    mtype_id& instance = LuaValue<mtype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<mtype>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_mtype_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mtype_id::mtype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mtype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<mtype_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mtype_id::mtype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mtype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to mtype_id::mtype_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<mtype_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or mtype_id or nothing at all");
}
static int op_mtype_id_eq(lua_State *L) {
    const mtype_id &lhs = LuaValue<mtype_id>::get(L, 1);
    const mtype_id &rhs = LuaValue<mtype_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_map_board_vehicle(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<player>::check(L, 3);
    auto && parameter2 = LuaReference<player>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to board_vehicle, expected only 3, got %d", lua_gettop(L));
    }
    instance.board_vehicle(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_tername(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to tername, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.tername(parameter1));
    return 1; // 1 return values
}
static int func_map_max_volume(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to max_volume, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.max_volume(parameter1));
    return 1; // 1 return values
}
static int func_map_furn_set(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaValue<furn_str_id>::has(L, 3)) {
        auto && parameter2 = LuaValue<furn_str_id>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to furn_set, expected only 3, got %d", lua_gettop(L));
        }
        instance.furn_set(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(LuaValue<furn_id>::has(L, 3)) {
        auto && parameter2 = LuaValue<furn_id>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to furn_set, expected only 3, got %d", lua_gettop(L));
        }
        instance.furn_set(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are furn_str_id or furn_id");
}
static int func_map_is_divable(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_divable, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_divable(parameter1));
    return 1; // 1 return values
}
static int func_map_draw_fill_background(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to draw_fill_background, expected only 2, got %d", lua_gettop(L));
        }
        instance.draw_fill_background(parameter1);
        return 0; // 0 return values
    }
    if(LuaValue<ter_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to draw_fill_background, expected only 2, got %d", lua_gettop(L));
        }
        instance.draw_fill_background(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_str_id or ter_id");
}
static int func_map_set_temperature(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_temperature, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_temperature(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_stored_volume(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to stored_volume, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.stored_volume(parameter1));
    return 1; // 1 return values
}
static int func_map_place_npc(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<std::string>::check(L, 4);
    auto && parameter3 = LuaType<std::string>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to place_npc, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.place_npc(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_trigger_rc_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to trigger_rc_items, expected only 2, got %d", lua_gettop(L));
    }
    instance.trigger_rc_items(parameter1);
    return 0; // 0 return values
}
static int func_map_load(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<bool>::check(L, 5);
    auto && parameter4 = LuaType<bool>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to load, expected only 5, got %d", lua_gettop(L));
    }
    instance.load(parameter1, parameter2, parameter3, parameter4);
    return 0; // 0 return values
}
static int func_map_getmapsize(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getmapsize, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.getmapsize());
    return 1; // 1 return values
}
static int func_map_draw_rough_circle_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_rough_circle_ter, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_rough_circle_ter(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    if(LuaValue<ter_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_rough_circle_ter, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_rough_circle_ter(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_str_id or ter_id");
}
static int func_map_make_rubble(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaValue<furn_id>::has(L, 3)) {
        auto && parameter2 = LuaValue<furn_id>::get(L, 3);
        LuaType<bool>::check(L, 4);
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(LuaValue<ter_id>::has(L, 5)) {
            auto && parameter4 = LuaValue<ter_id>::get(L, 5);
            if(LuaType<bool>::has(L, 6)) {
                auto && parameter5 = LuaType<bool>::get(L, 6);
                if(lua_gettop(L) > 6) {
                    return luaL_error(L, "Too many arguments to make_rubble, expected only 6, got %d", lua_gettop(L));
                }
                instance.make_rubble(parameter1, parameter2, parameter3, parameter4, parameter5);
                return 0; // 0 return values
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to make_rubble, expected only 5, got %d", lua_gettop(L));
                }
                instance.make_rubble(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are bool or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to make_rubble, expected only 4, got %d", lua_gettop(L));
            }
            instance.make_rubble(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are ter_id or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to make_rubble, expected only 2, got %d", lua_gettop(L));
        }
        instance.make_rubble(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are furn_id or nothing at all");
}
static int func_map_could_see_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<Creature>::check(L, 3);
    auto && parameter2 = LuaReference<Creature>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to could_see_items, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.could_see_items(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_draw_circle_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_circle_furn, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_circle_furn(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    if(LuaValue<furn_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_circle_furn, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_circle_furn(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or furn_id");
}
static int func_map_draw_square_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_square_furn, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_square_furn(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    if(LuaValue<furn_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_square_furn, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_square_furn(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or furn_id");
}
static int func_map_impassable(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to impassable, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.impassable(parameter1));
    return 1; // 1 return values
}
static int func_map_fungalize(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaReference<Creature>::has(L, 3)) {
        auto && parameter2 = LuaReference<Creature>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to fungalize, expected only 4, got %d", lua_gettop(L));
            }
            instance.fungalize(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to fungalize, expected only 3, got %d", lua_gettop(L));
            }
            instance.fungalize(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to fungalize, expected only 2, got %d", lua_gettop(L));
        }
        instance.fungalize(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are Creature or nothing at all");
}
static int func_map_displace_vehicle(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to displace_vehicle, expected only 3, got %d", lua_gettop(L));
    }
    instance.displace_vehicle(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_has_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_items, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_items(parameter1));
    return 1; // 1 return values
}
static int func_map_has_floor_or_support(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_floor_or_support, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_floor_or_support(parameter1));
    return 1; // 1 return values
}
static int func_map_has_flag_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_flag_ter, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag_ter(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_add_item_or_charges(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to add_item_or_charges, expected only 4, got %d", lua_gettop(L));
        }
        LuaReference<item>::push(L, instance.add_item_or_charges(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_item_or_charges, expected only 3, got %d", lua_gettop(L));
        }
        LuaReference<item>::push(L, instance.add_item_or_charges(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_hit_with_fire(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to hit_with_fire, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.hit_with_fire(parameter1));
    return 1; // 1 return values
}
static int func_map_place_vending(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<std::string>::check(L, 4);
    auto && parameter3 = LuaType<std::string>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to place_vending, expected only 4, got %d", lua_gettop(L));
    }
    instance.place_vending(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_map_create_spores(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaReference<Creature>::has(L, 3)) {
        auto && parameter2 = LuaReference<Creature>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to create_spores, expected only 3, got %d", lua_gettop(L));
        }
        instance.create_spores(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to create_spores, expected only 2, got %d", lua_gettop(L));
        }
        instance.create_spores(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are Creature or nothing at all");
}
static int func_map_bash_strength(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to bash_strength, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_strength(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to bash_strength, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_strength(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_combined_movecost(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to combined_movecost, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.combined_movecost(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_clear_traps(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_traps, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_traps();
    return 0; // 0 return values
}
static int func_map_disarm_trap(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to disarm_trap, expected only 2, got %d", lua_gettop(L));
    }
    instance.disarm_trap(parameter1);
    return 0; // 0 return values
}
static int func_map_save(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to save, expected only 1, got %d", lua_gettop(L));
    }
    instance.save();
    return 0; // 0 return values
}
static int func_map_is_outside(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_outside, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_outside(parameter1));
    return 1; // 1 return values
}
static int func_map_veh_part_coordinates(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to veh_part_coordinates, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<point>::push(L, instance.veh_part_coordinates(parameter1));
    return 1; // 1 return values
}
static int func_map_mop_spills(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mop_spills, expected only 2, got %d", lua_gettop(L));
    }
    instance.mop_spills(parameter1);
    return 0; // 0 return values
}
static int func_map_clear_path(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    LuaType<int>::check(L, 6);
    auto && parameter5 = LuaType<int>::get(L, 6);
    if(lua_gettop(L) > 6) {
        return luaL_error(L, "Too many arguments to clear_path, expected only 6, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.clear_path(parameter1, parameter2, parameter3, parameter4, parameter5));
    return 1; // 1 return values
}
static int func_map_is_bashable(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to is_bashable, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to is_bashable, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_add_trap(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<trap_id>::check(L, 3);
    auto && parameter2 = LuaValue<trap_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_trap, expected only 3, got %d", lua_gettop(L));
    }
    instance.add_trap(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_disp_name(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to disp_name, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.disp_name(parameter1));
    return 1; // 1 return values
}
static int func_map_delete_graffiti(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to delete_graffiti, expected only 2, got %d", lua_gettop(L));
    }
    instance.delete_graffiti(parameter1);
    return 0; // 0 return values
}
static int func_map_light_transparency(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to light_transparency, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.light_transparency(parameter1));
    return 1; // 1 return values
}
static int func_map_has_adjacent_furniture(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_adjacent_furniture, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_adjacent_furniture(parameter1));
    return 1; // 1 return values
}
static int func_map_name(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to name, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.name(parameter1));
    return 1; // 1 return values
}
static int func_map_creature_on_trap(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to creature_on_trap, expected only 3, got %d", lua_gettop(L));
        }
        instance.creature_on_trap(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to creature_on_trap, expected only 2, got %d", lua_gettop(L));
        }
        instance.creature_on_trap(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_sees_some_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<Creature>::check(L, 3);
    auto && parameter2 = LuaReference<Creature>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to sees_some_items, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.sees_some_items(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_displace_water(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to displace_water, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.displace_water(parameter1));
    return 1; // 1 return values
}
static int func_map_put_items_from_loc(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to put_items_from_loc, expected only 4, got %d", lua_gettop(L));
        }
        instance.put_items_from_loc(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to put_items_from_loc, expected only 3, got %d", lua_gettop(L));
        }
        instance.put_items_from_loc(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_map_spawn_an_item(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to spawn_an_item, expected only 5, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.spawn_an_item(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_map_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to ter, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<ter_id>::push(L, instance.ter(parameter1));
    return 1; // 1 return values
}
static int func_map_set_signage(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_signage, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_signage(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_crush(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to crush, expected only 2, got %d", lua_gettop(L));
    }
    instance.crush(parameter1);
    return 0; // 0 return values
}
static int func_map_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<furn_id>::push(L, instance.furn(parameter1));
    return 1; // 1 return values
}
static int func_map_close_door(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to close_door, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.close_door(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_getlocal(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to getlocal, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.getlocal(parameter1));
    return 1; // 1 return values
}
static int func_map_creature_in_field(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to creature_in_field, expected only 2, got %d", lua_gettop(L));
    }
    instance.creature_in_field(parameter1);
    return 0; // 0 return values
}
static int func_map_move_cost(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_cost, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.move_cost(parameter1));
    return 1; // 1 return values
}
static int func_map_place_gas_pump(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(LuaType<std::string>::has(L, 5)) {
        auto && parameter4 = LuaType<std::string>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to place_gas_pump, expected only 5, got %d", lua_gettop(L));
        }
        instance.place_gas_pump(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 4) {
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to place_gas_pump, expected only 4, got %d", lua_gettop(L));
        }
        instance.place_gas_pump(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 4, "Unexpected type, expected are string or nothing at all");
}
static int func_map_get_field_strength(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to get_field_strength, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_field_strength(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_adjust_field_strength(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to adjust_field_strength, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.adjust_field_strength(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_get_signage(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_signage, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_signage(parameter1));
    return 1; // 1 return values
}
static int func_map_trans(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to trans, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.trans(parameter1));
    return 1; // 1 return values
}
static int func_map_decay_fields_and_scent(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to decay_fields_and_scent, expected only 2, got %d", lua_gettop(L));
    }
    instance.decay_fields_and_scent(parameter1);
    return 0; // 0 return values
}
static int func_map_draw_rough_circle_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_rough_circle_furn, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_rough_circle_furn(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    if(LuaValue<furn_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_rough_circle_furn, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_rough_circle_furn(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or furn_id");
}
static int func_map_remove_trap(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_trap, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_trap(parameter1);
    return 0; // 0 return values
}
static int func_map_is_bashable_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to is_bashable_ter, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable_ter(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to is_bashable_ter, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable_ter(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_passable(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to passable, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.passable(parameter1));
    return 1; // 1 return values
}
static int func_map_water_from(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to water_from, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<item>::push(L, instance.water_from(parameter1));
    return 1; // 1 return values
}
static int func_map_adjust_radiation(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to adjust_radiation, expected only 3, got %d", lua_gettop(L));
    }
    instance.adjust_radiation(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_has_floor(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_floor, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_floor(parameter1));
    return 1; // 1 return values
}
static int func_map_marlossify(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to marlossify, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.marlossify(parameter1));
    return 1; // 1 return values
}
static int func_map_features(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to features, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.features(parameter1));
    return 1; // 1 return values
}
static int func_map_climb_difficulty(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to climb_difficulty, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.climb_difficulty(parameter1));
    return 1; // 1 return values
}
static int func_map_unboard_vehicle(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to unboard_vehicle, expected only 2, got %d", lua_gettop(L));
    }
    instance.unboard_vehicle(parameter1);
    return 0; // 0 return values
}
static int func_map_on_vehicle_moved(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_vehicle_moved, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_vehicle_moved(parameter1);
    return 0; // 0 return values
}
static int func_map_clear_spawns(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_spawns, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_spawns();
    return 0; // 0 return values
}
static int func_map_get_radiation(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_radiation, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_radiation(parameter1));
    return 1; // 1 return values
}
static int func_map_is_bashable_ter_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to is_bashable_ter_furn, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable_ter_furn(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to is_bashable_ter_furn, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_bashable_ter_furn(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_get_abs_sub(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_abs_sub, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.get_abs_sub());
    return 1; // 1 return values
}
static int func_map_add_field(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to add_field, expected only 5, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.add_field(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_map_i_rem(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaValue<item_stack_iterator>::has(L, 3)) {
        auto && parameter2 = LuaValue<item_stack_iterator>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 3, got %d", lua_gettop(L));
        }
        LuaValue<item_stack_iterator>::push(L, instance.i_rem(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.i_rem(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValueOrReference<item>::has(L, 3)) {
        auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 3, got %d", lua_gettop(L));
        }
        instance.i_rem(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are item_stack_iterator or int or item");
}
static int func_map_item_from(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to item_from, expected only 3, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.item_from(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_impassable_ter_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to impassable_ter_furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.impassable_ter_furn(parameter1));
    return 1; // 1 return values
}
static int func_map_has_flag_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_flag_furn, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag_furn(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_spawn_item(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(LuaType<int>::has(L, 5)) {
            auto && parameter4 = LuaType<int>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<int>::has(L, 7)) {
                    auto && parameter6 = LuaType<int>::get(L, 7);
                    if(lua_gettop(L) > 7) {
                        return luaL_error(L, "Too many arguments to spawn_item, expected only 7, got %d", lua_gettop(L));
                    }
                    instance.spawn_item(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to spawn_item, expected only 6, got %d", lua_gettop(L));
                    }
                    instance.spawn_item(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are int or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to spawn_item, expected only 5, got %d", lua_gettop(L));
                }
                instance.spawn_item(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to spawn_item, expected only 4, got %d", lua_gettop(L));
            }
            instance.spawn_item(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to spawn_item, expected only 3, got %d", lua_gettop(L));
        }
        instance.spawn_item(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_map_accessible_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to accessible_items, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.accessible_items(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_accessible_furniture(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to accessible_furniture, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.accessible_furniture(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_has_graffiti_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_graffiti_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_graffiti_at(parameter1));
    return 1; // 1 return values
}
static int func_map_add_corpse(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to add_corpse, expected only 2, got %d", lua_gettop(L));
    }
    instance.add_corpse(parameter1);
    return 0; // 0 return values
}
static int func_map_can_put_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to can_put_items, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_put_items(parameter1));
    return 1; // 1 return values
}
static int func_map_has_nearby_fire(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_nearby_fire, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_nearby_fire(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_nearby_fire, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_nearby_fire(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_map_has_flag(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_flag, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_pl_sees(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to pl_sees, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.pl_sees(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_i_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<map_stack>::push(L, instance.i_at(parameter1));
    return 1; // 1 return values
}
static int func_map_draw_circle_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<ter_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_id>::get(L, 2);
        if(LuaType<float>::has(L, 3)) {
            auto && parameter2 = LuaType<float>::get(L, 3);
            LuaType<float>::check(L, 4);
            auto && parameter3 = LuaType<float>::get(L, 4);
            LuaType<float>::check(L, 5);
            auto && parameter4 = LuaType<float>::get(L, 5);
            if(lua_gettop(L) > 5) {
                return luaL_error(L, "Too many arguments to draw_circle_ter, expected only 5, got %d", lua_gettop(L));
            }
            instance.draw_circle_ter(parameter1, parameter2, parameter3, parameter4);
            return 0; // 0 return values
        }
        if(LuaType<int>::has(L, 3)) {
            auto && parameter2 = LuaType<int>::get(L, 3);
            LuaType<int>::check(L, 4);
            auto && parameter3 = LuaType<int>::get(L, 4);
            LuaType<int>::check(L, 5);
            auto && parameter4 = LuaType<int>::get(L, 5);
            if(lua_gettop(L) > 5) {
                return luaL_error(L, "Too many arguments to draw_circle_ter, expected only 5, got %d", lua_gettop(L));
            }
            instance.draw_circle_ter(parameter1, parameter2, parameter3, parameter4);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are float or int");
    }
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to draw_circle_ter, expected only 5, got %d", lua_gettop(L));
        }
        instance.draw_circle_ter(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_id or ter_str_id");
}
static int func_map_get_field_age(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to get_field_age, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_field_age(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_translate_radius(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<ter_id>::check(L, 2);
    auto && parameter1 = LuaValue<ter_id>::get(L, 2);
    LuaValue<ter_id>::check(L, 3);
    auto && parameter2 = LuaValue<ter_id>::get(L, 3);
    LuaType<float>::check(L, 4);
    auto && parameter3 = LuaType<float>::get(L, 4);
    LuaValue<tripoint>::check(L, 5);
    auto && parameter4 = LuaValue<tripoint>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to translate_radius, expected only 5, got %d", lua_gettop(L));
    }
    instance.translate_radius(parameter1, parameter2, parameter3, parameter4);
    return 0; // 0 return values
}
static int func_map_trap_set(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<trap_id>::check(L, 3);
    auto && parameter2 = LuaValue<trap_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to trap_set, expected only 3, got %d", lua_gettop(L));
    }
    instance.trap_set(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_translate(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<ter_id>::check(L, 2);
    auto && parameter1 = LuaValue<ter_id>::get(L, 2);
    LuaValue<ter_id>::check(L, 3);
    auto && parameter2 = LuaValue<ter_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to translate, expected only 3, got %d", lua_gettop(L));
    }
    instance.translate(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_tr_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to tr_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<trap>::push(L, instance.tr_at(parameter1));
    return 1; // 1 return values
}
static int func_map_sees(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to sees, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.sees(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_has_flag_ter_or_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_flag_ter_or_furn, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag_ter_or_furn(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_ter_set(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaValue<ter_str_id>::has(L, 3)) {
        auto && parameter2 = LuaValue<ter_str_id>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to ter_set, expected only 3, got %d", lua_gettop(L));
        }
        instance.ter_set(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(LuaValue<ter_id>::has(L, 3)) {
        auto && parameter2 = LuaValue<ter_id>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to ter_set, expected only 3, got %d", lua_gettop(L));
        }
        instance.ter_set(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are ter_str_id or ter_id");
}
static int func_map_supports_above(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to supports_above, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.supports_above(parameter1));
    return 1; // 1 return values
}
static int func_map_bash_resistance(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to bash_resistance, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_resistance(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to bash_resistance, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_resistance(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_draw_line_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_line_ter, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_line_ter(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    if(LuaValue<ter_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_line_ter, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_line_ter(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_str_id or ter_id");
}
static int func_map_is_bashable_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_bashable_furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_bashable_furn(parameter1));
    return 1; // 1 return values
}
static int func_map_coord_to_angle(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to coord_to_angle, expected only 5, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.coord_to_angle(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_map_smash_items(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to smash_items, expected only 3, got %d", lua_gettop(L));
    }
    instance.smash_items(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_free_volume(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to free_volume, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.free_volume(parameter1));
    return 1; // 1 return values
}
static int func_map_destroy_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to destroy_furn, expected only 3, got %d", lua_gettop(L));
        }
        instance.destroy_furn(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to destroy_furn, expected only 2, got %d", lua_gettop(L));
        }
        instance.destroy_furn(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_set_radiation(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_radiation, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_radiation(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_collapse_check(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to collapse_check, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.collapse_check(parameter1));
    return 1; // 1 return values
}
static int func_map_set_graffiti(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_graffiti, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_graffiti(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_set_field_strength(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(LuaType<bool>::has(L, 5)) {
        auto && parameter4 = LuaType<bool>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to set_field_strength, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.set_field_strength(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 4) {
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to set_field_strength, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.set_field_strength(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_set_field_age(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(LuaType<bool>::has(L, 5)) {
        auto && parameter4 = LuaType<bool>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to set_field_age, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.set_field_age(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 4) {
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to set_field_age, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.set_field_age(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_get_ter_transforms_into(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_ter_transforms_into, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<ter_id>::push(L, instance.get_ter_transforms_into(parameter1));
    return 1; // 1 return values
}
static int func_map_spawn_artifact(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to spawn_artifact, expected only 2, got %d", lua_gettop(L));
    }
    instance.spawn_artifact(parameter1);
    return 0; // 0 return values
}
static int func_map_draw_square_ter(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_square_ter, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_square_ter(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    if(LuaValue<ter_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_square_ter, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_square_ter(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_str_id or ter_id");
}
static int func_map_delete_signage(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to delete_signage, expected only 2, got %d", lua_gettop(L));
    }
    instance.delete_signage(parameter1);
    return 0; // 0 return values
}
static int func_map_open_door(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to open_door, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.open_door(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to open_door, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.open_door(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_remove_field(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to remove_field, expected only 3, got %d", lua_gettop(L));
    }
    instance.remove_field(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_ambient_light_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to ambient_light_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.ambient_light_at(parameter1));
    return 1; // 1 return values
}
static int func_map_add_spawn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(LuaType<bool>::has(L, 6)) {
        auto && parameter5 = LuaType<bool>::get(L, 6);
        if(LuaType<int>::has(L, 7)) {
            auto && parameter6 = LuaType<int>::get(L, 7);
            if(LuaType<int>::has(L, 8)) {
                auto && parameter7 = LuaType<int>::get(L, 8);
                if(LuaType<std::string>::has(L, 9)) {
                    auto && parameter8 = LuaType<std::string>::get(L, 9);
                    if(lua_gettop(L) > 9) {
                        return luaL_error(L, "Too many arguments to add_spawn, expected only 9, got %d", lua_gettop(L));
                    }
                    instance.add_spawn(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 8) {
                    if(lua_gettop(L) > 8) {
                        return luaL_error(L, "Too many arguments to add_spawn, expected only 8, got %d", lua_gettop(L));
                    }
                    instance.add_spawn(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 8, "Unexpected type, expected are string or nothing at all");
            }
            if(lua_gettop(L) == 7) {
                if(lua_gettop(L) > 7) {
                    return luaL_error(L, "Too many arguments to add_spawn, expected only 7, got %d", lua_gettop(L));
                }
                instance.add_spawn(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 7, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 6) {
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to add_spawn, expected only 6, got %d", lua_gettop(L));
            }
            instance.add_spawn(parameter1, parameter2, parameter3, parameter4, parameter5);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 6, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 5) {
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to add_spawn, expected only 5, got %d", lua_gettop(L));
        }
        instance.add_spawn(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 5, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_random_outdoor_tile(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to random_outdoor_tile, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<point>::push(L, instance.random_outdoor_tile());
    return 1; // 1 return values
}
static int func_map_hit_with_acid(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to hit_with_acid, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.hit_with_acid(parameter1));
    return 1; // 1 return values
}
static int func_map_spawn_monsters(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to spawn_monsters, expected only 2, got %d", lua_gettop(L));
    }
    instance.spawn_monsters(parameter1);
    return 0; // 0 return values
}
static int func_map_place_toilet(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to place_toilet, expected only 4, got %d", lua_gettop(L));
        }
        instance.place_toilet(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to place_toilet, expected only 3, got %d", lua_gettop(L));
        }
        instance.place_toilet(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_map_place_spawns(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<mongroup_id>::check(L, 2);
    auto && parameter1 = LuaValue<mongroup_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    LuaType<int>::check(L, 6);
    auto && parameter5 = LuaType<int>::get(L, 6);
    LuaType<int>::check(L, 7);
    auto && parameter6 = LuaType<int>::get(L, 7);
    LuaType<float>::check(L, 8);
    auto && parameter7 = LuaType<float>::get(L, 8);
    if(lua_gettop(L) > 8) {
        return luaL_error(L, "Too many arguments to place_spawns, expected only 8, got %d", lua_gettop(L));
    }
    instance.place_spawns(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7);
    return 0; // 0 return values
}
static int func_map_field_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to field_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<field>::push(L, instance.field_at(parameter1));
    return 1; // 1 return values
}
static int func_map_passable_ter_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to passable_ter_furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.passable_ter_furn(parameter1));
    return 1; // 1 return values
}
static int func_map_graffiti_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to graffiti_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.graffiti_at(parameter1));
    return 1; // 1 return values
}
static int func_map_add_item(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_item, expected only 3, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.add_item(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_get_field(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to get_field, expected only 3, got %d", lua_gettop(L));
    }
    LuaReference<field_entry>::push(L, instance.get_field(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_move_cost_ter_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_cost_ter_furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.move_cost_ter_furn(parameter1));
    return 1; // 1 return values
}
static int func_map_destroy(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to destroy, expected only 3, got %d", lua_gettop(L));
        }
        instance.destroy(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to destroy, expected only 2, got %d", lua_gettop(L));
        }
        instance.destroy(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_valid_move(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(lua_gettop(L) > 5) {
                return luaL_error(L, "Too many arguments to valid_move, expected only 5, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.valid_move(parameter1, parameter2, parameter3, parameter4));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to valid_move, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.valid_move(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to valid_move, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.valid_move(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_has_zlevels(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_zlevels, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_zlevels());
    return 1; // 1 return values
}
static int func_map_add_camp(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_camp, expected only 3, got %d", lua_gettop(L));
    }
    instance.add_camp(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_flammable_items_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to flammable_items_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.flammable_items_at(parameter1));
    return 1; // 1 return values
}
static int func_map_allow_camp(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to allow_camp, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.allow_camp(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_map_i_clear(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_clear, expected only 2, got %d", lua_gettop(L));
    }
    instance.i_clear(parameter1);
    return 0; // 0 return values
}
static int func_map_inbounds(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to inbounds, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.inbounds(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to inbounds, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.inbounds(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or tripoint");
}
static int func_map_draw_line_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_line_furn, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_line_furn(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    if(LuaValue<furn_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        LuaType<int>::check(L, 5);
        auto && parameter4 = LuaType<int>::get(L, 5);
        LuaType<int>::check(L, 6);
        auto && parameter5 = LuaType<int>::get(L, 6);
        if(lua_gettop(L) > 6) {
            return luaL_error(L, "Too many arguments to draw_line_furn, expected only 6, got %d", lua_gettop(L));
        }
        instance.draw_line_furn(parameter1, parameter2, parameter3, parameter4, parameter5);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or furn_id");
}
static int func_map_has_furn(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_furn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_furn(parameter1));
    return 1; // 1 return values
}
static int func_map_furnname(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to furnname, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.furnname(parameter1));
    return 1; // 1 return values
}
static int func_map_getabs(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to getabs, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.getabs(parameter1));
    return 1; // 1 return values
}
static int func_map_collapse_at(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to collapse_at, expected only 3, got %d", lua_gettop(L));
    }
    instance.collapse_at(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_map_adjust_field_age(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaEnum<field_id>::check(L, 3);
    auto && parameter2 = LuaEnum<field_id>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to adjust_field_age, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.adjust_field_age(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_map_bash_rating(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to bash_rating, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_rating(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to bash_rating, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_rating(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_map_can_move_furniture(lua_State *L) {
    map& instance = LuaReference<map>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaReference<player>::has(L, 3)) {
        auto && parameter2 = LuaReference<player>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_move_furniture, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_move_furniture(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_move_furniture, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_move_furniture(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are player or nothing at all");
}
static int func_trap_id_to_i(lua_State *L) {
    trap_id& instance = LuaValue<trap_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to to_i, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.to_i());
    return 1; // 1 return values
}
static int func_trap_id_obj(lua_State *L) {
    trap_id& instance = LuaValue<trap_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<trap>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_trap_id(lua_State *L) {
    if(LuaValue<trap_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<trap_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to trap_id::trap_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<trap_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to trap_id::trap_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<trap_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are trap_str_id or nothing at all");
}
static int op_trap_id_eq(lua_State *L) {
    const trap_id &lhs = LuaValue<trap_id>::get(L, 1);
    const trap_id &rhs = LuaValue<trap_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_Creature_is_dead_state(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_dead_state());
    return 1; // 1 return values
}
static int func_Creature_basic_symbol_color(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to basic_symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.basic_symbol_color());
    return 1; // 1 return values
}
static int func_Creature_is_fake(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_fake, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_fake());
    return 1; // 1 return values
}
static int func_Creature_melee_attack(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(LuaValue<matec_id>::has(L, 4)) {
        auto && parameter3 = LuaValue<matec_id>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 4, got %d", lua_gettop(L));
        }
        instance.melee_attack(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 3, got %d", lua_gettop(L));
        }
        instance.melee_attack(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are matec_id or nothing at all");
}
static int func_Creature_get_killer(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_killer, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, instance.get_killer());
    return 1; // 1 return values
}
static int func_Creature_get_armor_bash(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_bash(parameter1));
    return 1; // 1 return values
}
static int func_Creature_posx(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posx, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.posx());
    return 1; // 1 return values
}
static int func_Creature_hp_percentage(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hp_percentage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.hp_percentage());
    return 1; // 1 return values
}
static int func_Creature_gibType(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gibType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.gibType());
    return 1; // 1 return values
}
static int func_Creature_mod_moves(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_moves, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_moves(parameter1);
    return 0; // 0 return values
}
static int func_Creature_bloodType(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bloodType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.bloodType());
    return 1; // 1 return values
}
static int func_Creature_digging(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to digging, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.digging());
    return 1; // 1 return values
}
static int func_Creature_pos(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pos, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.pos());
    return 1; // 1 return values
}
static int func_Creature_has_trait(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_trait(parameter1));
    return 1; // 1 return values
}
static int func_Creature_get_perceived_pain(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_perceived_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_perceived_pain());
    return 1; // 1 return values
}
static int func_Creature_is_monster(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_monster, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_monster());
    return 1; // 1 return values
}
static int func_Creature_get_hp(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_hp(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_hp());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_Creature_set_armor_cut_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_armor_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_env_resist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_env_resist, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_env_resist(parameter1));
    return 1; // 1 return values
}
static int func_Creature_set_fake(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fake, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_fake(parameter1);
    return 0; // 0 return values
}
static int func_Creature_mod_pain(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_pain(parameter1);
    return 0; // 0 return values
}
static int func_Creature_is_hallucination(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hallucination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_hallucination());
    return 1; // 1 return values
}
static int func_Creature_get_throw_resist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_throw_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_throw_resist());
    return 1; // 1 return values
}
static int func_Creature_get_value(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_value, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_value(parameter1));
    return 1; // 1 return values
}
static int func_Creature_set_throw_resist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_throw_resist, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_throw_resist(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_armor_cut_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_cut_bonus());
    return 1; // 1 return values
}
static int func_Creature_skin_name(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to skin_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.skin_name());
    return 1; // 1 return values
}
static int func_Creature_get_hp_max(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_hp_max(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_hp_max());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_Creature_set_cut_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_on_hit(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 4, got %d", lua_gettop(L));
            }
            instance.on_hit(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 3, got %d", lua_gettop(L));
            }
            instance.on_hit(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to on_hit, expected only 2, got %d", lua_gettop(L));
        }
        instance.on_hit(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_mod_stat(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_stat, expected only 3, got %d", lua_gettop(L));
    }
    instance.mod_stat(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Creature_setpos(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setpos, expected only 2, got %d", lua_gettop(L));
    }
    instance.setpos(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_speed_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_speed_bonus());
    return 1; // 1 return values
}
static int func_Creature_get_size(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_size, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<m_size>::push(L, instance.get_size());
    return 1; // 1 return values
}
static int func_Creature_is_warm(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_warm, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_warm());
    return 1; // 1 return values
}
static int func_Creature_process_turn(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_turn, expected only 1, got %d", lua_gettop(L));
    }
    instance.process_turn();
    return 0; // 0 return values
}
static int func_Creature_disp_name(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.disp_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.disp_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_Creature_get_cut_mult(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_cut_mult());
    return 1; // 1 return values
}
static int func_Creature_power_rating(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.power_rating());
    return 1; // 1 return values
}
static int func_Creature_get_name(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_name());
    return 1; // 1 return values
}
static int func_Creature_add_effect(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaEnum<body_part>::has(L, 4)) {
        auto && parameter3 = LuaEnum<body_part>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<bool>::has(L, 7)) {
                    auto && parameter6 = LuaType<bool>::get(L, 7);
                    if(lua_gettop(L) > 7) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 7, got %d", lua_gettop(L));
                    }
                    instance.add_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 6, got %d", lua_gettop(L));
                    }
                    instance.add_effect(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to add_effect, expected only 5, got %d", lua_gettop(L));
                }
                instance.add_effect(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to add_effect, expected only 4, got %d", lua_gettop(L));
            }
            instance.add_effect(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_effect, expected only 3, got %d", lua_gettop(L));
        }
        instance.add_effect(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_get_grab_resist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_grab_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_grab_resist());
    return 1; // 1 return values
}
static int func_Creature_get_effect_int(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_effect_int(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_effect_int(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_get_hit_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_hit_bonus());
    return 1; // 1 return values
}
static int func_Creature_is_immune_effect(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_immune_effect, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_immune_effect(parameter1));
    return 1; // 1 return values
}
static int func_Creature_set_cut_mult(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_mult, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_cut_mult(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_num_dodges(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_num_dodges());
    return 1; // 1 return values
}
static int func_Creature_is_npc(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_npc, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_npc());
    return 1; // 1 return values
}
static int func_Creature_set_bash_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_reset_bonuses(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_bonuses, expected only 1, got %d", lua_gettop(L));
    }
    instance.reset_bonuses();
    return 0; // 0 return values
}
static int func_Creature_get_dodge_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_dodge_bonus());
    return 1; // 1 return values
}
static int func_Creature_set_speed_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_hit_roll(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hit_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.hit_roll());
    return 1; // 1 return values
}
static int func_Creature_get_num_blocks(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_num_blocks());
    return 1; // 1 return values
}
static int func_Creature_on_dodge(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to on_dodge, expected only 3, got %d", lua_gettop(L));
    }
    instance.on_dodge(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Creature_get_bash_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_bash_bonus());
    return 1; // 1 return values
}
static int func_Creature_process_effects(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.process_effects();
    return 0; // 0 return values
}
static int func_Creature_set_dodge_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_num_dodges_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_num_dodges_bonus());
    return 1; // 1 return values
}
static int func_Creature_get_dodge(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_dodge());
    return 1; // 1 return values
}
static int func_Creature_get_dodge_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_dodge_base());
    return 1; // 1 return values
}
static int func_Creature_normalize(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to normalize, expected only 1, got %d", lua_gettop(L));
    }
    instance.normalize();
    return 0; // 0 return values
}
static int func_Creature_mod_bash_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_num_dodges_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_dodges_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_num_dodges_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_mod_hit_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_sight_range(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sight_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.sight_range(parameter1));
    return 1; // 1 return values
}
static int func_Creature_reset(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset, expected only 1, got %d", lua_gettop(L));
    }
    instance.reset();
    return 0; // 0 return values
}
static int func_Creature_speed_rating(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to speed_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.speed_rating());
    return 1; // 1 return values
}
static int func_Creature_get_num_blocks_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_num_blocks_bonus());
    return 1; // 1 return values
}
static int func_Creature_get_armor_bash_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_bash_base(parameter1));
    return 1; // 1 return values
}
static int func_Creature_has_weapon(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_weapon());
    return 1; // 1 return values
}
static int func_Creature_posz(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posz, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.posz());
    return 1; // 1 return values
}
static int func_Creature_get_armor_cut(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_cut(parameter1));
    return 1; // 1 return values
}
static int func_Creature_reset_stats(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_stats, expected only 1, got %d", lua_gettop(L));
    }
    instance.reset_stats();
    return 0; // 0 return values
}
static int func_Creature_set_num_blocks_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_blocks_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_num_blocks_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_mod_cut_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_has_grab_break_tec(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_grab_break_tec, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_grab_break_tec());
    return 1; // 1 return values
}
static int func_Creature_mod_dodge_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_is_symbol_highlighted(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_symbol_highlighted, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_symbol_highlighted());
    return 1; // 1 return values
}
static int func_Creature_move_effects(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_effects, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.move_effects(parameter1));
    return 1; // 1 return values
}
static int func_Creature_get_hit_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_hit_base());
    return 1; // 1 return values
}
static int func_Creature_mod_speed_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_cut_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_cut_bonus());
    return 1; // 1 return values
}
static int func_Creature_in_sleep_state(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_sleep_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.in_sleep_state());
    return 1; // 1 return values
}
static int func_Creature_set_value(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_value, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_value(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Creature_remove_effect(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.remove_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.remove_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_sees(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(LuaReference<Creature>::has(L, 2)) {
        auto && parameter1 = LuaReference<Creature>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaValue<point>::has(L, 2)) {
        auto && parameter1 = LuaValue<point>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.sees(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.sees(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.sees(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are Creature or point or int or tripoint");
}
static int func_Creature_get_weight(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_weight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_weight());
    return 1; // 1 return values
}
static int func_Creature_symbol_color(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.symbol_color());
    return 1; // 1 return values
}
static int func_Creature_weight_capacity(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.weight_capacity());
    return 1; // 1 return values
}
static int func_Creature_uncanny_dodge(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to uncanny_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.uncanny_dodge());
    return 1; // 1 return values
}
static int func_Creature_set_block_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_speed_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_base, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_speed_base(parameter1);
    return 0; // 0 return values
}
static int func_Creature_die(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to die, expected only 2, got %d", lua_gettop(L));
    }
    instance.die(parameter1);
    return 0; // 0 return values
}
static int func_Creature_mod_block_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_symbol(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.symbol());
    return 1; // 1 return values
}
static int func_Creature_knock_back_from(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to knock_back_from, expected only 2, got %d", lua_gettop(L));
    }
    instance.knock_back_from(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_bash_mult(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_mult, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_bash_mult(parameter1);
    return 0; // 0 return values
}
static int func_Creature_deal_melee_attack(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to deal_melee_attack, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.deal_melee_attack(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Creature_avoid_trap(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<trap>::check(L, 3);
    auto && parameter2 = LuaReference<trap>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to avoid_trap, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.avoid_trap(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Creature_clear_effects(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_effects();
    return 0; // 0 return values
}
static int func_Creature_get_bash_mult(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_bash_mult());
    return 1; // 1 return values
}
static int func_Creature_get_speed(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_speed());
    return 1; // 1 return values
}
static int func_Creature_get_block_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_block_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_block_bonus());
    return 1; // 1 return values
}
static int func_Creature_get_speed_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_speed_base());
    return 1; // 1 return values
}
static int func_Creature_has_effect(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_mod_pain_noresist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain_noresist, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_pain_noresist(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_armor_bash_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_armor_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_moves(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_moves, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_moves(parameter1);
    return 0; // 0 return values
}
static int func_Creature_add_env_effect(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(LuaEnum<body_part>::has(L, 6)) {
        auto && parameter5 = LuaEnum<body_part>::get(L, 6);
        if(LuaType<bool>::has(L, 7)) {
            auto && parameter6 = LuaType<bool>::get(L, 7);
            if(LuaType<int>::has(L, 8)) {
                auto && parameter7 = LuaType<int>::get(L, 8);
                if(LuaType<bool>::has(L, 9)) {
                    auto && parameter8 = LuaType<bool>::get(L, 9);
                    if(lua_gettop(L) > 9) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 9, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, instance.add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8));
                    return 1; // 1 return values
                }
                if(lua_gettop(L) == 8) {
                    if(lua_gettop(L) > 8) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 8, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, instance.add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7));
                    return 1; // 1 return values
                }
                return luaL_argerror(L, 8, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 7) {
                if(lua_gettop(L) > 7) {
                    return luaL_error(L, "Too many arguments to add_env_effect, expected only 7, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, instance.add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6));
                return 1; // 1 return values
            }
            return luaL_argerror(L, 7, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 6) {
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to add_env_effect, expected only 6, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 5) {
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to add_env_effect, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.add_env_effect(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 5, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_check_dead_state(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to check_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    instance.check_dead_state();
    return 0; // 0 return values
}
static int func_Creature_set_melee_quiet(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_melee_quiet, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_melee_quiet(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_hit_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Creature_set_grab_resist(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_grab_resist, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_grab_resist(parameter1);
    return 0; // 0 return values
}
static int func_Creature_fall_damage_mod(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fall_damage_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.fall_damage_mod());
    return 1; // 1 return values
}
static int func_Creature_get_random_body_part(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 2, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, instance.get_random_body_part(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 1, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, instance.get_random_body_part());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_Creature_get_melee(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_melee());
    return 1; // 1 return values
}
static int func_Creature_is_elec_immune(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_elec_immune, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_elec_immune());
    return 1; // 1 return values
}
static int func_Creature_is_on_ground(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_on_ground, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_on_ground());
    return 1; // 1 return values
}
static int func_Creature_get_armor_bash_bonus(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_bash_bonus());
    return 1; // 1 return values
}
static int func_Creature_is_underwater(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_underwater, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_underwater());
    return 1; // 1 return values
}
static int func_Creature_stability_roll(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stability_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.stability_roll());
    return 1; // 1 return values
}
static int func_Creature_is_player(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_player, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_player());
    return 1; // 1 return values
}
static int func_Creature_get_effect_dur(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_effect_dur(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_effect_dur(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Creature_apply_damage(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to apply_damage, expected only 4, got %d", lua_gettop(L));
    }
    instance.apply_damage(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_Creature_impact(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to impact, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.impact(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Creature_get_melee_quiet(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee_quiet, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.get_melee_quiet());
    return 1; // 1 return values
}
static int func_Creature_remove_value(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_value, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_value(parameter1);
    return 0; // 0 return values
}
static int func_Creature_posy(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.posy());
    return 1; // 1 return values
}
static int func_Creature_get_pain(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_pain());
    return 1; // 1 return values
}
static int func_Creature_set_pain(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_pain, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_pain(parameter1);
    return 0; // 0 return values
}
static int func_Creature_get_armor_cut_base(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_cut_base(parameter1));
    return 1; // 1 return values
}
static int func_Creature_dodge_roll(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to dodge_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.dodge_roll());
    return 1; // 1 return values
}
static int func_Creature_get_hit(lua_State *L) {
    Creature& instance = LuaReference<Creature>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_hit());
    return 1; // 1 return values
}
static int func_start_location_id_str(lua_State *L) {
    start_location_id& instance = LuaValue<start_location_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_start_location_id_is_valid(lua_State *L) {
    start_location_id& instance = LuaValue<start_location_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_start_location_id_obj(lua_State *L) {
    start_location_id& instance = LuaValue<start_location_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<start_location>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_start_location_id(lua_State *L) {
    if(LuaValue<start_location_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<start_location_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to start_location_id::start_location_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<start_location_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to start_location_id::start_location_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<start_location_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to start_location_id::start_location_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<start_location_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are start_location_id or string or nothing at all");
}
static int op_start_location_id_eq(lua_State *L) {
    const start_location_id &lhs = LuaValue<start_location_id>::get(L, 1);
    const start_location_id &rhs = LuaValue<start_location_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_furn_str_id_str(lua_State *L) {
    furn_str_id& instance = LuaValue<furn_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_furn_str_id_is_valid(lua_State *L) {
    furn_str_id& instance = LuaValue<furn_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_furn_str_id_id(lua_State *L) {
    furn_str_id& instance = LuaValue<furn_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to id, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<furn_id>::push(L, instance.id());
    return 1; // 1 return values
}
static int new_furn_str_id(lua_State *L) {
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to furn_str_id::furn_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<furn_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to furn_str_id::furn_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<furn_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to furn_str_id::furn_str_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<furn_str_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or string or nothing at all");
}
static int op_furn_str_id_eq(lua_State *L) {
    const furn_str_id &lhs = LuaValue<furn_str_id>::get(L, 1);
    const furn_str_id &rhs = LuaValue<furn_str_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_mabuff_id_str(lua_State *L) {
    mabuff_id& instance = LuaValue<mabuff_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_mabuff_id_is_valid(lua_State *L) {
    mabuff_id& instance = LuaValue<mabuff_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_mabuff_id_obj(lua_State *L) {
    mabuff_id& instance = LuaValue<mabuff_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<ma_buff>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_mabuff_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mabuff_id::mabuff_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mabuff_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<mabuff_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<mabuff_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mabuff_id::mabuff_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mabuff_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to mabuff_id::mabuff_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<mabuff_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or mabuff_id or nothing at all");
}
static int op_mabuff_id_eq(lua_State *L) {
    const mabuff_id &lhs = LuaValue<mabuff_id>::get(L, 1);
    const mabuff_id &rhs = LuaValue<mabuff_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_player_mabuff_dodge_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to mabuff_dodge_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.mabuff_dodge_bonus());
    return 1; // 1 return values
}
static int func_player_can_limb_block(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_limb_block, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_limb_block());
    return 1; // 1 return values
}
static int func_player_overmap_sight_range(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to overmap_sight_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.overmap_sight_range(parameter1));
    return 1; // 1 return values
}
static int func_player_fall_asleep(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to fall_asleep, expected only 2, got %d", lua_gettop(L));
    }
    instance.fall_asleep(parameter1);
    return 0; // 0 return values
}
static int func_player_is_quiet(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_quiet, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_quiet());
    return 1; // 1 return values
}
static int func_player_add_pain_msg(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_pain_msg, expected only 3, got %d", lua_gettop(L));
    }
    instance.add_pain_msg(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_can_unwield(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_unwield, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_unwield(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_unwield, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_unwield(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_mutate(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to mutate, expected only 1, got %d", lua_gettop(L));
    }
    instance.mutate();
    return 0; // 0 return values
}
static int func_player_process_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to process_bionic, expected only 2, got %d", lua_gettop(L));
    }
    instance.process_bionic(parameter1);
    return 0; // 0 return values
}
static int func_player_clear_destination(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_destination, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_destination();
    return 0; // 0 return values
}
static int func_player_get_weapon_dispersion(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_weapon_dispersion, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_weapon_dispersion(parameter1));
    return 1; // 1 return values
}
static int func_player_activate_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to activate_bionic, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.activate_bionic(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to activate_bionic, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.activate_bionic(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_scored_crit(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to scored_crit, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.scored_crit(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to scored_crit, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.scored_crit());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_player_on_hurt(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to on_hurt, expected only 3, got %d", lua_gettop(L));
        }
        instance.on_hurt(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to on_hurt, expected only 2, got %d", lua_gettop(L));
        }
        instance.on_hurt(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_invalidate_crafting_inventory(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to invalidate_crafting_inventory, expected only 1, got %d", lua_gettop(L));
    }
    instance.invalidate_crafting_inventory();
    return 0; // 0 return values
}
static int func_player_has_destination(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_destination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_destination());
    return 1; // 1 return values
}
static int func_player_has_identified(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_identified, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_identified(parameter1));
    return 1; // 1 return values
}
static int func_player_num_bionics(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to num_bionics, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.num_bionics());
    return 1; // 1 return values
}
static int func_player_melee_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to melee_value, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.melee_value(parameter1));
    return 1; // 1 return values
}
static int func_player_consume(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to consume, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.consume(parameter1));
    return 1; // 1 return values
}
static int func_player_consume_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to consume_effects, expected only 3, got %d", lua_gettop(L));
        }
        instance.consume_effects(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to consume_effects, expected only 2, got %d", lua_gettop(L));
        }
        instance.consume_effects(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_has_technique(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<matec_id>::check(L, 2);
    auto && parameter1 = LuaValue<matec_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_technique, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_technique(parameter1));
    return 1; // 1 return values
}
static int func_player_adjacent_tile(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to adjacent_tile, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.adjacent_tile());
    return 1; // 1 return values
}
static int func_player_takeoff(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to takeoff, expected only 2, got %d", lua_gettop(L));
    }
    instance.takeoff(parameter1);
    return 0; // 0 return values
}
static int func_player_has_watch(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_watch, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_watch());
    return 1; // 1 return values
}
static int func_player_charges_of(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to charges_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.charges_of(parameter1));
    return 1; // 1 return values
}
static int func_player_can_melee(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_melee());
    return 1; // 1 return values
}
static int func_player_clairvoyance(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clairvoyance, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.clairvoyance());
    return 1; // 1 return values
}
static int func_player_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to craft, expected only 1, got %d", lua_gettop(L));
    }
    instance.craft();
    return 0; // 0 return values
}
static int func_player_use_charges_if_avail(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to use_charges_if_avail, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.use_charges_if_avail(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_has_active_optcloak(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_active_optcloak, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_active_optcloak());
    return 1; // 1 return values
}
static int func_player_mutation_ok(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to mutation_ok, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.mutation_ok(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_player_burn_move_stamina(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to burn_move_stamina, expected only 2, got %d", lua_gettop(L));
    }
    instance.burn_move_stamina(parameter1);
    return 0; // 0 return values
}
static int func_player_perform_special_attacks(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to perform_special_attacks, expected only 2, got %d", lua_gettop(L));
    }
    instance.perform_special_attacks(parameter1);
    return 0; // 0 return values
}
static int func_player_set_cat_level_rec(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cat_level_rec, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_cat_level_rec(parameter1);
    return 0; // 0 return values
}
static int func_player_get_active_mission_target(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_active_mission_target, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.get_active_mission_target());
    return 1; // 1 return values
}
static int func_player_can_leg_block(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_leg_block, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_leg_block());
    return 1; // 1 return values
}
static int func_player_get_category_dream(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to get_category_dream, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_category_dream(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_remove_mutation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_mutation, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_mutation(parameter1);
    return 0; // 0 return values
}
static int func_player_add_martialart(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<matype_id>::check(L, 2);
    auto && parameter1 = LuaValue<matype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to add_martialart, expected only 2, got %d", lua_gettop(L));
    }
    instance.add_martialart(parameter1);
    return 0; // 0 return values
}
static int func_player_boost_skill_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<skill_id>::check(L, 2);
    auto && parameter1 = LuaValue<skill_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to boost_skill_level, expected only 3, got %d", lua_gettop(L));
    }
    instance.boost_skill_level(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_invlet_to_position(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to invlet_to_position, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.invlet_to_position(parameter1));
    return 1; // 1 return values
}
static int func_player_bonus_damage(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to bonus_damage, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.bonus_damage(parameter1));
    return 1; // 1 return values
}
static int func_player_bodytemp_color(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to bodytemp_color, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.bodytemp_color(parameter1));
    return 1; // 1 return values
}
static int func_player_mabuff_tohit_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to mabuff_tohit_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.mabuff_tohit_bonus());
    return 1; // 1 return values
}
static int func_player_leak_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to leak_level, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.leak_level(parameter1));
    return 1; // 1 return values
}
static int func_player_sleep_spot(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sleep_spot, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.sleep_spot(parameter1));
    return 1; // 1 return values
}
static int func_player_rem_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<morale_type>::check(L, 2);
    auto && parameter1 = LuaEnum<morale_type>::get(L, 2);
    if(LuaReference<itype>::has(L, 3)) {
        auto && parameter2 = LuaReference<itype>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to rem_morale, expected only 3, got %d", lua_gettop(L));
        }
        instance.rem_morale(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to rem_morale, expected only 2, got %d", lua_gettop(L));
        }
        instance.rem_morale(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are itype or nothing at all");
}
static int func_player_crit_chance(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaValueOrReference<item>::check(L, 4);
    auto && parameter3 = LuaValueOrReference<item>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to crit_chance, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.crit_chance(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_player_footwear_factor(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to footwear_factor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.footwear_factor());
    return 1; // 1 return values
}
static int func_player_uninstall_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to uninstall_bionic, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.uninstall_bionic(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to uninstall_bionic, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.uninstall_bionic(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_consume_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to consume_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.consume_item(parameter1));
    return 1; // 1 return values
}
static int func_player_recalc_speed_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recalc_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    instance.recalc_speed_bonus();
    return 0; // 0 return values
}
static int func_player_throw_range(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to throw_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.throw_range(parameter1));
    return 1; // 1 return values
}
static int func_player_gunmod_remove(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to gunmod_remove, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.gunmod_remove(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_practice(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<skill_id>::check(L, 2);
    auto && parameter1 = LuaValue<skill_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to practice, expected only 4, got %d", lua_gettop(L));
        }
        instance.practice(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to practice, expected only 3, got %d", lua_gettop(L));
        }
        instance.practice(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_player_read_speed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to read_speed, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.read_speed(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to read_speed, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.read_speed());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_action_taken(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to action_taken, expected only 1, got %d", lua_gettop(L));
    }
    instance.action_taken();
    return 0; // 0 return values
}
static int func_player_has_gun_for_ammo(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<ammotype>::check(L, 2);
    auto && parameter1 = LuaValue<ammotype>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_gun_for_ammo, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_gun_for_ammo(parameter1));
    return 1; // 1 return values
}
static int func_player_disp_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to disp_morale, expected only 1, got %d", lua_gettop(L));
    }
    instance.disp_morale();
    return 0; // 0 return values
}
static int func_player_handle_melee_wear(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<float>::has(L, 2)) {
        auto && parameter1 = LuaType<float>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to handle_melee_wear, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.handle_melee_wear(parameter1));
        return 1; // 1 return values
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(LuaType<float>::has(L, 3)) {
            auto && parameter2 = LuaType<float>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to handle_melee_wear, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.handle_melee_wear(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to handle_melee_wear, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.handle_melee_wear(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to handle_melee_wear, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.handle_melee_wear());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are float or item or nothing at all");
}
static int func_player_search_surroundings(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to search_surroundings, expected only 1, got %d", lua_gettop(L));
    }
    instance.search_surroundings();
    return 0; // 0 return values
}
static int func_player_metabolic_rate_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to metabolic_rate_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.metabolic_rate_base());
    return 1; // 1 return values
}
static int func_player_natural_attack_restricted_on(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to natural_attack_restricted_on, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.natural_attack_restricted_on(parameter1));
    return 1; // 1 return values
}
static int func_player_read(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to read, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.read(parameter1));
    return 1; // 1 return values
}
static int func_player_calc_focus_equilibrium(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to calc_focus_equilibrium, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.calc_focus_equilibrium());
    return 1; // 1 return values
}
static int func_player_store(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(lua_gettop(L) > 5) {
                return luaL_error(L, "Too many arguments to store, expected only 5, got %d", lua_gettop(L));
            }
            instance.store(parameter1, parameter2, parameter3, parameter4);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to store, expected only 4, got %d", lua_gettop(L));
            }
            instance.store(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to store, expected only 3, got %d", lua_gettop(L));
        }
        instance.store(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_player_set_skill_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<skill_id>::check(L, 2);
    auto && parameter1 = LuaValue<skill_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_skill_level, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_skill_level(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_charge_power(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to charge_power, expected only 2, got %d", lua_gettop(L));
    }
    instance.charge_power(parameter1);
    return 0; // 0 return values
}
static int func_player_climbing_cost(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to climbing_cost, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.climbing_cost(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_has_mission_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_mission_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_mission_item(parameter1));
    return 1; // 1 return values
}
static int func_player_reach_attack(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to reach_attack, expected only 2, got %d", lua_gettop(L));
    }
    instance.reach_attack(parameter1);
    return 0; // 0 return values
}
static int func_player_run_cost(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to run_cost, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.run_cost(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to run_cost, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.run_cost(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_wear_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to wear_item, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.wear_item(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to wear_item, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.wear_item(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_fine_detail_vision_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fine_detail_vision_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.fine_detail_vision_mod());
    return 1; // 1 return values
}
static int func_player_is_hibernating(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hibernating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_hibernating());
    return 1; // 1 return values
}
static int func_player_healall(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to healall, expected only 2, got %d", lua_gettop(L));
    }
    instance.healall(parameter1);
    return 0; // 0 return values
}
static int func_player_overmap_los(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to overmap_los, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.overmap_los(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_max_quality(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<quality_id>::check(L, 2);
    auto && parameter1 = LuaValue<quality_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to max_quality, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.max_quality(parameter1));
    return 1; // 1 return values
}
static int func_player_rust_rate(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to rust_rate, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.rust_rate(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to rust_rate, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.rust_rate());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_knows_trap(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to knows_trap, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.knows_trap(parameter1));
    return 1; // 1 return values
}
static int func_player_adjust_for_focus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to adjust_for_focus, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.adjust_for_focus(parameter1));
    return 1; // 1 return values
}
static int func_player_add_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to add_bionic, expected only 2, got %d", lua_gettop(L));
    }
    instance.add_bionic(parameter1);
    return 0; // 0 return values
}
static int func_player_has_martialart(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<matype_id>::check(L, 2);
    auto && parameter1 = LuaValue<matype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_martialart, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_martialart(parameter1));
    return 1; // 1 return values
}
static int func_player_unarmed_attack(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to unarmed_attack, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.unarmed_attack());
    return 1; // 1 return values
}
static int func_player_make_all_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to make_all_craft, expected only 3, got %d", lua_gettop(L));
    }
    instance.make_all_craft(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_amount_worn(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to amount_worn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.amount_worn(parameter1));
    return 1; // 1 return values
}
static int func_player_has_amount(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_amount, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_amount(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_metabolic_rate(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to metabolic_rate, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.metabolic_rate());
    return 1; // 1 return values
}
static int func_player_ma_ongethit_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_ongethit_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_ongethit_effects();
    return 0; // 0 return values
}
static int func_player_disp_info(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to disp_info, expected only 1, got %d", lua_gettop(L));
    }
    instance.disp_info();
    return 0; // 0 return values
}
static int func_player_addiction_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<add_type>::check(L, 2);
    auto && parameter1 = LuaEnum<add_type>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to addiction_level, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.addiction_level(parameter1));
    return 1; // 1 return values
}
static int func_player_use(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to use, expected only 2, got %d", lua_gettop(L));
    }
    instance.use(parameter1);
    return 0; // 0 return values
}
static int func_player_can_sleep(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_sleep, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_sleep());
    return 1; // 1 return values
}
static int func_player_save_info(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to save_info, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.save_info());
    return 1; // 1 return values
}
static int func_player_pick_style(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pick_style, expected only 1, got %d", lua_gettop(L));
    }
    instance.pick_style();
    return 0; // 0 return values
}
static int func_player_eat(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to eat, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.eat(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to eat, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.eat(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_nutrition_for(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<itype>::check(L, 2);
    auto && parameter1 = LuaReference<itype>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to nutrition_for, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.nutrition_for(parameter1));
    return 1; // 1 return values
}
static int func_player_get_stamina_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_stamina_max, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_stamina_max());
    return 1; // 1 return values
}
static int func_player_can_hear(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to can_hear, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_hear(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_is_armed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_armed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_armed());
    return 1; // 1 return values
}
static int func_player_item_reload_cost(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to item_reload_cost, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.item_reload_cost(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_player_vomit_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to vomit_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.vomit_mod());
    return 1; // 1 return values
}
static int func_player_wield(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to wield, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.wield(parameter1));
    return 1; // 1 return values
}
static int func_player_is_snuggling(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_snuggling, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.is_snuggling());
    return 1; // 1 return values
}
static int func_player_apply_wetness_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to apply_wetness_morale, expected only 2, got %d", lua_gettop(L));
    }
    instance.apply_wetness_morale(parameter1);
    return 0; // 0 return values
}
static int func_player_is_wearing_power_armor(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_wearing_power_armor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_wearing_power_armor());
    return 1; // 1 return values
}
static int func_player_pick_technique(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    LuaType<bool>::check(L, 5);
    auto && parameter4 = LuaType<bool>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to pick_technique, expected only 5, got %d", lua_gettop(L));
    }
    LuaValue<matec_id>::push(L, instance.pick_technique(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_player_disassemble(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<bool>::check(L, 4);
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(lua_gettop(L) > 5) {
                return luaL_error(L, "Too many arguments to disassemble, expected only 5, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.disassemble(parameter1, parameter2, parameter3, parameter4));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to disassemble, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.disassemble(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to disassemble, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.disassemble(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to disassemble, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.disassemble());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are item or int or nothing at all");
}
static int func_player_shout(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to shout, expected only 2, got %d", lua_gettop(L));
        }
        instance.shout(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to shout, expected only 1, got %d", lua_gettop(L));
        }
        instance.shout();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or nothing at all");
}
static int func_player_get_skill_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<skill_id>::check(L, 2);
    auto && parameter1 = LuaValue<skill_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_skill_level, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_skill_level(parameter1));
    return 1; // 1 return values
}
static int func_player_long_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to long_craft, expected only 1, got %d", lua_gettop(L));
    }
    instance.long_craft();
    return 0; // 0 return values
}
static int func_player_swim_speed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to swim_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.swim_speed());
    return 1; // 1 return values
}
static int func_player_throw_dex_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to throw_dex_mod, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.throw_dex_mod(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to throw_dex_mod, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.throw_dex_mod());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_has_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<morale_type>::check(L, 2);
    auto && parameter1 = LuaEnum<morale_type>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_morale, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.has_morale(parameter1));
    return 1; // 1 return values
}
static int func_player_best_shield(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to best_shield, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.best_shield());
    return 1; // 1 return values
}
static int func_player_active_light(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to active_light, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.active_light());
    return 1; // 1 return values
}
static int func_player_get_armor_fire(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_fire, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_fire(parameter1));
    return 1; // 1 return values
}
static int func_player_setx(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setx, expected only 2, got %d", lua_gettop(L));
    }
    instance.setx(parameter1);
    return 0; // 0 return values
}
static int func_player_drink_from_hands(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to drink_from_hands, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.drink_from_hands(parameter1));
    return 1; // 1 return values
}
static int func_player_hurtall(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaReference<Creature>::check(L, 3);
    auto && parameter2 = LuaReference<Creature>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to hurtall, expected only 3, got %d", lua_gettop(L));
    }
    instance.hurtall(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_set_highest_cat_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to set_highest_cat_level, expected only 1, got %d", lua_gettop(L));
    }
    instance.set_highest_cat_level();
    return 0; // 0 return values
}
static int func_player_amount_of(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to amount_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.amount_of(parameter1));
    return 1; // 1 return values
}
static int func_player_get_sick(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_sick, expected only 1, got %d", lua_gettop(L));
    }
    instance.get_sick();
    return 0; // 0 return values
}
static int func_player_wear(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to wear, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.wear(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to wear, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.wear(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_mutate_towards(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutate_towards, expected only 2, got %d", lua_gettop(L));
    }
    instance.mutate_towards(parameter1);
    return 0; // 0 return values
}
static int func_player_has_mabuff(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<mabuff_id>::check(L, 2);
    auto && parameter1 = LuaValue<mabuff_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_mabuff, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_mabuff(parameter1));
    return 1; // 1 return values
}
static int func_player_power_bionics(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_bionics, expected only 1, got %d", lua_gettop(L));
    }
    instance.power_bionics();
    return 0; // 0 return values
}
static int func_player_update_needs(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to update_needs, expected only 2, got %d", lua_gettop(L));
    }
    instance.update_needs(parameter1);
    return 0; // 0 return values
}
static int func_player_has_morale_to_read(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_morale_to_read, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_morale_to_read());
    return 1; // 1 return values
}
static int func_player_has_lower_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_lower_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_lower_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_has_higher_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_higher_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_higher_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_temp_equalizer(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to temp_equalizer, expected only 3, got %d", lua_gettop(L));
    }
    instance.temp_equalizer(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_allergy_type(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to allergy_type, expected only 2, got %d", lua_gettop(L));
    }
    LuaEnum<morale_type>::push(L, instance.allergy_type(parameter1));
    return 1; // 1 return values
}
static int func_player_studied_all_recipes(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<itype>::check(L, 2);
    auto && parameter1 = LuaReference<itype>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to studied_all_recipes, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.studied_all_recipes(parameter1));
    return 1; // 1 return values
}
static int func_player_invoke_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<std::string>::has(L, 3)) {
        auto && parameter2 = LuaType<std::string>::get(L, 3);
        if(LuaValue<tripoint>::has(L, 4)) {
            auto && parameter3 = LuaValue<tripoint>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to invoke_item, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.invoke_item(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to invoke_item, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.invoke_item(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are tripoint or nothing at all");
    }
    if(LuaValue<tripoint>::has(L, 3)) {
        auto && parameter2 = LuaValue<tripoint>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to invoke_item, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.invoke_item(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to invoke_item, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.invoke_item(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are string or tripoint or nothing at all");
}
static int func_player_attack_speed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to attack_speed, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.attack_speed(parameter1));
    return 1; // 1 return values
}
static int func_player_pick_usb(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pick_usb, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.pick_usb());
    return 1; // 1 return values
}
static int func_player_pause(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pause, expected only 1, got %d", lua_gettop(L));
    }
    instance.pause();
    return 0; // 0 return values
}
static int func_player_remove_child_flag(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_child_flag, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_child_flag(parameter1);
    return 0; // 0 return values
}
static int func_player_wearing_something_on(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to wearing_something_on, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.wearing_something_on(parameter1));
    return 1; // 1 return values
}
static int func_player_toggle_move_mode(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to toggle_move_mode, expected only 1, got %d", lua_gettop(L));
    }
    instance.toggle_move_mode();
    return 0; // 0 return values
}
static int func_player_mabuff_speed_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to mabuff_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.mabuff_speed_bonus());
    return 1; // 1 return values
}
static int func_player_rooted(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to rooted, expected only 1, got %d", lua_gettop(L));
    }
    instance.rooted();
    return 0; // 0 return values
}
static int func_player_ma_onhit_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_onhit_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_onhit_effects();
    return 0; // 0 return values
}
static int func_player_rem_addiction(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<add_type>::check(L, 2);
    auto && parameter1 = LuaEnum<add_type>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to rem_addiction, expected only 2, got %d", lua_gettop(L));
    }
    instance.rem_addiction(parameter1);
    return 0; // 0 return values
}
static int func_player_has_item_with_flag(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_item_with_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_item_with_flag(parameter1));
    return 1; // 1 return values
}
static int func_player_deactivate_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to deactivate_bionic, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.deactivate_bionic(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to deactivate_bionic, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.deactivate_bionic(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_global_square_location(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to global_square_location, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.global_square_location());
    return 1; // 1 return values
}
static int func_player_make_craft_with_command(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to make_craft_with_command, expected only 4, got %d", lua_gettop(L));
        }
        instance.make_craft_with_command(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to make_craft_with_command, expected only 3, got %d", lua_gettop(L));
        }
        instance.make_craft_with_command(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_visibility(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(LuaType<int>::has(L, 3)) {
            auto && parameter2 = LuaType<int>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to visibility, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.visibility(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to visibility, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.visibility(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to visibility, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.visibility());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_drench_mut_calc(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to drench_mut_calc, expected only 1, got %d", lua_gettop(L));
    }
    instance.drench_mut_calc();
    return 0; // 0 return values
}
static int func_player_can_arm_block(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_arm_block, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_arm_block());
    return 1; // 1 return values
}
static int func_player_is_wearing_active_power_armor(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_wearing_active_power_armor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_wearing_active_power_armor());
    return 1; // 1 return values
}
static int func_player_gun_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to gun_value, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.gun_value(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_value, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.gun_value(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_has_conflicting_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_conflicting_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_conflicting_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_sees_with_infrared(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sees_with_infrared, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.sees_with_infrared(parameter1));
    return 1; // 1 return values
}
static int func_player_has_child_flag(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_child_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_child_flag(parameter1));
    return 1; // 1 return values
}
static int func_player_ma_onattack_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_onattack_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_onattack_effects();
    return 0; // 0 return values
}
static int func_player_weapname(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weapname, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.weapname());
    return 1; // 1 return values
}
static int func_player_cough(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(LuaType<int>::has(L, 3)) {
            auto && parameter2 = LuaType<int>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to cough, expected only 3, got %d", lua_gettop(L));
            }
            instance.cough(parameter1, parameter2);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to cough, expected only 2, got %d", lua_gettop(L));
            }
            instance.cough(parameter1);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to cough, expected only 1, got %d", lua_gettop(L));
        }
        instance.cough();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_apply_persistent_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to apply_persistent_morale, expected only 1, got %d", lua_gettop(L));
    }
    instance.apply_persistent_morale();
    return 0; // 0 return values
}
static int func_player_get_combat_style(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_combat_style, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<martialart>::push(L, instance.get_combat_style());
    return 1; // 1 return values
}
static int func_player_change_side(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to change_side, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.change_side(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to change_side, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.change_side(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to change_side, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.change_side(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to change_side, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.change_side(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or item");
}
static int func_player_has_alarm_clock(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_alarm_clock, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_alarm_clock());
    return 1; // 1 return values
}
static int func_player_set_underwater(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_underwater, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_underwater(parameter1);
    return 0; // 0 return values
}
static int func_player_sort_armor(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sort_armor, expected only 1, got %d", lua_gettop(L));
    }
    instance.sort_armor();
    return 0; // 0 return values
}
static int func_player_has_opposite_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_opposite_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_opposite_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_environmental_revert_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to environmental_revert_effect, expected only 1, got %d", lua_gettop(L));
    }
    instance.environmental_revert_effect();
    return 0; // 0 return values
}
static int func_player_fire_gun(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(LuaValueOrReference<item>::has(L, 4)) {
            auto && parameter3 = LuaValueOrReference<item>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to fire_gun, expected only 4, got %d", lua_gettop(L));
            }
            instance.fire_gun(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to fire_gun, expected only 3, got %d", lua_gettop(L));
            }
            instance.fire_gun(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are item or nothing at all");
    }
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaValueOrReference<item>::has(L, 4)) {
            auto && parameter3 = LuaValueOrReference<item>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to fire_gun, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.fire_gun(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to fire_gun, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.fire_gun(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are item or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to fire_gun, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.fire_gun(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or int or nothing at all");
}
static int func_player_complete_disassemble(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to complete_disassemble, expected only 1, got %d", lua_gettop(L));
    }
    instance.complete_disassemble();
    return 0; // 0 return values
}
static int func_player_mabuff_block_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to mabuff_block_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.mabuff_block_bonus());
    return 1; // 1 return values
}
static int func_player_wield_contents(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(LuaType<bool>::has(L, 5)) {
                auto && parameter4 = LuaType<bool>::get(L, 5);
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to wield_contents, expected only 5, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, instance.wield_contents(parameter1, parameter2, parameter3, parameter4));
                return 1; // 1 return values
            }
            if(lua_gettop(L) == 4) {
                if(lua_gettop(L) > 4) {
                    return luaL_error(L, "Too many arguments to wield_contents, expected only 4, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, instance.wield_contents(parameter1, parameter2, parameter3));
                return 1; // 1 return values
            }
            return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to wield_contents, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.wield_contents(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to wield_contents, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.wield_contents(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_has_two_arms(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_two_arms, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_two_arms());
    return 1; // 1 return values
}
static int func_player_can_reload(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<std::string>::has(L, 3)) {
        auto && parameter2 = LuaType<std::string>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_reload, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_reload(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_reload, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_reload(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are string or nothing at all");
}
static int func_player_has_charges(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to has_charges, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_charges(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_set_painkiller(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_painkiller, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_painkiller(parameter1);
    return 0; // 0 return values
}
static int func_player_process_active_items(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_active_items, expected only 1, got %d", lua_gettop(L));
    }
    instance.process_active_items();
    return 0; // 0 return values
}
static int func_player_dump_memorial(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to dump_memorial, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.dump_memorial());
    return 1; // 1 return values
}
static int func_player_is_wearing_shoes(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to is_wearing_shoes, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_wearing_shoes(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to is_wearing_shoes, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.is_wearing_shoes());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or nothing at all");
}
static int func_player_is_invisible(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_invisible, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_invisible());
    return 1; // 1 return values
}
static int func_player_has_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_item(parameter1));
    return 1; // 1 return values
}
static int func_player_update_mental_focus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to update_mental_focus, expected only 1, got %d", lua_gettop(L));
    }
    instance.update_mental_focus();
    return 0; // 0 return values
}
static int func_player_item_handling_cost(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to item_handling_cost, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.item_handling_cost(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to item_handling_cost, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.item_handling_cost(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to item_handling_cost, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.item_handling_cost(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_warmth(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to warmth, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.warmth(parameter1));
    return 1; // 1 return values
}
static int func_player_wake_up(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to wake_up, expected only 1, got %d", lua_gettop(L));
    }
    instance.wake_up();
    return 0; // 0 return values
}
static int func_player_vomit(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to vomit, expected only 1, got %d", lua_gettop(L));
    }
    instance.vomit();
    return 0; // 0 return values
}
static int func_player_ma_onblock_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_onblock_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_onblock_effects();
    return 0; // 0 return values
}
static int func_player_use_wielded(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to use_wielded, expected only 1, got %d", lua_gettop(L));
    }
    instance.use_wielded();
    return 0; // 0 return values
}
static int func_player_get_hit_weapon(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_hit_weapon, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_hit_weapon(parameter1));
    return 1; // 1 return values
}
static int func_player_can_wield(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_wield, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_wield(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_wield, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_wield(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_update_stamina(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to update_stamina, expected only 2, got %d", lua_gettop(L));
    }
    instance.update_stamina(parameter1);
    return 0; // 0 return values
}
static int func_player_update_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to update_morale, expected only 1, got %d", lua_gettop(L));
    }
    instance.update_morale();
    return 0; // 0 return values
}
static int func_player_add_addiction(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<add_type>::check(L, 2);
    auto && parameter1 = LuaEnum<add_type>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_addiction, expected only 3, got %d", lua_gettop(L));
    }
    instance.add_addiction(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_cancel_activity(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to cancel_activity, expected only 1, got %d", lua_gettop(L));
    }
    instance.cancel_activity();
    return 0; // 0 return values
}
static int func_player_update_bodytemp(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to update_bodytemp, expected only 1, got %d", lua_gettop(L));
    }
    instance.update_bodytemp();
    return 0; // 0 return values
}
static int func_player_mod_painkiller(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_painkiller, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_painkiller(parameter1);
    return 0; // 0 return values
}
static int func_player_update_body_wetness(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<w_point>::check(L, 2);
    auto && parameter1 = LuaReference<w_point>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to update_body_wetness, expected only 2, got %d", lua_gettop(L));
    }
    instance.update_body_wetness(parameter1);
    return 0; // 0 return values
}
static int func_player_do_read(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to do_read, expected only 2, got %d", lua_gettop(L));
    }
    instance.do_read(parameter1);
    return 0; // 0 return values
}
static int func_player_shoe_type_count(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to shoe_type_count, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.shoe_type_count(parameter1));
    return 1; // 1 return values
}
static int func_player_drench(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to drench, expected only 4, got %d", lua_gettop(L));
    }
    instance.drench(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_player_crossed_threshold(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to crossed_threshold, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.crossed_threshold());
    return 1; // 1 return values
}
static int func_player_has_miss_recovery_tec(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_miss_recovery_tec, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_miss_recovery_tec());
    return 1; // 1 return values
}
static int func_player_talk_skill(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to talk_skill, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.talk_skill());
    return 1; // 1 return values
}
static int func_player_place_corpse(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to place_corpse, expected only 1, got %d", lua_gettop(L));
    }
    instance.place_corpse();
    return 0; // 0 return values
}
static int func_player_add_morale(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<morale_type>::check(L, 2);
    auto && parameter1 = LuaEnum<morale_type>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaType<int>::has(L, 4)) {
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(LuaType<int>::has(L, 5)) {
            auto && parameter4 = LuaType<int>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<bool>::has(L, 7)) {
                    auto && parameter6 = LuaType<bool>::get(L, 7);
                    if(LuaReference<itype>::has(L, 8)) {
                        auto && parameter7 = LuaReference<itype>::get(L, 8);
                        if(lua_gettop(L) > 8) {
                            return luaL_error(L, "Too many arguments to add_morale, expected only 8, got %d", lua_gettop(L));
                        }
                        instance.add_morale(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7);
                        return 0; // 0 return values
                    }
                    if(lua_gettop(L) == 7) {
                        if(lua_gettop(L) > 7) {
                            return luaL_error(L, "Too many arguments to add_morale, expected only 7, got %d", lua_gettop(L));
                        }
                        instance.add_morale(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                        return 0; // 0 return values
                    }
                    return luaL_argerror(L, 7, "Unexpected type, expected are itype or nothing at all");
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to add_morale, expected only 6, got %d", lua_gettop(L));
                    }
                    instance.add_morale(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to add_morale, expected only 5, got %d", lua_gettop(L));
                }
                instance.add_morale(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to add_morale, expected only 4, got %d", lua_gettop(L));
            }
            instance.add_morale(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_morale, expected only 3, got %d", lua_gettop(L));
        }
        instance.add_morale(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
}
static int func_player_unimpaired_range(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to unimpaired_range, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.unimpaired_range());
    return 1; // 1 return values
}
static int func_player_mutate_category(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutate_category, expected only 2, got %d", lua_gettop(L));
    }
    instance.mutate_category(parameter1);
    return 0; // 0 return values
}
static int func_player_unarmed_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to unarmed_value, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.unarmed_value());
    return 1; // 1 return values
}
static int func_player_global_sm_location(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to global_sm_location, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.global_sm_location());
    return 1; // 1 return values
}
static int func_player_try_to_sleep(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to try_to_sleep, expected only 1, got %d", lua_gettop(L));
    }
    instance.try_to_sleep();
    return 0; // 0 return values
}
static int func_player_mend(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mend, expected only 2, got %d", lua_gettop(L));
    }
    instance.mend(parameter1);
    return 0; // 0 return values
}
static int func_player_remove_random_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to remove_random_bionic, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.remove_random_bionic());
    return 1; // 1 return values
}
static int func_player_make_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to make_craft, expected only 3, got %d", lua_gettop(L));
    }
    instance.make_craft(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_suffer(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to suffer, expected only 1, got %d", lua_gettop(L));
    }
    instance.suffer();
    return 0; // 0 return values
}
static int func_player_bonus_item_warmth(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to bonus_item_warmth, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.bonus_item_warmth(parameter1));
    return 1; // 1 return values
}
static int func_player_spores(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to spores, expected only 1, got %d", lua_gettop(L));
    }
    instance.spores();
    return 0; // 0 return values
}
static int func_player_add_known_trap(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<trap>::check(L, 3);
    auto && parameter2 = LuaReference<trap>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to add_known_trap, expected only 3, got %d", lua_gettop(L));
    }
    instance.add_known_trap(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_stomach_capacity(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stomach_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.stomach_capacity());
    return 1; // 1 return values
}
static int func_player_intimidation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to intimidation, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.intimidation());
    return 1; // 1 return values
}
static int func_player_making_would_work(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to making_would_work, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.making_would_work(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_weapon_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to weapon_value, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.weapon_value(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to weapon_value, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.weapon_value(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_heal(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to heal, expected only 3, got %d", lua_gettop(L));
        }
        instance.heal(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(LuaEnum<body_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<body_part>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to heal, expected only 3, got %d", lua_gettop(L));
        }
        instance.heal(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or body_part");
}
static int func_player_remove_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_bionic, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_bionic(parameter1);
    return 0; // 0 return values
}
static int func_player_sight_impaired(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sight_impaired, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.sight_impaired());
    return 1; // 1 return values
}
static int func_player_blossoms(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to blossoms, expected only 1, got %d", lua_gettop(L));
    }
    instance.blossoms();
    return 0; // 0 return values
}
static int func_player_is_allergic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_allergic, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_allergic(parameter1));
    return 1; // 1 return values
}
static int func_player_get_highest_category(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_highest_category, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_highest_category());
    return 1; // 1 return values
}
static int func_player_can_weapon_block(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_weapon_block, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_weapon_block());
    return 1; // 1 return values
}
static int func_player_ma_onmove_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_onmove_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_onmove_effects();
    return 0; // 0 return values
}
static int func_player_sety(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sety, expected only 2, got %d", lua_gettop(L));
    }
    instance.sety(parameter1);
    return 0; // 0 return values
}
static int func_player_setz(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setz, expected only 2, got %d", lua_gettop(L));
    }
    instance.setz(parameter1);
    return 0; // 0 return values
}
static int func_player_get_painkiller(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_painkiller, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_painkiller());
    return 1; // 1 return values
}
static int func_player_is_throw_immune(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_throw_immune, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_throw_immune());
    return 1; // 1 return values
}
static int func_player_purifiable(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to purifiable, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.purifiable(parameter1));
    return 1; // 1 return values
}
static int func_player_shift_destination(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to shift_destination, expected only 3, got %d", lua_gettop(L));
    }
    instance.shift_destination(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_setID(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setID, expected only 2, got %d", lua_gettop(L));
    }
    instance.setID(parameter1);
    return 0; // 0 return values
}
static int func_player_rooted_message(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to rooted_message, expected only 1, got %d", lua_gettop(L));
    }
    instance.rooted_message();
    return 0; // 0 return values
}
static int func_player_in_climate_control(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_climate_control, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.in_climate_control());
    return 1; // 1 return values
}
static int func_player_has_morale_to_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_morale_to_craft, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_morale_to_craft());
    return 1; // 1 return values
}
static int func_player_consume_charges(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to consume_charges, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.consume_charges(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_reduce_charges(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to reduce_charges, expected only 3, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, instance.reduce_charges(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to reduce_charges, expected only 3, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, instance.reduce_charges(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or item");
}
static int func_player_load_info(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to load_info, expected only 2, got %d", lua_gettop(L));
    }
    instance.load_info(parameter1);
    return 0; // 0 return values
}
static int func_player_is_deaf(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_deaf, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_deaf());
    return 1; // 1 return values
}
static int func_player_regen(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to regen, expected only 2, got %d", lua_gettop(L));
    }
    instance.regen(parameter1);
    return 0; // 0 return values
}
static int func_player_getID(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getID, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.getID());
    return 1; // 1 return values
}
static int func_player_clear_miss_reasons(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_miss_reasons, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_miss_reasons();
    return 0; // 0 return values
}
static int func_player_recraft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recraft, expected only 1, got %d", lua_gettop(L));
    }
    instance.recraft();
    return 0; // 0 return values
}
static int func_player_power_mutations(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_mutations, expected only 1, got %d", lua_gettop(L));
    }
    instance.power_mutations();
    return 0; // 0 return values
}
static int func_player_has_addiction(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<add_type>::check(L, 2);
    auto && parameter1 = LuaEnum<add_type>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_addiction, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_addiction(parameter1));
    return 1; // 1 return values
}
static int func_player_get_morale_level(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_morale_level, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_morale_level());
    return 1; // 1 return values
}
static int func_player_global_omt_location(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to global_omt_location, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.global_omt_location());
    return 1; // 1 return values
}
static int func_player_get_armor_acid(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_acid, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_armor_acid(parameter1));
    return 1; // 1 return values
}
static int func_player_ma_static_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_static_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_static_effects();
    return 0; // 0 return values
}
static int func_player_ma_ondodge_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ma_ondodge_effects, expected only 1, got %d", lua_gettop(L));
    }
    instance.ma_ondodge_effects();
    return 0; // 0 return values
}
static int func_player_hearing_ability(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hearing_ability, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.hearing_ability());
    return 1; // 1 return values
}
static int func_player_complete_craft(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to complete_craft, expected only 1, got %d", lua_gettop(L));
    }
    instance.complete_craft();
    return 0; // 0 return values
}
static int func_player_gunmod_add(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to gunmod_add, expected only 3, got %d", lua_gettop(L));
    }
    instance.gunmod_add(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_get_wind_resistance(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_wind_resistance, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_wind_resistance(parameter1));
    return 1; // 1 return values
}
static int func_player_install_bionics(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<itype>::check(L, 2);
    auto && parameter1 = LuaReference<itype>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to install_bionics, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.install_bionics(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to install_bionics, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.install_bionics(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_hitall(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaReference<Creature>::check(L, 4);
    auto && parameter3 = LuaReference<Creature>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to hitall, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.hitall(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_player_has_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_bionic, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_bionic(parameter1));
    return 1; // 1 return values
}
static int func_player_random_good_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to random_good_trait, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Character&>(instance).random_good_trait());
    return 1; // 1 return values
}
static int func_player_get_item_position(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_item_position, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_item_position(parameter1));
    return 1; // 1 return values
}
static int func_player_can_pickVolume(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_pickVolume, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_pickVolume(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_pickVolume, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_pickVolume(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_get_per_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_per_bonus());
    return 1; // 1 return values
}
static int func_player_add_traits(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to add_traits, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).add_traits();
    return 0; // 0 return values
}
static int func_player_set_per_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_per_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_per_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_mutation_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutation_effect, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mutation_effect(parameter1);
    return 0; // 0 return values
}
static int func_player_weight_carried(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_carried, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).weight_carried());
    return 1; // 1 return values
}
static int func_player_set_dex_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dex_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_dex_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_mutation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_mutation, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_mutation(parameter1);
    return 0; // 0 return values
}
static int func_player_remove_weapon(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to remove_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item>::push(L, static_cast<Character&>(instance).remove_weapon());
    return 1; // 1 return values
}
static int func_player_recalc_hp(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recalc_hp, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).recalc_hp();
    return 0; // 0 return values
}
static int func_player_get_dex_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_dex_base());
    return 1; // 1 return values
}
static int func_player_get_healthy_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_healthy_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_healthy_mod());
    return 1; // 1 return values
}
static int func_player_is_wearing_on_bp(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to is_wearing_on_bp, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).is_wearing_on_bp(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_recalc_sight_limits(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recalc_sight_limits, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).recalc_sight_limits();
    return 0; // 0 return values
}
static int func_player_set_healthy_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_healthy_mod, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_healthy_mod(parameter1);
    return 0; // 0 return values
}
static int func_player_get_turn_died(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_turn_died, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_turn_died());
    return 1; // 1 return values
}
static int func_player_set_healthy(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_healthy, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_healthy(parameter1);
    return 0; // 0 return values
}
static int func_player_has_nv(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_nv, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_nv());
    return 1; // 1 return values
}
static int func_player_has_active_mutation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_mutation, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_active_mutation(parameter1));
    return 1; // 1 return values
}
static int func_player_worn_with_flag(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to worn_with_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).worn_with_flag(parameter1));
    return 1; // 1 return values
}
static int func_player_i_add_or_drop(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to i_add_or_drop, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).i_add_or_drop(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_add_or_drop, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).i_add_or_drop(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_player_mutation_loss_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutation_loss_effect, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mutation_loss_effect(parameter1);
    return 0; // 0 return values
}
static int func_player_get_str_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_str_bonus());
    return 1; // 1 return values
}
static int func_player_set_thirst(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_thirst, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_thirst(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_int_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_int_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_int_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_str_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_str_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_str_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_aim_per_move(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to aim_per_move, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Character&>(instance).aim_per_move(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_get_int_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_int_base());
    return 1; // 1 return values
}
static int func_player_can_use(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaValueOrReference<item>::has(L, 3)) {
        auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_use, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_use(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_use, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_use(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are item or nothing at all");
}
static int func_player_pick_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to pick_name, expected only 2, got %d", lua_gettop(L));
        }
        static_cast<Character&>(instance).pick_name(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to pick_name, expected only 1, got %d", lua_gettop(L));
        }
        static_cast<Character&>(instance).pick_name();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_get_per_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_per_base());
    return 1; // 1 return values
}
static int func_player_get_thirst(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_thirst, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_thirst());
    return 1; // 1 return values
}
static int func_player_empty_skills(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to empty_skills, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).empty_skills();
    return 0; // 0 return values
}
static int func_player_volume_carried(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to volume_carried, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, static_cast<Character&>(instance).volume_carried());
    return 1; // 1 return values
}
static int func_player_get_dex(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_dex());
    return 1; // 1 return values
}
static int func_player_i_at(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, static_cast<Character&>(instance).i_at(parameter1));
    return 1; // 1 return values
}
static int func_player_i_rem_keep_contents(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_rem_keep_contents, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).i_rem_keep_contents(parameter1);
    return 0; // 0 return values
}
static int func_player_made_of(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<material_id>::check(L, 2);
    auto && parameter1 = LuaValue<material_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).made_of(parameter1));
    return 1; // 1 return values
}
static int func_player_can_pickWeight(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_pickWeight, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_pickWeight(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_pickWeight, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Character&>(instance).can_pickWeight(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_get_vision_threshold(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_vision_threshold, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Character&>(instance).get_vision_threshold(parameter1));
    return 1; // 1 return values
}
static int func_player_unset_mutation(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to unset_mutation, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).unset_mutation(parameter1);
    return 0; // 0 return values
}
static int func_player_has_active_item(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_active_item(parameter1));
    return 1; // 1 return values
}
static int func_player_get_str(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_str());
    return 1; // 1 return values
}
static int func_player_is_wearing(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_wearing, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).is_wearing(parameter1));
    return 1; // 1 return values
}
static int func_player_mod_per_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_per_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_per_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_empty_traits(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to empty_traits, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).empty_traits();
    return 0; // 0 return values
}
static int func_player_update_health(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to update_health, expected only 2, got %d", lua_gettop(L));
        }
        static_cast<Character&>(instance).update_health(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to update_health, expected only 1, got %d", lua_gettop(L));
        }
        static_cast<Character&>(instance).update_health();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_player_i_rem(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, static_cast<Character&>(instance).i_rem(parameter1));
        return 1; // 1 return values
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, static_cast<Character&>(instance).i_rem(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or item");
}
static int func_player_mod_stomach_food(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_stomach_food, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_stomach_food(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_thirst(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_thirst, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_thirst(parameter1);
    return 0; // 0 return values
}
static int func_player_get_int(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_int());
    return 1; // 1 return values
}
static int func_player_random_bad_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to random_bad_trait, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Character&>(instance).random_bad_trait());
    return 1; // 1 return values
}
static int func_player_mod_dex_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dex_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_dex_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_str_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_str_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_str_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_toggle_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to toggle_trait, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).toggle_trait(parameter1);
    return 0; // 0 return values
}
static int func_player_get_str_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_str_base());
    return 1; // 1 return values
}
static int func_player_get_per(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_per());
    return 1; // 1 return values
}
static int func_player_get_dex_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_dex_bonus());
    return 1; // 1 return values
}
static int func_player_set_fatigue(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fatigue, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_fatigue(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_hunger(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hunger, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_hunger(parameter1);
    return 0; // 0 return values
}
static int func_player_set_stomach_water(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_stomach_water, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_stomach_water(parameter1);
    return 0; // 0 return values
}
static int func_player_get_healthy(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_healthy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_healthy());
    return 1; // 1 return values
}
static int func_player_remove_mission_items(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_mission_items, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).remove_mission_items(parameter1);
    return 0; // 0 return values
}
static int func_player_has_trait_flag(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_trait_flag(parameter1));
    return 1; // 1 return values
}
static int func_player_set_hunger(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hunger, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_hunger(parameter1);
    return 0; // 0 return values
}
static int func_player_is_worn(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_worn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).is_worn(parameter1));
    return 1; // 1 return values
}
static int func_player_get_fatigue(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_fatigue, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_fatigue());
    return 1; // 1 return values
}
static int func_player_volume_capacity(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to volume_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, static_cast<Character&>(instance).volume_capacity());
    return 1; // 1 return values
}
static int func_player_limb_color(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    LuaType<bool>::check(L, 5);
    auto && parameter4 = LuaType<bool>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to limb_color, expected only 5, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).limb_color(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_player_mod_healthy(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_healthy, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_healthy(parameter1);
    return 0; // 0 return values
}
static int func_player_set_int_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_int_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_int_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_has_active_bionic(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_bionic, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_active_bionic(parameter1));
    return 1; // 1 return values
}
static int func_player_mod_fatigue(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_fatigue, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_fatigue(parameter1);
    return 0; // 0 return values
}
static int func_player_get_stomach_water(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_stomach_water, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_stomach_water());
    return 1; // 1 return values
}
static int func_player_get_stomach_food(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_stomach_food, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_stomach_food());
    return 1; // 1 return values
}
static int func_player_set_turn_died(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_turn_died, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_turn_died(parameter1);
    return 0; // 0 return values
}
static int func_player_get_hunger(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hunger, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_hunger());
    return 1; // 1 return values
}
static int func_player_has_base_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_base_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Character&>(instance).has_base_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_mod_healthy_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_healthy_mod, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_healthy_mod(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_set_stomach_food(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_stomach_food, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).set_stomach_food(parameter1);
    return 0; // 0 return values
}
static int func_player_i_add(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_add, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, static_cast<Character&>(instance).i_add(parameter1));
    return 1; // 1 return values
}
static int func_player_mod_stomach_water(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_stomach_water, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Character&>(instance).mod_stomach_water(parameter1);
    return 0; // 0 return values
}
static int func_player_get_int_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Character&>(instance).get_int_bonus());
    return 1; // 1 return values
}
static int func_player_trait_by_invlet(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to trait_by_invlet, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Character&>(instance).trait_by_invlet(parameter1));
    return 1; // 1 return values
}
static int func_player_is_dead_state(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_dead_state());
    return 1; // 1 return values
}
static int func_player_basic_symbol_color(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to basic_symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).basic_symbol_color());
    return 1; // 1 return values
}
static int func_player_is_fake(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_fake, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_fake());
    return 1; // 1 return values
}
static int func_player_melee_attack(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(LuaValue<matec_id>::has(L, 4)) {
        auto && parameter3 = LuaValue<matec_id>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 4, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are matec_id or nothing at all");
}
static int func_player_get_killer(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_killer, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, static_cast<Creature&>(instance).get_killer());
    return 1; // 1 return values
}
static int func_player_get_armor_bash(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash(parameter1));
    return 1; // 1 return values
}
static int func_player_posx(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posx, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posx());
    return 1; // 1 return values
}
static int func_player_hp_percentage(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hp_percentage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).hp_percentage());
    return 1; // 1 return values
}
static int func_player_gibType(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gibType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).gibType());
    return 1; // 1 return values
}
static int func_player_mod_moves(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_moves(parameter1);
    return 0; // 0 return values
}
static int func_player_bloodType(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bloodType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).bloodType());
    return 1; // 1 return values
}
static int func_player_digging(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to digging, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).digging());
    return 1; // 1 return values
}
static int func_player_pos(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pos, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, static_cast<Creature&>(instance).pos());
    return 1; // 1 return values
}
static int func_player_has_trait(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_trait(parameter1));
    return 1; // 1 return values
}
static int func_player_get_perceived_pain(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_perceived_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_perceived_pain());
    return 1; // 1 return values
}
static int func_player_is_monster(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_monster, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_monster());
    return 1; // 1 return values
}
static int func_player_get_hp(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_player_set_armor_cut_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_get_env_resist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_env_resist, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_env_resist(parameter1));
    return 1; // 1 return values
}
static int func_player_set_fake(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fake, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_fake(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_pain(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain(parameter1);
    return 0; // 0 return values
}
static int func_player_is_hallucination(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hallucination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_hallucination());
    return 1; // 1 return values
}
static int func_player_get_throw_resist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_throw_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_throw_resist());
    return 1; // 1 return values
}
static int func_player_get_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_value, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_value(parameter1));
    return 1; // 1 return values
}
static int func_player_set_throw_resist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_throw_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_throw_resist(parameter1);
    return 0; // 0 return values
}
static int func_player_get_armor_cut_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_bonus());
    return 1; // 1 return values
}
static int func_player_skin_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to skin_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).skin_name());
    return 1; // 1 return values
}
static int func_player_get_hp_max(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_player_set_cut_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_on_hit(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 3, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to on_hit, expected only 2, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).on_hit(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_mod_stat(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_stat, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_stat(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_setpos(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setpos, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).setpos(parameter1);
    return 0; // 0 return values
}
static int func_player_get_speed_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_bonus());
    return 1; // 1 return values
}
static int func_player_get_size(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_size, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<m_size>::push(L, static_cast<Creature&>(instance).get_size());
    return 1; // 1 return values
}
static int func_player_is_warm(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_warm, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_warm());
    return 1; // 1 return values
}
static int func_player_process_turn(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_turn, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_turn();
    return 0; // 0 return values
}
static int func_player_disp_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_get_cut_mult(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_cut_mult());
    return 1; // 1 return values
}
static int func_player_power_rating(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).power_rating());
    return 1; // 1 return values
}
static int func_player_get_name(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_name());
    return 1; // 1 return values
}
static int func_player_add_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaEnum<body_part>::has(L, 4)) {
        auto && parameter3 = LuaEnum<body_part>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<bool>::has(L, 7)) {
                    auto && parameter6 = LuaType<bool>::get(L, 7);
                    if(lua_gettop(L) > 7) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 7, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 6, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to add_effect, expected only 5, got %d", lua_gettop(L));
                }
                static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to add_effect, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_effect, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).add_effect(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_get_grab_resist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_grab_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_grab_resist());
    return 1; // 1 return values
}
static int func_player_get_effect_int(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_get_hit_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_bonus());
    return 1; // 1 return values
}
static int func_player_is_immune_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_immune_effect, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_immune_effect(parameter1));
    return 1; // 1 return values
}
static int func_player_set_cut_mult(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_mult(parameter1);
    return 0; // 0 return values
}
static int func_player_get_num_dodges(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges());
    return 1; // 1 return values
}
static int func_player_is_npc(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_npc, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_npc());
    return 1; // 1 return values
}
static int func_player_set_bash_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_reset_bonuses(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_bonuses, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_bonuses();
    return 0; // 0 return values
}
static int func_player_get_dodge_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_bonus());
    return 1; // 1 return values
}
static int func_player_set_speed_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_hit_roll(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hit_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).hit_roll());
    return 1; // 1 return values
}
static int func_player_get_num_blocks(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks());
    return 1; // 1 return values
}
static int func_player_on_dodge(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to on_dodge, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).on_dodge(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_get_bash_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_bash_bonus());
    return 1; // 1 return values
}
static int func_player_process_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_effects();
    return 0; // 0 return values
}
static int func_player_set_dodge_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_get_num_dodges_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges_bonus());
    return 1; // 1 return values
}
static int func_player_get_dodge(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge());
    return 1; // 1 return values
}
static int func_player_get_dodge_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_base());
    return 1; // 1 return values
}
static int func_player_normalize(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to normalize, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).normalize();
    return 0; // 0 return values
}
static int func_player_mod_bash_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_num_dodges_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_dodges_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_dodges_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_hit_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_sight_range(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sight_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).sight_range(parameter1));
    return 1; // 1 return values
}
static int func_player_reset(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset();
    return 0; // 0 return values
}
static int func_player_speed_rating(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to speed_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).speed_rating());
    return 1; // 1 return values
}
static int func_player_get_num_blocks_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks_bonus());
    return 1; // 1 return values
}
static int func_player_get_armor_bash_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_base(parameter1));
    return 1; // 1 return values
}
static int func_player_has_weapon(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_weapon());
    return 1; // 1 return values
}
static int func_player_posz(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posz, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posz());
    return 1; // 1 return values
}
static int func_player_get_armor_cut(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut(parameter1));
    return 1; // 1 return values
}
static int func_player_reset_stats(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_stats, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_stats();
    return 0; // 0 return values
}
static int func_player_set_num_blocks_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_blocks_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_blocks_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_cut_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_has_grab_break_tec(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_grab_break_tec, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_grab_break_tec());
    return 1; // 1 return values
}
static int func_player_mod_dodge_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_is_symbol_highlighted(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_symbol_highlighted, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_symbol_highlighted());
    return 1; // 1 return values
}
static int func_player_move_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_effects, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).move_effects(parameter1));
    return 1; // 1 return values
}
static int func_player_get_hit_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_base());
    return 1; // 1 return values
}
static int func_player_mod_speed_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_get_cut_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_cut_bonus());
    return 1; // 1 return values
}
static int func_player_in_sleep_state(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_sleep_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).in_sleep_state());
    return 1; // 1 return values
}
static int func_player_set_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_value, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_value(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_player_remove_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_sees(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaReference<Creature>::has(L, 2)) {
        auto && parameter1 = LuaReference<Creature>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaValue<point>::has(L, 2)) {
        auto && parameter1 = LuaValue<point>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are Creature or point or int or tripoint");
}
static int func_player_get_weight(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_weight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_weight());
    return 1; // 1 return values
}
static int func_player_symbol_color(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).symbol_color());
    return 1; // 1 return values
}
static int func_player_weight_capacity(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).weight_capacity());
    return 1; // 1 return values
}
static int func_player_uncanny_dodge(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to uncanny_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).uncanny_dodge());
    return 1; // 1 return values
}
static int func_player_set_block_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_speed_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_base, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_base(parameter1);
    return 0; // 0 return values
}
static int func_player_die(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to die, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).die(parameter1);
    return 0; // 0 return values
}
static int func_player_mod_block_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_symbol(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).symbol());
    return 1; // 1 return values
}
static int func_player_knock_back_from(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to knock_back_from, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).knock_back_from(parameter1);
    return 0; // 0 return values
}
static int func_player_set_bash_mult(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_mult(parameter1);
    return 0; // 0 return values
}
static int func_player_deal_melee_attack(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to deal_melee_attack, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).deal_melee_attack(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_avoid_trap(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<trap>::check(L, 3);
    auto && parameter2 = LuaReference<trap>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to avoid_trap, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).avoid_trap(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_clear_effects(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).clear_effects();
    return 0; // 0 return values
}
static int func_player_get_bash_mult(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_bash_mult());
    return 1; // 1 return values
}
static int func_player_get_speed(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed());
    return 1; // 1 return values
}
static int func_player_get_block_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_block_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_block_bonus());
    return 1; // 1 return values
}
static int func_player_get_speed_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_base());
    return 1; // 1 return values
}
static int func_player_has_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_mod_pain_noresist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain_noresist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain_noresist(parameter1);
    return 0; // 0 return values
}
static int func_player_set_armor_bash_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_moves(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_moves(parameter1);
    return 0; // 0 return values
}
static int func_player_add_env_effect(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(LuaEnum<body_part>::has(L, 6)) {
        auto && parameter5 = LuaEnum<body_part>::get(L, 6);
        if(LuaType<bool>::has(L, 7)) {
            auto && parameter6 = LuaType<bool>::get(L, 7);
            if(LuaType<int>::has(L, 8)) {
                auto && parameter7 = LuaType<int>::get(L, 8);
                if(LuaType<bool>::has(L, 9)) {
                    auto && parameter8 = LuaType<bool>::get(L, 9);
                    if(lua_gettop(L) > 9) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 9, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8));
                    return 1; // 1 return values
                }
                if(lua_gettop(L) == 8) {
                    if(lua_gettop(L) > 8) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 8, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7));
                    return 1; // 1 return values
                }
                return luaL_argerror(L, 8, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 7) {
                if(lua_gettop(L) > 7) {
                    return luaL_error(L, "Too many arguments to add_env_effect, expected only 7, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6));
                return 1; // 1 return values
            }
            return luaL_argerror(L, 7, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 6) {
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to add_env_effect, expected only 6, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 5) {
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to add_env_effect, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 5, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_check_dead_state(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to check_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).check_dead_state();
    return 0; // 0 return values
}
static int func_player_set_melee_quiet(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_melee_quiet, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_melee_quiet(parameter1);
    return 0; // 0 return values
}
static int func_player_set_hit_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_player_set_grab_resist(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_grab_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_grab_resist(parameter1);
    return 0; // 0 return values
}
static int func_player_fall_damage_mod(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fall_damage_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).fall_damage_mod());
    return 1; // 1 return values
}
static int func_player_get_random_body_part(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 2, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 1, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_player_get_melee(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_melee());
    return 1; // 1 return values
}
static int func_player_is_elec_immune(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_elec_immune, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_elec_immune());
    return 1; // 1 return values
}
static int func_player_is_on_ground(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_on_ground, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_on_ground());
    return 1; // 1 return values
}
static int func_player_get_armor_bash_bonus(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_bonus());
    return 1; // 1 return values
}
static int func_player_is_underwater(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_underwater, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_underwater());
    return 1; // 1 return values
}
static int func_player_stability_roll(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stability_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).stability_roll());
    return 1; // 1 return values
}
static int func_player_is_player(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_player, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_player());
    return 1; // 1 return values
}
static int func_player_get_effect_dur(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_player_apply_damage(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to apply_damage, expected only 4, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).apply_damage(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_player_impact(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to impact, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).impact(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_player_get_melee_quiet(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee_quiet, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).get_melee_quiet());
    return 1; // 1 return values
}
static int func_player_remove_value(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_value, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).remove_value(parameter1);
    return 0; // 0 return values
}
static int func_player_posy(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posy());
    return 1; // 1 return values
}
static int func_player_get_pain(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_pain());
    return 1; // 1 return values
}
static int func_player_set_pain(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_pain(parameter1);
    return 0; // 0 return values
}
static int func_player_get_armor_cut_base(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_base(parameter1));
    return 1; // 1 return values
}
static int func_player_dodge_roll(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to dodge_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).dodge_roll());
    return 1; // 1 return values
}
static int func_player_get_hit(lua_State *L) {
    player& instance = LuaReference<player>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit());
    return 1; // 1 return values
}
static int func_efftype_id_str(lua_State *L) {
    efftype_id& instance = LuaValue<efftype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_efftype_id_is_valid(lua_State *L) {
    efftype_id& instance = LuaValue<efftype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_efftype_id_obj(lua_State *L) {
    efftype_id& instance = LuaValue<efftype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<effect_type>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_efftype_id(lua_State *L) {
    if(LuaValue<efftype_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to efftype_id::efftype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<efftype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to efftype_id::efftype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<efftype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to efftype_id::efftype_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<efftype_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are efftype_id or string or nothing at all");
}
static int op_efftype_id_eq(lua_State *L) {
    const efftype_id &lhs = LuaValue<efftype_id>::get(L, 1);
    const efftype_id &rhs = LuaValue<efftype_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_furn_id_to_i(lua_State *L) {
    furn_id& instance = LuaValue<furn_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to to_i, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.to_i());
    return 1; // 1 return values
}
static int func_furn_id_obj(lua_State *L) {
    furn_id& instance = LuaValue<furn_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<furn_t>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_furn_id(lua_State *L) {
    if(LuaValue<furn_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<furn_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to furn_id::furn_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<furn_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to furn_id::furn_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<furn_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are furn_str_id or nothing at all");
}
static int op_furn_id_eq(lua_State *L) {
    const furn_id &lhs = LuaValue<furn_id>::get(L, 1);
    const furn_id &rhs = LuaValue<furn_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_volume_value(lua_State *L) {
    volume& instance = LuaValue<volume>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to value, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.value());
    return 1; // 1 return values
}
static int func_game_swap_critters(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaReference<Creature>::check(L, 3);
    auto && parameter2 = LuaReference<Creature>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to swap_critters, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.swap_critters(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_game_get_temperature(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_temperature, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_temperature());
    return 1; // 1 return values
}
static int func_game_draw_critter(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to draw_critter, expected only 3, got %d", lua_gettop(L));
    }
    instance.draw_critter(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_game_increase_kill_count(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to increase_kill_count, expected only 2, got %d", lua_gettop(L));
    }
    instance.increase_kill_count(parameter1);
    return 0; // 0 return values
}
static int func_game_spread_fungus(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to spread_fungus, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.spread_fungus(parameter1));
    return 1; // 1 return values
}
static int func_game_handle_liquid(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to handle_liquid, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.handle_liquid(parameter1));
    return 1; // 1 return values
}
static int func_game_knockback(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    LuaType<int>::check(L, 6);
    auto && parameter5 = LuaType<int>::get(L, 6);
    if(lua_gettop(L) > 6) {
        return luaL_error(L, "Too many arguments to knockback, expected only 6, got %d", lua_gettop(L));
    }
    instance.knockback(parameter1, parameter2, parameter3, parameter4, parameter5);
    return 0; // 0 return values
}
static int func_game_inventory_item_menu(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to inventory_item_menu, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.inventory_item_menu(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to inventory_item_menu, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<int>::push(L, instance.inventory_item_menu(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to inventory_item_menu, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.inventory_item_menu(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_game_natural_light_level(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to natural_light_level, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.natural_light_level(parameter1));
    return 1; // 1 return values
}
static int func_game_refresh_all(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to refresh_all, expected only 1, got %d", lua_gettop(L));
    }
    instance.refresh_all();
    return 0; // 0 return values
}
static int func_game_get_cur_om(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cur_om, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<overmap>::push(L, instance.get_cur_om());
    return 1; // 1 return values
}
static int func_game_plswim(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to plswim, expected only 2, got %d", lua_gettop(L));
    }
    instance.plswim(parameter1);
    return 0; // 0 return values
}
static int func_game_inv_for_flag(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to inv_for_flag, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.inv_for_flag(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_game_look_around(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to look_around, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.look_around());
    return 1; // 1 return values
}
static int func_game_flashbang(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to flashbang, expected only 3, got %d", lua_gettop(L));
        }
        instance.flashbang(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to flashbang, expected only 2, got %d", lua_gettop(L));
        }
        instance.flashbang(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_draw_hit_player(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to draw_hit_player, expected only 3, got %d", lua_gettop(L));
    }
    instance.draw_hit_player(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_game_zombie(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to zombie, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<monster>::push(L, instance.zombie(parameter1));
    return 1; // 1 return values
}
static int func_game_assign_faction_id(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to assign_faction_id, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.assign_faction_id());
    return 1; // 1 return values
}
static int func_game_teleport(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(LuaReference<player>::has(L, 2)) {
        auto && parameter1 = LuaReference<player>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to teleport, expected only 3, got %d", lua_gettop(L));
            }
            instance.teleport(parameter1, parameter2);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to teleport, expected only 2, got %d", lua_gettop(L));
            }
            instance.teleport(parameter1);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to teleport, expected only 1, got %d", lua_gettop(L));
        }
        instance.teleport();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are player or nothing at all");
}
static int func_game_draw(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to draw, expected only 1, got %d", lua_gettop(L));
    }
    instance.draw();
    return 0; // 0 return values
}
static int func_game_npc_by_id(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to npc_by_id, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.npc_by_id(parameter1));
    return 1; // 1 return values
}
static int func_game_assign_mission_id(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to assign_mission_id, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.assign_mission_id());
    return 1; // 1 return values
}
static int func_game_mon_at(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to mon_at, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.mon_at(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mon_at, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.mon_at(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_cancel_activity(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to cancel_activity, expected only 1, got %d", lua_gettop(L));
    }
    instance.cancel_activity();
    return 0; // 0 return values
}
static int func_game_add_zombie(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaReference<monster>::check(L, 2);
    auto && parameter1 = LuaReference<monster>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_zombie, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.add_zombie(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to add_zombie, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.add_zombie(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_npc_at(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to npc_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.npc_at(parameter1));
    return 1; // 1 return values
}
static int func_game_monster_at(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to monster_at, expected only 3, got %d", lua_gettop(L));
        }
        LuaReference<monster>::push(L, instance.monster_at(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to monster_at, expected only 2, got %d", lua_gettop(L));
        }
        LuaReference<monster>::push(L, instance.monster_at(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_save(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to save, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.save());
    return 1; // 1 return values
}
static int func_game_revive_corpse(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to revive_corpse, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.revive_corpse(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_game_nuke(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to nuke, expected only 2, got %d", lua_gettop(L));
    }
    instance.nuke(parameter1);
    return 0; // 0 return values
}
static int func_game_is_hostile_very_close(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hostile_very_close, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, instance.is_hostile_very_close());
    return 1; // 1 return values
}
static int func_game_draw_trail_to_square(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to draw_trail_to_square, expected only 3, got %d", lua_gettop(L));
    }
    instance.draw_trail_to_square(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_game_open_gate(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to open_gate, expected only 2, got %d", lua_gettop(L));
    }
    instance.open_gate(parameter1);
    return 0; // 0 return values
}
static int func_game_look_debug(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to look_debug, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.look_debug());
    return 1; // 1 return values
}
static int func_game_peek(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to peek, expected only 2, got %d", lua_gettop(L));
        }
        instance.peek(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to peek, expected only 1, got %d", lua_gettop(L));
        }
        instance.peek();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are tripoint or nothing at all");
}
static int func_game_num_zombies(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to num_zombies, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.num_zombies());
    return 1; // 1 return values
}
static int func_game_draw_sct(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to draw_sct, expected only 1, got %d", lua_gettop(L));
    }
    instance.draw_sct();
    return 0; // 0 return values
}
static int func_game_do_blast(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    LuaType<float>::check(L, 4);
    auto && parameter3 = LuaType<float>::get(L, 4);
    LuaType<bool>::check(L, 5);
    auto && parameter4 = LuaType<bool>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to do_blast, expected only 5, got %d", lua_gettop(L));
    }
    instance.do_blast(parameter1, parameter2, parameter3, parameter4);
    return 0; // 0 return values
}
static int func_game_is_empty(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_empty, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_empty(parameter1));
    return 1; // 1 return values
}
static int func_game_shockwave(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    LuaType<int>::check(L, 6);
    auto && parameter5 = LuaType<int>::get(L, 6);
    LuaType<bool>::check(L, 7);
    auto && parameter6 = LuaType<bool>::get(L, 7);
    if(lua_gettop(L) > 7) {
        return luaL_error(L, "Too many arguments to shockwave, expected only 7, got %d", lua_gettop(L));
    }
    instance.shockwave(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
    return 0; // 0 return values
}
static int func_game_use_computer(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to use_computer, expected only 2, got %d", lua_gettop(L));
    }
    instance.use_computer(parameter1);
    return 0; // 0 return values
}
static int func_game_fling_creature(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<float>::check(L, 4);
    auto && parameter3 = LuaType<float>::get(L, 4);
    if(LuaType<bool>::has(L, 5)) {
        auto && parameter4 = LuaType<bool>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to fling_creature, expected only 5, got %d", lua_gettop(L));
        }
        instance.fling_creature(parameter1, parameter2, parameter3, parameter4);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 4) {
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to fling_creature, expected only 4, got %d", lua_gettop(L));
        }
        instance.fling_creature(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_inv_for_all(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to inv_for_all, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.inv_for_all(parameter1));
    return 1; // 1 return values
}
static int func_game_kill_count(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to kill_count, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.kill_count(parameter1));
    return 1; // 1 return values
}
static int func_game_remove_zombie(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_zombie, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_zombie(parameter1);
    return 0; // 0 return values
}
static int func_game_clear_zombies(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_zombies, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_zombies();
    return 0; // 0 return values
}
static int func_game_emp_blast(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to emp_blast, expected only 2, got %d", lua_gettop(L));
    }
    instance.emp_blast(parameter1);
    return 0; // 0 return values
}
static int func_game_light_level(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to light_level, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.light_level(parameter1));
    return 1; // 1 return values
}
static int func_game_get_levz(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_levz, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_levz());
    return 1; // 1 return values
}
static int func_game_summon_mon(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to summon_mon, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.summon_mon(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_game_get_levy(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_levy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_levy());
    return 1; // 1 return values
}
static int func_game_draw_ter(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to draw_ter, expected only 2, got %d", lua_gettop(L));
        }
        instance.draw_ter(parameter1);
        return 0; // 0 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(LuaType<bool>::has(L, 4)) {
                auto && parameter3 = LuaType<bool>::get(L, 4);
                if(lua_gettop(L) > 4) {
                    return luaL_error(L, "Too many arguments to draw_ter, expected only 4, got %d", lua_gettop(L));
                }
                instance.draw_ter(parameter1, parameter2, parameter3);
                return 0; // 0 return values
            }
            if(lua_gettop(L) == 3) {
                if(lua_gettop(L) > 3) {
                    return luaL_error(L, "Too many arguments to draw_ter, expected only 3, got %d", lua_gettop(L));
                }
                instance.draw_ter(parameter1, parameter2);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to draw_ter, expected only 2, got %d", lua_gettop(L));
            }
            instance.draw_ter(parameter1);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to draw_ter, expected only 1, got %d", lua_gettop(L));
        }
        instance.draw_ter();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or tripoint or nothing at all");
}
static int func_game_assign_npc_id(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to assign_npc_id, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.assign_npc_id());
    return 1; // 1 return values
}
static int func_game_critter_at(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to critter_at, expected only 3, got %d", lua_gettop(L));
        }
        LuaReference<Creature>::push(L, instance.critter_at(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to critter_at, expected only 2, got %d", lua_gettop(L));
        }
        LuaReference<Creature>::push(L, instance.critter_at(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_spawn_hallucination(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to spawn_hallucination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.spawn_hallucination());
    return 1; // 1 return values
}
static int func_game_is_in_sunlight(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_in_sunlight, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_in_sunlight(parameter1));
    return 1; // 1 return values
}
static int func_game_explosion(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(LuaType<float>::has(L, 4)) {
        auto && parameter3 = LuaType<float>::get(L, 4);
        if(LuaType<int>::has(L, 5)) {
            auto && parameter4 = LuaType<int>::get(L, 5);
            if(LuaType<bool>::has(L, 6)) {
                auto && parameter5 = LuaType<bool>::get(L, 6);
                if(lua_gettop(L) > 6) {
                    return luaL_error(L, "Too many arguments to explosion, expected only 6, got %d", lua_gettop(L));
                }
                instance.explosion(parameter1, parameter2, parameter3, parameter4, parameter5);
                return 0; // 0 return values
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to explosion, expected only 5, got %d", lua_gettop(L));
                }
                instance.explosion(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are bool or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to explosion, expected only 4, got %d", lua_gettop(L));
            }
            instance.explosion(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to explosion, expected only 3, got %d", lua_gettop(L));
        }
        instance.explosion(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
}
static int func_game_resonance_cascade(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to resonance_cascade, expected only 2, got %d", lua_gettop(L));
    }
    instance.resonance_cascade(parameter1);
    return 0; // 0 return values
}
static int func_game_draw_explosion(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to draw_explosion, expected only 4, got %d", lua_gettop(L));
    }
    instance.draw_explosion(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_game_scrambler_blast(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to scrambler_blast, expected only 2, got %d", lua_gettop(L));
    }
    instance.scrambler_blast(parameter1);
    return 0; // 0 return values
}
static int func_game_draw_hit_mon(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<monster>::check(L, 3);
    auto && parameter2 = LuaReference<monster>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to draw_hit_mon, expected only 4, got %d", lua_gettop(L));
        }
        instance.draw_hit_mon(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to draw_hit_mon, expected only 3, got %d", lua_gettop(L));
        }
        instance.draw_hit_mon(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_game_unload(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to unload, expected only 2, got %d", lua_gettop(L));
        }
        instance.unload(parameter1);
        return 0; // 0 return values
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to unload, expected only 2, got %d", lua_gettop(L));
        }
        instance.unload(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to unload, expected only 1, got %d", lua_gettop(L));
        }
        instance.unload();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or item or nothing at all");
}
static int func_game_plfire(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to plfire, expected only 1, got %d", lua_gettop(L));
    }
    instance.plfire();
    return 0; // 0 return values
}
static int func_game_is_sheltered(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_sheltered, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_sheltered(parameter1));
    return 1; // 1 return values
}
static int func_game_get_levx(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_levx, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_levx());
    return 1; // 1 return values
}
static int func_game_is_hostile_nearby(lua_State *L) {
    game& instance = LuaReference<game>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hostile_nearby, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, instance.is_hostile_nearby());
    return 1; // 1 return values
}
static int func_trap_str_id_str(lua_State *L) {
    trap_str_id& instance = LuaValue<trap_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_trap_str_id_is_valid(lua_State *L) {
    trap_str_id& instance = LuaValue<trap_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_trap_str_id_id(lua_State *L) {
    trap_str_id& instance = LuaValue<trap_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to id, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<trap_id>::push(L, instance.id());
    return 1; // 1 return values
}
static int new_trap_str_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to trap_str_id::trap_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<trap_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<trap_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<trap_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to trap_str_id::trap_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<trap_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to trap_str_id::trap_str_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<trap_str_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or trap_str_id or nothing at all");
}
static int op_trap_str_id_eq(lua_State *L) {
    const trap_str_id &lhs = LuaValue<trap_str_id>::get(L, 1);
    const trap_str_id &rhs = LuaValue<trap_str_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_ter_str_id_str(lua_State *L) {
    ter_str_id& instance = LuaValue<ter_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_ter_str_id_is_valid(lua_State *L) {
    ter_str_id& instance = LuaValue<ter_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_ter_str_id_id(lua_State *L) {
    ter_str_id& instance = LuaValue<ter_str_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to id, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<ter_id>::push(L, instance.id());
    return 1; // 1 return values
}
static int new_ter_str_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ter_str_id::ter_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ter_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ter_str_id::ter_str_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ter_str_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to ter_str_id::ter_str_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<ter_str_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or ter_str_id or nothing at all");
}
static int op_ter_str_id_eq(lua_State *L) {
    const ter_str_id &lhs = LuaValue<ter_str_id>::get(L, 1);
    const ter_str_id &rhs = LuaValue<ter_str_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_matec_id_str(lua_State *L) {
    matec_id& instance = LuaValue<matec_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_matec_id_is_valid(lua_State *L) {
    matec_id& instance = LuaValue<matec_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_matec_id_obj(lua_State *L) {
    matec_id& instance = LuaValue<matec_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<ma_technique>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_matec_id(lua_State *L) {
    if(LuaValue<matec_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<matec_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to matec_id::matec_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<matec_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to matec_id::matec_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<matec_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to matec_id::matec_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<matec_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are matec_id or string or nothing at all");
}
static int op_matec_id_eq(lua_State *L) {
    const matec_id &lhs = LuaValue<matec_id>::get(L, 1);
    const matec_id &rhs = LuaValue<matec_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_mongroup_id_str(lua_State *L) {
    mongroup_id& instance = LuaValue<mongroup_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_mongroup_id_is_valid(lua_State *L) {
    mongroup_id& instance = LuaValue<mongroup_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_mongroup_id_obj(lua_State *L) {
    mongroup_id& instance = LuaValue<mongroup_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<MonsterGroup>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_mongroup_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mongroup_id::mongroup_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mongroup_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<mongroup_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<mongroup_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to mongroup_id::mongroup_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<mongroup_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to mongroup_id::mongroup_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<mongroup_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or mongroup_id or nothing at all");
}
static int op_mongroup_id_eq(lua_State *L) {
    const mongroup_id &lhs = LuaValue<mongroup_id>::get(L, 1);
    const mongroup_id &rhs = LuaValue<mongroup_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int new_point(lua_State *L) {
    if(LuaValue<point>::has(L, 2)) {
        auto && parameter1 = LuaValue<point>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to point::point, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<point>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to point::point, expected only 3, got %d", lua_gettop(L));
        }
        LuaValue<point>::push(L, parameter1, parameter2);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are point or int");
}
static int op_point_eq(lua_State *L) {
    const point &lhs = LuaValue<point>::get(L, 1);
    const point &rhs = LuaValue<point>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_calendar_years(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to years, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.years());
    return 1; // 1 return values
}
static int func_calendar_sunrise(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sunrise, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<calendar>::push(L, instance.sunrise());
    return 1; // 1 return values
}
static int func_calendar_day_of_year(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to day_of_year, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.day_of_year());
    return 1; // 1 return values
}
static int func_calendar_textify_period(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to textify_period, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.textify_period());
    return 1; // 1 return values
}
static int func_calendar_seconds_past_midnight(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to seconds_past_midnight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.seconds_past_midnight());
    return 1; // 1 return values
}
static int func_calendar_turn_of_year(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to turn_of_year, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.turn_of_year());
    return 1; // 1 return values
}
static int func_calendar_minutes(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to minutes, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.minutes());
    return 1; // 1 return values
}
static int func_calendar_minutes_past_midnight(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to minutes_past_midnight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.minutes_past_midnight());
    return 1; // 1 return values
}
static int func_calendar_days(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to days, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.days());
    return 1; // 1 return values
}
static int func_calendar_seconds(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to seconds, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.seconds());
    return 1; // 1 return values
}
static int func_calendar_get_season(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_season, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<season_type>::push(L, instance.get_season());
    return 1; // 1 return values
}
static int func_calendar_day_of_week(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to day_of_week, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.day_of_week());
    return 1; // 1 return values
}
static int func_calendar_increment(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to increment, expected only 1, got %d", lua_gettop(L));
    }
    instance.increment();
    return 0; // 0 return values
}
static int func_calendar_is_night(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_night, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_night());
    return 1; // 1 return values
}
static int func_calendar_sunlight(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sunlight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.sunlight());
    return 1; // 1 return values
}
static int func_calendar_sunset(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sunset, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<calendar>::push(L, instance.sunset());
    return 1; // 1 return values
}
static int func_calendar_hours(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hours, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.hours());
    return 1; // 1 return values
}
static int func_calendar_get_turn(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_turn, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_turn());
    return 1; // 1 return values
}
static int func_calendar_print_time(lua_State *L) {
    calendar& instance = LuaValueOrReference<calendar>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to print_time, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.print_time(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to print_time, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.print_time());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int new_calendar(lua_State *L) {
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(LuaType<int>::has(L, 3)) {
            auto && parameter2 = LuaType<int>::get(L, 3);
            LuaType<int>::check(L, 4);
            auto && parameter3 = LuaType<int>::get(L, 4);
            LuaEnum<season_type>::check(L, 5);
            auto && parameter4 = LuaEnum<season_type>::get(L, 5);
            LuaType<int>::check(L, 6);
            auto && parameter5 = LuaType<int>::get(L, 6);
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to calendar::calendar, expected only 6, got %d", lua_gettop(L));
            }
            LuaValue<calendar>::push(L, parameter1, parameter2, parameter3, parameter4, parameter5);
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to calendar::calendar, expected only 2, got %d", lua_gettop(L));
            }
            LuaValue<calendar>::push(L, parameter1);
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
    }
    if(LuaValueOrReference<calendar>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<calendar>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to calendar::calendar, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<calendar>::push(L, parameter1);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or calendar");
}
static int func_uimenu_show(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to show, expected only 1, got %d", lua_gettop(L));
    }
    instance.show();
    return 0; // 0 return values
}
static int func_uimenu_addentry(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to addentry, expected only 2, got %d", lua_gettop(L));
    }
    instance.addentry(parameter1);
    return 0; // 0 return values
}
static int func_uimenu_query(lua_State *L) {
    uimenu& instance = LuaReference<uimenu>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to query, expected only 2, got %d", lua_gettop(L));
    }
    instance.query(parameter1);
    return 0; // 0 return values
}
static int func_map_stack_erase(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    LuaValue<item_stack_iterator>::check(L, 2);
    auto && parameter1 = LuaValue<item_stack_iterator>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to erase, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<item_stack_iterator>::push(L, instance.erase(parameter1));
    return 1; // 1 return values
}
static int func_map_stack_cppbegin(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to cppbegin, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item_stack_iterator>::push(L, instance.begin());
    return 1; // 1 return values
}
static int func_map_stack_push_back(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to push_back, expected only 2, got %d", lua_gettop(L));
    }
    instance.push_back(parameter1);
    return 0; // 0 return values
}
static int func_map_stack_empty(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to empty, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.empty());
    return 1; // 1 return values
}
static int func_map_stack_cppend(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to cppend, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item_stack_iterator>::push(L, instance.end());
    return 1; // 1 return values
}
static int func_map_stack_size(lua_State *L) {
    map_stack& instance = LuaValue<map_stack>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to size, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.size());
    return 1; // 1 return values
}
static int func_ter_id_to_i(lua_State *L) {
    ter_id& instance = LuaValue<ter_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to to_i, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.to_i());
    return 1; // 1 return values
}
static int func_ter_id_obj(lua_State *L) {
    ter_id& instance = LuaValue<ter_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<ter_t>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_ter_id(lua_State *L) {
    if(LuaValue<ter_str_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<ter_str_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ter_id::ter_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ter_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to ter_id::ter_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<ter_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are ter_str_id or nothing at all");
}
static int op_ter_id_eq(lua_State *L) {
    const ter_id &lhs = LuaValue<ter_id>::get(L, 1);
    const ter_id &rhs = LuaValue<ter_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_Character_has_bionic(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_bionic, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_bionic(parameter1));
    return 1; // 1 return values
}
static int func_Character_random_good_trait(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to random_good_trait, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.random_good_trait());
    return 1; // 1 return values
}
static int func_Character_get_item_position(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_item_position, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_item_position(parameter1));
    return 1; // 1 return values
}
static int func_Character_can_pickVolume(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_pickVolume, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_pickVolume(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_pickVolume, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_pickVolume(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_Character_get_per_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_per_bonus());
    return 1; // 1 return values
}
static int func_Character_add_traits(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to add_traits, expected only 1, got %d", lua_gettop(L));
    }
    instance.add_traits();
    return 0; // 0 return values
}
static int func_Character_set_per_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_per_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_per_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_mutation_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutation_effect, expected only 2, got %d", lua_gettop(L));
    }
    instance.mutation_effect(parameter1);
    return 0; // 0 return values
}
static int func_Character_weight_carried(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_carried, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.weight_carried());
    return 1; // 1 return values
}
static int func_Character_set_dex_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dex_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_dex_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_mutation(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_mutation, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_mutation(parameter1);
    return 0; // 0 return values
}
static int func_Character_remove_weapon(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to remove_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item>::push(L, instance.remove_weapon());
    return 1; // 1 return values
}
static int func_Character_recalc_hp(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recalc_hp, expected only 1, got %d", lua_gettop(L));
    }
    instance.recalc_hp();
    return 0; // 0 return values
}
static int func_Character_get_dex_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_dex_base());
    return 1; // 1 return values
}
static int func_Character_get_healthy_mod(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_healthy_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_healthy_mod());
    return 1; // 1 return values
}
static int func_Character_is_wearing_on_bp(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to is_wearing_on_bp, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_wearing_on_bp(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Character_recalc_sight_limits(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to recalc_sight_limits, expected only 1, got %d", lua_gettop(L));
    }
    instance.recalc_sight_limits();
    return 0; // 0 return values
}
static int func_Character_set_healthy_mod(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_healthy_mod, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_healthy_mod(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_turn_died(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_turn_died, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_turn_died());
    return 1; // 1 return values
}
static int func_Character_set_healthy(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_healthy, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_healthy(parameter1);
    return 0; // 0 return values
}
static int func_Character_has_nv(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_nv, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_nv());
    return 1; // 1 return values
}
static int func_Character_has_active_mutation(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_mutation, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_active_mutation(parameter1));
    return 1; // 1 return values
}
static int func_Character_worn_with_flag(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to worn_with_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.worn_with_flag(parameter1));
    return 1; // 1 return values
}
static int func_Character_i_add_or_drop(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to i_add_or_drop, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.i_add_or_drop(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_add_or_drop, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.i_add_or_drop(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_Character_mutation_loss_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mutation_loss_effect, expected only 2, got %d", lua_gettop(L));
    }
    instance.mutation_loss_effect(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_str_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_str_bonus());
    return 1; // 1 return values
}
static int func_Character_set_thirst(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_thirst, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_thirst(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_int_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_int_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_int_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_str_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_str_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_str_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_aim_per_move(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to aim_per_move, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.aim_per_move(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Character_get_int_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_int_base());
    return 1; // 1 return values
}
static int func_Character_can_use(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaValueOrReference<item>::has(L, 3)) {
        auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_use, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_use(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_use, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_use(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are item or nothing at all");
}
static int func_Character_pick_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to pick_name, expected only 2, got %d", lua_gettop(L));
        }
        instance.pick_name(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to pick_name, expected only 1, got %d", lua_gettop(L));
        }
        instance.pick_name();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_Character_get_per_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_per_base());
    return 1; // 1 return values
}
static int func_Character_get_thirst(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_thirst, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_thirst());
    return 1; // 1 return values
}
static int func_Character_empty_skills(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to empty_skills, expected only 1, got %d", lua_gettop(L));
    }
    instance.empty_skills();
    return 0; // 0 return values
}
static int func_Character_volume_carried(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to volume_carried, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.volume_carried());
    return 1; // 1 return values
}
static int func_Character_get_dex(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_dex());
    return 1; // 1 return values
}
static int func_Character_i_at(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.i_at(parameter1));
    return 1; // 1 return values
}
static int func_Character_i_rem_keep_contents(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_rem_keep_contents, expected only 2, got %d", lua_gettop(L));
    }
    instance.i_rem_keep_contents(parameter1);
    return 0; // 0 return values
}
static int func_Character_made_of(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<material_id>::check(L, 2);
    auto && parameter1 = LuaValue<material_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.made_of(parameter1));
    return 1; // 1 return values
}
static int func_Character_can_pickWeight(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_pickWeight, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_pickWeight(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_pickWeight, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_pickWeight(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_Character_get_vision_threshold(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_vision_threshold, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_vision_threshold(parameter1));
    return 1; // 1 return values
}
static int func_Character_unset_mutation(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to unset_mutation, expected only 2, got %d", lua_gettop(L));
    }
    instance.unset_mutation(parameter1);
    return 0; // 0 return values
}
static int func_Character_has_active_item(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_active_item(parameter1));
    return 1; // 1 return values
}
static int func_Character_get_str(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_str());
    return 1; // 1 return values
}
static int func_Character_is_wearing(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_wearing, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_wearing(parameter1));
    return 1; // 1 return values
}
static int func_Character_mod_per_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_per_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_per_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_empty_traits(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to empty_traits, expected only 1, got %d", lua_gettop(L));
    }
    instance.empty_traits();
    return 0; // 0 return values
}
static int func_Character_update_health(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to update_health, expected only 2, got %d", lua_gettop(L));
        }
        instance.update_health(parameter1);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to update_health, expected only 1, got %d", lua_gettop(L));
        }
        instance.update_health();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_Character_i_rem(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, instance.i_rem(parameter1));
        return 1; // 1 return values
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to i_rem, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, instance.i_rem(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or item");
}
static int func_Character_mod_stomach_food(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_stomach_food, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_stomach_food(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_thirst(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_thirst, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_thirst(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_int(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_int());
    return 1; // 1 return values
}
static int func_Character_random_bad_trait(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to random_bad_trait, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.random_bad_trait());
    return 1; // 1 return values
}
static int func_Character_mod_dex_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dex_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_dex_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_str_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_str_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_str_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_toggle_trait(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to toggle_trait, expected only 2, got %d", lua_gettop(L));
    }
    instance.toggle_trait(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_str_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_str_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_str_base());
    return 1; // 1 return values
}
static int func_Character_get_per(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_per, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_per());
    return 1; // 1 return values
}
static int func_Character_get_dex_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dex_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_dex_bonus());
    return 1; // 1 return values
}
static int func_Character_set_fatigue(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fatigue, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_fatigue(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_hunger(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hunger, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_hunger(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_stomach_water(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_stomach_water, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_stomach_water(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_healthy(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_healthy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_healthy());
    return 1; // 1 return values
}
static int func_Character_remove_mission_items(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_mission_items, expected only 2, got %d", lua_gettop(L));
    }
    instance.remove_mission_items(parameter1);
    return 0; // 0 return values
}
static int func_Character_has_trait_flag(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_trait_flag(parameter1));
    return 1; // 1 return values
}
static int func_Character_set_hunger(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hunger, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_hunger(parameter1);
    return 0; // 0 return values
}
static int func_Character_is_worn(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_worn, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_worn(parameter1));
    return 1; // 1 return values
}
static int func_Character_get_fatigue(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_fatigue, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_fatigue());
    return 1; // 1 return values
}
static int func_Character_volume_capacity(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to volume_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.volume_capacity());
    return 1; // 1 return values
}
static int func_Character_limb_color(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    LuaType<bool>::check(L, 5);
    auto && parameter4 = LuaType<bool>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to limb_color, expected only 5, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.limb_color(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int func_Character_mod_healthy(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_healthy, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_healthy(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_int_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_int_bonus, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_int_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_has_active_bionic(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_active_bionic, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_active_bionic(parameter1));
    return 1; // 1 return values
}
static int func_Character_mod_fatigue(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_fatigue, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_fatigue(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_stomach_water(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_stomach_water, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_stomach_water());
    return 1; // 1 return values
}
static int func_Character_get_stomach_food(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_stomach_food, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_stomach_food());
    return 1; // 1 return values
}
static int func_Character_set_turn_died(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_turn_died, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_turn_died(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_hunger(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hunger, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_hunger());
    return 1; // 1 return values
}
static int func_Character_has_base_trait(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_base_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_base_trait(parameter1));
    return 1; // 1 return values
}
static int func_Character_mod_healthy_mod(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_healthy_mod, expected only 3, got %d", lua_gettop(L));
    }
    instance.mod_healthy_mod(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Character_set_stomach_food(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_stomach_food, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_stomach_food(parameter1);
    return 0; // 0 return values
}
static int func_Character_i_add(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to i_add, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.i_add(parameter1));
    return 1; // 1 return values
}
static int func_Character_mod_stomach_water(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_stomach_water, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_stomach_water(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_int_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_int_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_int_bonus());
    return 1; // 1 return values
}
static int func_Character_trait_by_invlet(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to trait_by_invlet, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.trait_by_invlet(parameter1));
    return 1; // 1 return values
}
static int func_Character_is_dead_state(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_dead_state());
    return 1; // 1 return values
}
static int func_Character_basic_symbol_color(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to basic_symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).basic_symbol_color());
    return 1; // 1 return values
}
static int func_Character_is_fake(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_fake, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_fake());
    return 1; // 1 return values
}
static int func_Character_melee_attack(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(LuaValue<matec_id>::has(L, 4)) {
        auto && parameter3 = LuaValue<matec_id>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 4, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are matec_id or nothing at all");
}
static int func_Character_get_killer(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_killer, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, static_cast<Creature&>(instance).get_killer());
    return 1; // 1 return values
}
static int func_Character_get_armor_bash(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash(parameter1));
    return 1; // 1 return values
}
static int func_Character_posx(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posx, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posx());
    return 1; // 1 return values
}
static int func_Character_hp_percentage(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hp_percentage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).hp_percentage());
    return 1; // 1 return values
}
static int func_Character_gibType(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gibType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).gibType());
    return 1; // 1 return values
}
static int func_Character_mod_moves(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_moves(parameter1);
    return 0; // 0 return values
}
static int func_Character_bloodType(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bloodType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).bloodType());
    return 1; // 1 return values
}
static int func_Character_digging(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to digging, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).digging());
    return 1; // 1 return values
}
static int func_Character_pos(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pos, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, static_cast<Creature&>(instance).pos());
    return 1; // 1 return values
}
static int func_Character_has_trait(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_trait(parameter1));
    return 1; // 1 return values
}
static int func_Character_get_perceived_pain(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_perceived_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_perceived_pain());
    return 1; // 1 return values
}
static int func_Character_is_monster(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_monster, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_monster());
    return 1; // 1 return values
}
static int func_Character_get_hp(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_Character_set_armor_cut_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_env_resist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_env_resist, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_env_resist(parameter1));
    return 1; // 1 return values
}
static int func_Character_set_fake(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fake, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_fake(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_pain(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain(parameter1);
    return 0; // 0 return values
}
static int func_Character_is_hallucination(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hallucination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_hallucination());
    return 1; // 1 return values
}
static int func_Character_get_throw_resist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_throw_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_throw_resist());
    return 1; // 1 return values
}
static int func_Character_get_value(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_value, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_value(parameter1));
    return 1; // 1 return values
}
static int func_Character_set_throw_resist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_throw_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_throw_resist(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_armor_cut_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_bonus());
    return 1; // 1 return values
}
static int func_Character_skin_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to skin_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).skin_name());
    return 1; // 1 return values
}
static int func_Character_get_hp_max(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_Character_set_cut_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_on_hit(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 3, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to on_hit, expected only 2, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).on_hit(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_mod_stat(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_stat, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_stat(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Character_setpos(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setpos, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).setpos(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_speed_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_bonus());
    return 1; // 1 return values
}
static int func_Character_get_size(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_size, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<m_size>::push(L, static_cast<Creature&>(instance).get_size());
    return 1; // 1 return values
}
static int func_Character_is_warm(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_warm, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_warm());
    return 1; // 1 return values
}
static int func_Character_process_turn(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_turn, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_turn();
    return 0; // 0 return values
}
static int func_Character_disp_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_Character_get_cut_mult(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_cut_mult());
    return 1; // 1 return values
}
static int func_Character_power_rating(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).power_rating());
    return 1; // 1 return values
}
static int func_Character_get_name(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_name());
    return 1; // 1 return values
}
static int func_Character_add_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaEnum<body_part>::has(L, 4)) {
        auto && parameter3 = LuaEnum<body_part>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<bool>::has(L, 7)) {
                    auto && parameter6 = LuaType<bool>::get(L, 7);
                    if(lua_gettop(L) > 7) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 7, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 6, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to add_effect, expected only 5, got %d", lua_gettop(L));
                }
                static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to add_effect, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_effect, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).add_effect(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_get_grab_resist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_grab_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_grab_resist());
    return 1; // 1 return values
}
static int func_Character_get_effect_int(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_get_hit_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_bonus());
    return 1; // 1 return values
}
static int func_Character_is_immune_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_immune_effect, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_immune_effect(parameter1));
    return 1; // 1 return values
}
static int func_Character_set_cut_mult(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_mult(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_num_dodges(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges());
    return 1; // 1 return values
}
static int func_Character_is_npc(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_npc, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_npc());
    return 1; // 1 return values
}
static int func_Character_set_bash_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_reset_bonuses(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_bonuses, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_bonuses();
    return 0; // 0 return values
}
static int func_Character_get_dodge_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_bonus());
    return 1; // 1 return values
}
static int func_Character_set_speed_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_hit_roll(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hit_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).hit_roll());
    return 1; // 1 return values
}
static int func_Character_get_num_blocks(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks());
    return 1; // 1 return values
}
static int func_Character_on_dodge(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to on_dodge, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).on_dodge(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Character_get_bash_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_bash_bonus());
    return 1; // 1 return values
}
static int func_Character_process_effects(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_effects();
    return 0; // 0 return values
}
static int func_Character_set_dodge_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_num_dodges_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges_bonus());
    return 1; // 1 return values
}
static int func_Character_get_dodge(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge());
    return 1; // 1 return values
}
static int func_Character_get_dodge_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_base());
    return 1; // 1 return values
}
static int func_Character_normalize(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to normalize, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).normalize();
    return 0; // 0 return values
}
static int func_Character_mod_bash_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_num_dodges_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_dodges_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_dodges_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_hit_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_sight_range(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sight_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).sight_range(parameter1));
    return 1; // 1 return values
}
static int func_Character_reset(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset();
    return 0; // 0 return values
}
static int func_Character_speed_rating(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to speed_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).speed_rating());
    return 1; // 1 return values
}
static int func_Character_get_num_blocks_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks_bonus());
    return 1; // 1 return values
}
static int func_Character_get_armor_bash_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_base(parameter1));
    return 1; // 1 return values
}
static int func_Character_has_weapon(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_weapon());
    return 1; // 1 return values
}
static int func_Character_posz(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posz, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posz());
    return 1; // 1 return values
}
static int func_Character_get_armor_cut(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut(parameter1));
    return 1; // 1 return values
}
static int func_Character_reset_stats(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_stats, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_stats();
    return 0; // 0 return values
}
static int func_Character_set_num_blocks_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_blocks_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_blocks_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_cut_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_has_grab_break_tec(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_grab_break_tec, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_grab_break_tec());
    return 1; // 1 return values
}
static int func_Character_mod_dodge_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_is_symbol_highlighted(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_symbol_highlighted, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_symbol_highlighted());
    return 1; // 1 return values
}
static int func_Character_move_effects(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_effects, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).move_effects(parameter1));
    return 1; // 1 return values
}
static int func_Character_get_hit_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_base());
    return 1; // 1 return values
}
static int func_Character_mod_speed_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_cut_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_cut_bonus());
    return 1; // 1 return values
}
static int func_Character_in_sleep_state(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_sleep_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).in_sleep_state());
    return 1; // 1 return values
}
static int func_Character_set_value(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_value, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_value(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_Character_remove_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_sees(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaReference<Creature>::has(L, 2)) {
        auto && parameter1 = LuaReference<Creature>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaValue<point>::has(L, 2)) {
        auto && parameter1 = LuaValue<point>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are Creature or point or int or tripoint");
}
static int func_Character_get_weight(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_weight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_weight());
    return 1; // 1 return values
}
static int func_Character_symbol_color(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).symbol_color());
    return 1; // 1 return values
}
static int func_Character_weight_capacity(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).weight_capacity());
    return 1; // 1 return values
}
static int func_Character_uncanny_dodge(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to uncanny_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).uncanny_dodge());
    return 1; // 1 return values
}
static int func_Character_set_block_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_speed_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_base, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_base(parameter1);
    return 0; // 0 return values
}
static int func_Character_die(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to die, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).die(parameter1);
    return 0; // 0 return values
}
static int func_Character_mod_block_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_symbol(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).symbol());
    return 1; // 1 return values
}
static int func_Character_knock_back_from(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to knock_back_from, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).knock_back_from(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_bash_mult(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_mult(parameter1);
    return 0; // 0 return values
}
static int func_Character_deal_melee_attack(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to deal_melee_attack, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).deal_melee_attack(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Character_avoid_trap(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<trap>::check(L, 3);
    auto && parameter2 = LuaReference<trap>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to avoid_trap, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).avoid_trap(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Character_clear_effects(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).clear_effects();
    return 0; // 0 return values
}
static int func_Character_get_bash_mult(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_bash_mult());
    return 1; // 1 return values
}
static int func_Character_get_speed(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed());
    return 1; // 1 return values
}
static int func_Character_get_block_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_block_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_block_bonus());
    return 1; // 1 return values
}
static int func_Character_get_speed_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_base());
    return 1; // 1 return values
}
static int func_Character_has_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_mod_pain_noresist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain_noresist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain_noresist(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_armor_bash_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_moves(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_moves(parameter1);
    return 0; // 0 return values
}
static int func_Character_add_env_effect(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(LuaEnum<body_part>::has(L, 6)) {
        auto && parameter5 = LuaEnum<body_part>::get(L, 6);
        if(LuaType<bool>::has(L, 7)) {
            auto && parameter6 = LuaType<bool>::get(L, 7);
            if(LuaType<int>::has(L, 8)) {
                auto && parameter7 = LuaType<int>::get(L, 8);
                if(LuaType<bool>::has(L, 9)) {
                    auto && parameter8 = LuaType<bool>::get(L, 9);
                    if(lua_gettop(L) > 9) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 9, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8));
                    return 1; // 1 return values
                }
                if(lua_gettop(L) == 8) {
                    if(lua_gettop(L) > 8) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 8, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7));
                    return 1; // 1 return values
                }
                return luaL_argerror(L, 8, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 7) {
                if(lua_gettop(L) > 7) {
                    return luaL_error(L, "Too many arguments to add_env_effect, expected only 7, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6));
                return 1; // 1 return values
            }
            return luaL_argerror(L, 7, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 6) {
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to add_env_effect, expected only 6, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 5) {
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to add_env_effect, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 5, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_check_dead_state(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to check_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).check_dead_state();
    return 0; // 0 return values
}
static int func_Character_set_melee_quiet(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_melee_quiet, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_melee_quiet(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_hit_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_Character_set_grab_resist(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_grab_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_grab_resist(parameter1);
    return 0; // 0 return values
}
static int func_Character_fall_damage_mod(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fall_damage_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).fall_damage_mod());
    return 1; // 1 return values
}
static int func_Character_get_random_body_part(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 2, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 1, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_Character_get_melee(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_melee());
    return 1; // 1 return values
}
static int func_Character_is_elec_immune(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_elec_immune, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_elec_immune());
    return 1; // 1 return values
}
static int func_Character_is_on_ground(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_on_ground, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_on_ground());
    return 1; // 1 return values
}
static int func_Character_get_armor_bash_bonus(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_bonus());
    return 1; // 1 return values
}
static int func_Character_is_underwater(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_underwater, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_underwater());
    return 1; // 1 return values
}
static int func_Character_stability_roll(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stability_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).stability_roll());
    return 1; // 1 return values
}
static int func_Character_is_player(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_player, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_player());
    return 1; // 1 return values
}
static int func_Character_get_effect_dur(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_Character_apply_damage(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to apply_damage, expected only 4, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).apply_damage(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_Character_impact(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to impact, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).impact(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_Character_get_melee_quiet(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee_quiet, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).get_melee_quiet());
    return 1; // 1 return values
}
static int func_Character_remove_value(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_value, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).remove_value(parameter1);
    return 0; // 0 return values
}
static int func_Character_posy(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posy());
    return 1; // 1 return values
}
static int func_Character_get_pain(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_pain());
    return 1; // 1 return values
}
static int func_Character_set_pain(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_pain(parameter1);
    return 0; // 0 return values
}
static int func_Character_get_armor_cut_base(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_base(parameter1));
    return 1; // 1 return values
}
static int func_Character_dodge_roll(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to dodge_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).dodge_roll());
    return 1; // 1 return values
}
static int func_Character_get_hit(lua_State *L) {
    Character& instance = LuaReference<Character>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit());
    return 1; // 1 return values
}
static int func_item_is_watertight_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_watertight_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_watertight_container());
    return 1; // 1 return values
}
static int func_item_ammo_capacity(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ammo_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.ammo_capacity());
    return 1; // 1 return values
}
static int func_item_gun_recoil(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to gun_recoil, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_recoil(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_recoil, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_recoil(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_flammable(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to flammable, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.flammable());
    return 1; // 1 return values
}
static int func_item_on_wield(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_wield, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_wield(parameter1);
    return 0; // 0 return values
}
static int func_item_get_quality(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<quality_id>::check(L, 2);
    auto && parameter1 = LuaValue<quality_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_quality, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_quality(parameter1));
    return 1; // 1 return values
}
static int func_item_is_two_handed(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_two_handed, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_two_handed(parameter1));
    return 1; // 1 return values
}
static int func_item_put_in(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to put_in, expected only 2, got %d", lua_gettop(L));
    }
    instance.put_in(parameter1);
    return 0; // 0 return values
}
static int func_item_clear_vars(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_vars, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_vars();
    return 0; // 0 return values
}
static int func_item_amount_of(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to amount_of, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.amount_of(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_item_gun_cycle_mode(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gun_cycle_mode, expected only 1, got %d", lua_gettop(L));
    }
    instance.gun_cycle_mode();
    return 0; // 0 return values
}
static int func_item_is_bionic(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_bionic, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_bionic());
    return 1; // 1 return values
}
static int func_item_is_gun(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_gun, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_gun());
    return 1; // 1 return values
}
static int func_item_is_salvageable(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_salvageable, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_salvageable());
    return 1; // 1 return values
}
static int func_item_color_in_inventory(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to color_in_inventory, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.color_in_inventory());
    return 1; // 1 return values
}
static int func_item_get_mtype(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_mtype, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<mtype>::push(L, instance.get_mtype());
    return 1; // 1 return values
}
static int func_item_is_dangerous(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dangerous, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_dangerous());
    return 1; // 1 return values
}
static int func_item_get_env_resist(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_env_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_env_resist());
    return 1; // 1 return values
}
static int func_item_count_by_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to count_by_charges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.count_by_charges());
    return 1; // 1 return values
}
static int func_item_get_property_string(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(LuaType<std::string>::has(L, 3)) {
        auto && parameter2 = LuaType<std::string>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_property_string, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.get_property_string(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_property_string, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.get_property_string(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are string or nothing at all");
}
static int func_item_get_var(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(LuaType<float>::has(L, 3)) {
        auto && parameter2 = LuaType<float>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_var, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.get_var(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 3)) {
        auto && parameter2 = LuaType<std::string>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_var, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.get_var(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_var, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_var(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_var, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.get_var(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are float or string or int or nothing at all");
}
static int func_item_goes_bad(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to goes_bad, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.goes_bad());
    return 1; // 1 return values
}
static int func_item_get_thickness(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_thickness, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_thickness());
    return 1; // 1 return values
}
static int func_item_magazine_current(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to magazine_current, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.magazine_current());
    return 1; // 1 return values
}
static int func_item_set_mtype(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<mtype>::check(L, 2);
    auto && parameter1 = LuaReference<mtype>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_mtype, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_mtype(parameter1);
    return 0; // 0 return values
}
static int func_item_charges_of(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to charges_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.charges_of(parameter1));
    return 1; // 1 return values
}
static int func_item_conductive(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to conductive, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.conductive());
    return 1; // 1 return values
}
static int func_item_brewing_time(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to brewing_time, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.brewing_time());
    return 1; // 1 return values
}
static int func_item_merge_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to merge_charges, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.merge_charges(parameter1));
    return 1; // 1 return values
}
static int func_item_gun_range(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_range, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_range(parameter1));
        return 1; // 1 return values
    }
    if(LuaReference<player>::has(L, 2)) {
        auto && parameter1 = LuaReference<player>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_range, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_range(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to gun_range, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_range());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or player or nothing at all");
}
static int func_item_is_ammo(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_ammo, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_ammo());
    return 1; // 1 return values
}
static int func_item_get_remaining_chapters(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_remaining_chapters, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_remaining_chapters(parameter1));
    return 1; // 1 return values
}
static int func_item_components_to_string(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to components_to_string, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.components_to_string());
    return 1; // 1 return values
}
static int func_item_is_magazine(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_magazine, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_magazine());
    return 1; // 1 return values
}
static int func_item_has_rotten_away(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_rotten_away, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_rotten_away());
    return 1; // 1 return values
}
static int func_item_can_holster(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to can_holster, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_holster(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to can_holster, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.can_holster(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_inc_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to inc_damage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.inc_damage());
    return 1; // 1 return values
}
static int func_item_color(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.color());
    return 1; // 1 return values
}
static int func_item_is_container_empty(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_container_empty, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_container_empty());
    return 1; // 1 return values
}
static int func_item_convert(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to convert, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.convert(parameter1));
    return 1; // 1 return values
}
static int func_item_is_artifact(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_artifact, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_artifact());
    return 1; // 1 return values
}
static int func_item_already_used_by_player(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to already_used_by_player, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.already_used_by_player(parameter1));
    return 1; // 1 return values
}
static int func_item_mark_as_used_by_player(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mark_as_used_by_player, expected only 2, got %d", lua_gettop(L));
    }
    instance.mark_as_used_by_player(parameter1);
    return 0; // 0 return values
}
static int func_item_is_corpse(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_corpse, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_corpse());
    return 1; // 1 return values
}
static int func_item_is_food(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_food, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_food());
    return 1; // 1 return values
}
static int func_item_is_book(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_book, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_book());
    return 1; // 1 return values
}
static int func_item_mark_chapter_as_read(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mark_chapter_as_read, expected only 2, got %d", lua_gettop(L));
    }
    instance.mark_chapter_as_read(parameter1);
    return 0; // 0 return values
}
static int func_item_calc_rot(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to calc_rot, expected only 2, got %d", lua_gettop(L));
    }
    instance.calc_rot(parameter1);
    return 0; // 0 return values
}
static int func_item_gunmod_find(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to gunmod_find, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.gunmod_find(parameter1));
    return 1; // 1 return values
}
static int func_item_fill_with(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to fill_with, expected only 2, got %d", lua_gettop(L));
    }
    instance.fill_with(parameter1);
    return 0; // 0 return values
}
static int func_item_is_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_container());
    return 1; // 1 return values
}
static int func_item_ammo_current(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ammo_current, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.ammo_current());
    return 1; // 1 return values
}
static int func_item_melee_skill(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to melee_skill, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<skill_id>::push(L, instance.melee_skill());
    return 1; // 1 return values
}
static int func_item_set_relative_rot(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_relative_rot, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_relative_rot(parameter1);
    return 0; // 0 return values
}
static int func_item_is_silent(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_silent, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_silent());
    return 1; // 1 return values
}
static int func_item_volume(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to volume, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.volume());
    return 1; // 1 return values
}
static int func_item_add_technique(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<matec_id>::check(L, 2);
    auto && parameter1 = LuaValue<matec_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to add_technique, expected only 2, got %d", lua_gettop(L));
    }
    instance.add_technique(parameter1);
    return 0; // 0 return values
}
static int func_item_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to damage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.damage());
    return 1; // 1 return values
}
static int func_item_get_relative_rot(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_relative_rot, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.get_relative_rot());
    return 1; // 1 return values
}
static int func_item_craft_has_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to craft_has_charges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.craft_has_charges());
    return 1; // 1 return values
}
static int func_item_ready_to_revive(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to ready_to_revive, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.ready_to_revive(parameter1));
    return 1; // 1 return values
}
static int func_item_on_pickup(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<Character>::check(L, 2);
    auto && parameter1 = LuaReference<Character>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_pickup, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_pickup(parameter1);
    return 0; // 0 return values
}
static int func_item_is_going_bad(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_going_bad, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_going_bad());
    return 1; // 1 return values
}
static int func_item_get_side(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_side, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<side>::push(L, instance.get_side());
    return 1; // 1 return values
}
static int func_item_is_armor(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_armor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_armor());
    return 1; // 1 return values
}
static int func_item_gun_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_damage, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_damage(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to gun_damage, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_damage());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_get_remaining_capacity_for_liquid(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to get_remaining_capacity_for_liquid, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_remaining_capacity_for_liquid(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_item_acid_resist(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to acid_resist, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.acid_resist(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to acid_resist, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.acid_resist());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_is_ammo_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_ammo_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_ammo_container());
    return 1; // 1 return values
}
static int func_item_bash_resist(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to bash_resist, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_resist(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to bash_resist, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.bash_resist());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_load_info(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to load_info, expected only 2, got %d", lua_gettop(L));
    }
    instance.load_info(parameter1);
    return 0; // 0 return values
}
static int func_item_get_chapters(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_chapters, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_chapters());
    return 1; // 1 return values
}
static int func_item_serialize(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to serialize, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.serialize());
    return 1; // 1 return values
}
static int func_item_get_usable_item(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_usable_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.get_usable_item(parameter1));
    return 1; // 1 return values
}
static int func_item_is_null(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_null, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_null());
    return 1; // 1 return values
}
static int func_item_charges_per_volume(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<volume>::check(L, 2);
    auto && parameter1 = LuaValue<volume>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to charges_per_volume, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.charges_per_volume(parameter1));
    return 1; // 1 return values
}
static int func_item_is_emissive(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_emissive, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_emissive());
    return 1; // 1 return values
}
static int func_item_stacks_with(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to stacks_with, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.stacks_with(parameter1));
    return 1; // 1 return values
}
static int func_item_erase_var(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to erase_var, expected only 2, got %d", lua_gettop(L));
    }
    instance.erase_var(parameter1);
    return 0; // 0 return values
}
static int func_item_set_snippet(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_snippet, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_snippet(parameter1);
    return 0; // 0 return values
}
static int func_item_get_plant_epoch(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_plant_epoch, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_plant_epoch());
    return 1; // 1 return values
}
static int func_item_gun_set_mode(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to gun_set_mode, expected only 2, got %d", lua_gettop(L));
    }
    instance.gun_set_mode(parameter1);
    return 0; // 0 return values
}
static int func_item_get_storage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_storage, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<volume>::push(L, instance.get_storage());
    return 1; // 1 return values
}
static int func_item_has_label(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_label, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_label());
    return 1; // 1 return values
}
static int func_item_deserialize(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to deserialize, expected only 2, got %d", lua_gettop(L));
    }
    instance.deserialize(parameter1);
    return 0; // 0 return values
}
static int func_item_chip_resistance(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to chip_resistance, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.chip_resistance(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to chip_resistance, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.chip_resistance());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_symbol(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.symbol());
    return 1; // 1 return values
}
static int func_item_is_firearm(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_firearm, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_firearm());
    return 1; // 1 return values
}
static int func_item_get_property_long(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_property_long, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_property_long(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_property_long, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.get_property_long(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_item_is_food_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_food_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_food_container());
    return 1; // 1 return values
}
static int func_item_add_rain_to_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_rain_to_container, expected only 3, got %d", lua_gettop(L));
        }
        instance.add_rain_to_container(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to add_rain_to_container, expected only 2, got %d", lua_gettop(L));
        }
        instance.add_rain_to_container(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_item_has_flag(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag(parameter1));
    return 1; // 1 return values
}
static int func_item_is_gunmod(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_gunmod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_gunmod());
    return 1; // 1 return values
}
static int func_item_mod_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_charges, expected only 2, got %d", lua_gettop(L));
    }
    instance.mod_charges(parameter1);
    return 0; // 0 return values
}
static int func_item_typeId(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to typeId, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.typeId());
    return 1; // 1 return values
}
static int func_item_price(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to price, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.price(parameter1));
    return 1; // 1 return values
}
static int func_item_sight_dispersion(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to sight_dispersion, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.sight_dispersion());
    return 1; // 1 return values
}
static int func_item_type_name(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to type_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.type_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to type_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.type_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_item_tname(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to tname, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<std::string>::push(L, instance.tname(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to tname, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<std::string>::push(L, instance.tname(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to tname, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.tname());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_item_covers(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to covers, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.covers(parameter1));
    return 1; // 1 return values
}
static int func_item_gun_pierce(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_pierce, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_pierce(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to gun_pierce, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_pierce());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_weight(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.weight());
    return 1; // 1 return values
}
static int func_item_set_var(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(LuaType<float>::has(L, 3)) {
        auto && parameter2 = LuaType<float>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to set_var, expected only 3, got %d", lua_gettop(L));
        }
        instance.set_var(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(LuaType<std::string>::has(L, 3)) {
        auto && parameter2 = LuaType<std::string>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to set_var, expected only 3, got %d", lua_gettop(L));
        }
        instance.set_var(parameter1, parameter2);
        return 0; // 0 return values
    }
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to set_var, expected only 3, got %d", lua_gettop(L));
        }
        instance.set_var(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are float or string or int");
}
static int func_item_rotten(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to rotten, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.rotten());
    return 1; // 1 return values
}
static int func_item_reset_cable(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to reset_cable, expected only 2, got %d", lua_gettop(L));
    }
    instance.reset_cable(parameter1);
    return 0; // 0 return values
}
static int func_item_has_quality(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<quality_id>::check(L, 2);
    auto && parameter1 = LuaValue<quality_id>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_quality, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_quality(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_quality, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.has_quality(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_item_process_artifact(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to process_artifact, expected only 3, got %d", lua_gettop(L));
    }
    instance.process_artifact(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_item_has_var(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_var, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_var(parameter1));
    return 1; // 1 return values
}
static int func_item_gun_skill(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gun_skill, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<skill_id>::push(L, instance.gun_skill());
    return 1; // 1 return values
}
static int func_item_on_wear(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_wear, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_wear(parameter1);
    return 0; // 0 return values
}
static int func_item_get_coverage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_coverage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_coverage());
    return 1; // 1 return values
}
static int func_item_get_free_mod_locations(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_free_mod_locations, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_free_mod_locations(parameter1));
    return 1; // 1 return values
}
static int func_item_has_property(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_property, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_property(parameter1));
    return 1; // 1 return values
}
static int func_item_on_takeoff(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_takeoff, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_takeoff(parameter1);
    return 0; // 0 return values
}
static int func_item_ammo_remaining(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ammo_remaining, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.ammo_remaining());
    return 1; // 1 return values
}
static int func_item_needs_processing(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to needs_processing, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.needs_processing());
    return 1; // 1 return values
}
static int func_item_mod_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_damage, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.mod_damage(parameter1));
    return 1; // 1 return values
}
static int func_item_getlight_emit(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getlight_emit, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.getlight_emit());
    return 1; // 1 return values
}
static int func_item_min_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to min_damage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.min_damage());
    return 1; // 1 return values
}
static int func_item_is_tool(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_tool, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_tool());
    return 1; // 1 return values
}
static int func_item_processing_speed(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to processing_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.processing_speed());
    return 1; // 1 return values
}
static int func_item_is_power_armor(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_power_armor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_power_armor());
    return 1; // 1 return values
}
static int func_item_make_corpse(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaValue<mtype_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<std::string>::has(L, 4)) {
            auto && parameter3 = LuaType<std::string>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to make_corpse, expected only 4, got %d", lua_gettop(L));
            }
            instance.make_corpse(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to make_corpse, expected only 3, got %d", lua_gettop(L));
            }
            instance.make_corpse(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are string or nothing at all");
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to make_corpse, expected only 1, got %d", lua_gettop(L));
        }
        instance.make_corpse();
        return 0; // 0 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are mtype_id or nothing at all");
}
static int func_item_magazine_integral(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to magazine_integral, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.magazine_integral());
    return 1; // 1 return values
}
static int func_item_magazine_default(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to magazine_default, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.magazine_default(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to magazine_default, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.magazine_default());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_label(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to label, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.label(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to label, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.label());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_item_get_rot(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_rot, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_rot());
    return 1; // 1 return values
}
static int func_item_get_gun_ups_drain(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_gun_ups_drain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_gun_ups_drain());
    return 1; // 1 return values
}
static int func_item_max_damage(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to max_damage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.max_damage());
    return 1; // 1 return values
}
static int func_item_made_of(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaValue<material_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<material_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.made_of(parameter1));
        return 1; // 1 return values
    }
    if(LuaEnum<phase_id>::has(L, 2)) {
        auto && parameter1 = LuaEnum<phase_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.made_of(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are material_id or phase_id");
}
static int func_item_gun_dispersion(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to gun_dispersion, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_dispersion(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to gun_dispersion, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.gun_dispersion());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_is_sided(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_sided, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_sided());
    return 1; // 1 return values
}
static int func_item_display_name(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to display_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.display_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to display_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.display_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_item_process(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    LuaType<bool>::check(L, 4);
    auto && parameter3 = LuaType<bool>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to process, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.process(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_item_get_layer(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_layer, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_layer());
    return 1; // 1 return values
}
static int func_item_ammo_required(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ammo_required, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.ammo_required());
    return 1; // 1 return values
}
static int func_item_is_tool_reversible(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_tool_reversible, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_tool_reversible());
    return 1; // 1 return values
}
static int func_item_can_revive(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_revive, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_revive());
    return 1; // 1 return values
}
static int func_item_ammo_data(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to ammo_data, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<itype>::push(L, instance.ammo_data());
    return 1; // 1 return values
}
static int func_item_is_non_resealable_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_non_resealable_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_non_resealable_container());
    return 1; // 1 return values
}
static int func_item_get_plant_name(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_plant_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_plant_name());
    return 1; // 1 return values
}
static int func_item_get_warmth(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_warmth, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_warmth());
    return 1; // 1 return values
}
static int func_item_cut_resist(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to cut_resist, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.cut_resist(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to cut_resist, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.cut_resist());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_is_container_full(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_container_full, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_container_full());
    return 1; // 1 return values
}
static int func_item_get_encumber(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_encumber, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_encumber());
    return 1; // 1 return values
}
static int func_item_info(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to info, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.info(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to info, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.info());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_in_its_container(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_its_container, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item>::push(L, instance.in_its_container());
    return 1; // 1 return values
}
static int func_item_has_technique(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    LuaValue<matec_id>::check(L, 2);
    auto && parameter1 = LuaValue<matec_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_technique, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_technique(parameter1));
    return 1; // 1 return values
}
static int func_item_destroyed_at_zero_charges(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to destroyed_at_zero_charges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.destroyed_at_zero_charges());
    return 1; // 1 return values
}
static int func_item_is_seed(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_seed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_seed());
    return 1; // 1 return values
}
static int func_item_ammo_type(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to ammo_type, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<ammotype>::push(L, instance.ammo_type(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to ammo_type, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<ammotype>::push(L, instance.ammo_type());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_item_attack_time(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to attack_time, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.attack_time());
    return 1; // 1 return values
}
static int func_item_is_melee(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_melee());
    return 1; // 1 return values
}
static int func_item_fire_resist(lua_State *L) {
    item& instance = LuaValueOrReference<item>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to fire_resist, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.fire_resist(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to fire_resist, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.fire_resist());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int new_item(lua_State *L) {
    if(LuaReference<itype>::has(L, 2)) {
        auto && parameter1 = LuaReference<itype>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to item::item, expected only 4, got %d", lua_gettop(L));
            }
            LuaValue<item>::push(L, parameter1, parameter2, parameter3);
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to item::item, expected only 3, got %d", lua_gettop(L));
            }
            LuaValue<item>::push(L, parameter1, parameter2);
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to item::item, expected only 4, got %d", lua_gettop(L));
            }
            LuaValue<item>::push(L, parameter1, parameter2, parameter3);
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to item::item, expected only 3, got %d", lua_gettop(L));
            }
            LuaValue<item>::push(L, parameter1, parameter2);
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(LuaValueOrReference<item>::has(L, 2)) {
        auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to item::item, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to item::item, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<item>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are itype or string or item or nothing at all");
}
static int func_overmap_add_note(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<std::string>::check(L, 5);
    auto && parameter4 = LuaType<std::string>::get(L, 5);
    if(lua_gettop(L) > 5) {
        return luaL_error(L, "Too many arguments to add_note, expected only 5, got %d", lua_gettop(L));
    }
    instance.add_note(parameter1, parameter2, parameter3, parameter4);
    return 0; // 0 return values
}
static int func_overmap_has_note(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to has_note, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_note(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_overmap_find_random_omt(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to find_random_omt, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.find_random_omt(parameter1));
    return 1; // 1 return values
}
static int func_overmap_note(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to note, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.note(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_overmap_delete_note(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to delete_note, expected only 4, got %d", lua_gettop(L));
    }
    instance.delete_note(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_overmap_is_explored(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to is_explored, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_explored(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_overmap_clear_mon_groups(lua_State *L) {
    overmap& instance = LuaReference<overmap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_mon_groups, expected only 1, got %d", lua_gettop(L));
    }
    instance.clear_mon_groups();
    return 0; // 0 return values
}
static int func_matype_id_str(lua_State *L) {
    matype_id& instance = LuaValue<matype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_matype_id_is_valid(lua_State *L) {
    matype_id& instance = LuaValue<matype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_matype_id_obj(lua_State *L) {
    matype_id& instance = LuaValue<matype_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<martialart>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_matype_id(lua_State *L) {
    if(LuaValue<matype_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<matype_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to matype_id::matype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<matype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to matype_id::matype_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<matype_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to matype_id::matype_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<matype_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are matype_id or string or nothing at all");
}
static int op_matype_id_eq(lua_State *L) {
    const matype_id &lhs = LuaValue<matype_id>::get(L, 1);
    const matype_id &rhs = LuaValue<matype_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_trap_can_see(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<player>::check(L, 3);
    auto && parameter2 = LuaReference<player>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to can_see, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_see(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_trap_get_difficulty(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_difficulty, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_difficulty());
    return 1; // 1 return values
}
static int func_trap_is_3x3_trap(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_3x3_trap, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_3x3_trap());
    return 1; // 1 return values
}
static int func_trap_trigger(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<Creature>::check(L, 3);
    auto && parameter2 = LuaReference<Creature>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to trigger, expected only 3, got %d", lua_gettop(L));
    }
    instance.trigger(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_trap_detect_trap(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<player>::check(L, 3);
    auto && parameter2 = LuaReference<player>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to detect_trap, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.detect_trap(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_trap_is_benign(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_benign, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_benign());
    return 1; // 1 return values
}
static int func_trap_triggered_by_item(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to triggered_by_item, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.triggered_by_item(parameter1));
    return 1; // 1 return values
}
static int func_trap_is_funnel(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_funnel, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_funnel());
    return 1; // 1 return values
}
static int func_trap_funnel_turns_per_charge(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to funnel_turns_per_charge, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, instance.funnel_turns_per_charge(parameter1));
    return 1; // 1 return values
}
static int func_trap_is_null(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_null, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_null());
    return 1; // 1 return values
}
static int func_trap_on_disarmed(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to on_disarmed, expected only 2, got %d", lua_gettop(L));
    }
    instance.on_disarmed(parameter1);
    return 0; // 0 return values
}
static int func_trap_get_visibility(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_visibility, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_visibility());
    return 1; // 1 return values
}
static int func_trap_get_avoidance(lua_State *L) {
    trap& instance = LuaReference<trap>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_avoidance, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.get_avoidance());
    return 1; // 1 return values
}
static int func_species_id_str(lua_State *L) {
    species_id& instance = LuaValue<species_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_species_id_is_valid(lua_State *L) {
    species_id& instance = LuaValue<species_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_species_id_obj(lua_State *L) {
    species_id& instance = LuaValue<species_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<species_type>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_species_id(lua_State *L) {
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to species_id::species_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<species_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaValue<species_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<species_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to species_id::species_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<species_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to species_id::species_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<species_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are string or species_id or nothing at all");
}
static int op_species_id_eq(lua_State *L) {
    const species_id &lhs = LuaValue<species_id>::get(L, 1);
    const species_id &rhs = LuaValue<species_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_mongroup_inc_interest(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to inc_interest, expected only 2, got %d", lua_gettop(L));
    }
    instance.inc_interest(parameter1);
    return 0; // 0 return values
}
static int func_mongroup_dec_interest(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to dec_interest, expected only 2, got %d", lua_gettop(L));
    }
    instance.dec_interest(parameter1);
    return 0; // 0 return values
}
static int func_mongroup_set_interest(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_interest, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_interest(parameter1);
    return 0; // 0 return values
}
static int func_mongroup_set_target(lua_State *L) {
    mongroup& instance = LuaReference<mongroup>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_target, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_target(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_item_stack_iterator_elem(lua_State *L) {
    item_stack_iterator& instance = LuaValue<item_stack_iterator>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to elem, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<item>::push(L, instance.operator*());
    return 1; // 1 return values
}
static int func_item_stack_iterator_inc(lua_State *L) {
    item_stack_iterator& instance = LuaValue<item_stack_iterator>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to inc, expected only 1, got %d", lua_gettop(L));
    }
    instance.operator++();
    return 0; // 0 return values
}
static int new_item_stack_iterator(lua_State *L) {
    LuaValue<item_stack_iterator>::check(L, 2);
    auto && parameter1 = LuaValue<item_stack_iterator>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to item_stack_iterator::item_stack_iterator, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<item_stack_iterator>::push(L, parameter1);
    return 1; // 1 return values
}
static int op_item_stack_iterator_eq(lua_State *L) {
    const item_stack_iterator &lhs = LuaValue<item_stack_iterator>::get(L, 1);
    const item_stack_iterator &rhs = LuaValue<item_stack_iterator>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_ter_t_color(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.color());
    return 1; // 1 return values
}
static int func_ter_t_symbol(lua_State *L) {
    ter_t& instance = LuaReference<ter_t>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.symbol());
    return 1; // 1 return values
}
static int func_field_entry_isAlive(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to isAlive, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.isAlive());
    return 1; // 1 return values
}
static int func_field_entry_move_cost(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to move_cost, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.move_cost());
    return 1; // 1 return values
}
static int func_field_entry_getFieldAge(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getFieldAge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.getFieldAge());
    return 1; // 1 return values
}
static int func_field_entry_setFieldType(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    LuaEnum<field_id>::check(L, 2);
    auto && parameter1 = LuaEnum<field_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setFieldType, expected only 2, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.setFieldType(parameter1));
    return 1; // 1 return values
}
static int func_field_entry_setFieldDensity(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setFieldDensity, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.setFieldDensity(parameter1));
    return 1; // 1 return values
}
static int func_field_entry_setFieldAge(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setFieldAge, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.setFieldAge(parameter1));
    return 1; // 1 return values
}
static int func_field_entry_is_dangerous(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dangerous, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_dangerous());
    return 1; // 1 return values
}
static int func_field_entry_getFieldType(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getFieldType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.getFieldType());
    return 1; // 1 return values
}
static int func_field_entry_name(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.name());
    return 1; // 1 return values
}
static int func_field_entry_getFieldDensity(lua_State *L) {
    field_entry& instance = LuaReference<field_entry>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to getFieldDensity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.getFieldDensity());
    return 1; // 1 return values
}
static int func_tripoint_serialize(lua_State *L) {
    tripoint& instance = LuaValue<tripoint>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to serialize, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.serialize());
    return 1; // 1 return values
}
static int new_tripoint(lua_State *L) {
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        LuaType<int>::check(L, 4);
        auto && parameter3 = LuaType<int>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to tripoint::tripoint, expected only 4, got %d", lua_gettop(L));
        }
        LuaValue<tripoint>::push(L, parameter1, parameter2, parameter3);
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to tripoint::tripoint, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<tripoint>::push(L, parameter1);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or tripoint");
}
static int op_tripoint_eq(lua_State *L) {
    const tripoint &lhs = LuaValue<tripoint>::get(L, 1);
    const tripoint &rhs = LuaValue<tripoint>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_furn_t_color(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.color());
    return 1; // 1 return values
}
static int func_furn_t_symbol(lua_State *L) {
    furn_t& instance = LuaReference<furn_t>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.symbol());
    return 1; // 1 return values
}
static int func_material_id_str(lua_State *L) {
    material_id& instance = LuaValue<material_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to str, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.str());
    return 1; // 1 return values
}
static int func_material_id_is_valid(lua_State *L) {
    material_id& instance = LuaValue<material_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_valid, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_valid());
    return 1; // 1 return values
}
static int func_material_id_obj(lua_State *L) {
    material_id& instance = LuaValue<material_id>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to obj, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<material_type>::push(L, instance.obj());
    return 1; // 1 return values
}
static int new_material_id(lua_State *L) {
    if(LuaValue<material_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<material_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to material_id::material_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<material_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(LuaType<std::string>::has(L, 2)) {
        auto && parameter1 = LuaType<std::string>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to material_id::material_id, expected only 2, got %d", lua_gettop(L));
        }
        LuaValue<material_id>::push(L, parameter1);
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to material_id::material_id, expected only 1, got %d", lua_gettop(L));
        }
        LuaValue<material_id>::push(L);
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are material_id or string or nothing at all");
}
static int op_material_id_eq(lua_State *L) {
    const material_id &lhs = LuaValue<material_id>::get(L, 1);
    const material_id &rhs = LuaValue<material_id>::get(L, 2);
    bool rval = lhs == rhs;
    LuaType<bool>::push(L, rval);
    return 1; // 1 return values
}
static int func_itype_nname(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to nname, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.nname(parameter1));
    return 1; // 1 return values
}
static int func_itype_charges_to_use(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to charges_to_use, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.charges_to_use());
    return 1; // 1 return values
}
static int func_itype_has_use(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_use, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_use());
    return 1; // 1 return values
}
static int func_itype_charges_default(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to charges_default, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.charges_default());
    return 1; // 1 return values
}
static int func_itype_maximum_charges(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to maximum_charges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.maximum_charges());
    return 1; // 1 return values
}
static int func_itype_count_by_charges(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to count_by_charges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.count_by_charges());
    return 1; // 1 return values
}
static int func_itype_tick(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    LuaValue<tripoint>::check(L, 4);
    auto && parameter3 = LuaValue<tripoint>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to tick, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.tick(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_itype_can_use(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to can_use, expected only 2, got %d", lua_gettop(L));
    }
    instance.can_use(parameter1);
    return 0; // 0 return values
}
static int func_itype_get_item_type_string(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_item_type_string, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_item_type_string());
    return 1; // 1 return values
}
static int func_itype_invoke(lua_State *L) {
    itype& instance = LuaReference<itype>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    LuaValueOrReference<item>::check(L, 3);
    auto && parameter2 = LuaValueOrReference<item>::get(L, 3);
    LuaValue<tripoint>::check(L, 4);
    auto && parameter3 = LuaValue<tripoint>::get(L, 4);
    if(LuaType<std::string>::has(L, 5)) {
        auto && parameter4 = LuaType<std::string>::get(L, 5);
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to invoke, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.invoke(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 4) {
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to invoke, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.invoke(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 4, "Unexpected type, expected are string or nothing at all");
}
static int func_monster_bash_at(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to bash_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.bash_at(parameter1));
    return 1; // 1 return values
}
static int func_monster_move_target(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to move_target, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.move_target());
    return 1; // 1 return values
}
static int func_monster_explode(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to explode, expected only 1, got %d", lua_gettop(L));
    }
    instance.explode();
    return 0; // 0 return values
}
static int func_monster_calc_climb_cost(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to calc_climb_cost, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.calc_climb_cost(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_attack_target(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to attack_target, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, instance.attack_target());
    return 1; // 1 return values
}
static int func_monster_stumble(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stumble, expected only 1, got %d", lua_gettop(L));
    }
    instance.stumble();
    return 0; // 0 return values
}
static int func_monster_made_of(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaValue<material_id>::has(L, 2)) {
        auto && parameter1 = LuaValue<material_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.made_of(parameter1));
        return 1; // 1 return values
    }
    if(LuaEnum<phase_id>::has(L, 2)) {
        auto && parameter1 = LuaEnum<phase_id>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.made_of(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are material_id or phase_id");
}
static int func_monster_rate_target(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(LuaType<bool>::has(L, 4)) {
        auto && parameter3 = LuaType<bool>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to rate_target, expected only 4, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.rate_target(parameter1, parameter2, parameter3));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to rate_target, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<float>::push(L, instance.rate_target(parameter1, parameter2));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are bool or nothing at all");
}
static int func_monster_reset_special_rng(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to reset_special_rng, expected only 2, got %d", lua_gettop(L));
    }
    instance.reset_special_rng(parameter1);
    return 0; // 0 return values
}
static int func_monster_turns_to_reach(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to turns_to_reach, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.turns_to_reach(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_load_info(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to load_info, expected only 2, got %d", lua_gettop(L));
    }
    instance.load_info(parameter1);
    return 0; // 0 return values
}
static int func_monster_can_drown(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_drown, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_drown());
    return 1; // 1 return values
}
static int func_monster_to_item(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to to_item, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<item>::push(L, instance.to_item());
    return 1; // 1 return values
}
static int func_monster_color_with_effects(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to color_with_effects, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.color_with_effects());
    return 1; // 1 return values
}
static int func_monster_die_in_explosion(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to die_in_explosion, expected only 2, got %d", lua_gettop(L));
    }
    instance.die_in_explosion(parameter1);
    return 0; // 0 return values
}
static int func_monster_wander(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to wander, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.wander());
    return 1; // 1 return values
}
static int func_monster_bash_estimate(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bash_estimate, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.bash_estimate());
    return 1; // 1 return values
}
static int func_monster_wander_to(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to wander_to, expected only 3, got %d", lua_gettop(L));
    }
    instance.wander_to(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_unset_dest(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to unset_dest, expected only 1, got %d", lua_gettop(L));
    }
    instance.unset_dest();
    return 0; // 0 return values
}
static int func_monster_set_special(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_special, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_special(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_heal(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to heal, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.heal(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to heal, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, instance.heal(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_monster_can_hear(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_hear, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_hear());
    return 1; // 1 return values
}
static int func_monster_make_friendly(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to make_friendly, expected only 1, got %d", lua_gettop(L));
    }
    instance.make_friendly();
    return 0; // 0 return values
}
static int func_monster_make_ally(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<monster>::check(L, 2);
    auto && parameter1 = LuaReference<monster>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to make_ally, expected only 2, got %d", lua_gettop(L));
    }
    instance.make_ally(parameter1);
    return 0; // 0 return values
}
static int func_monster_is_dead(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dead, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_dead());
    return 1; // 1 return values
}
static int func_monster_try_upgrade(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to try_upgrade, expected only 2, got %d", lua_gettop(L));
    }
    instance.try_upgrade(parameter1);
    return 0; // 0 return values
}
static int func_monster_will_reach(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to will_reach, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.will_reach(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_can_act(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_act, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_act());
    return 1; // 1 return values
}
static int func_monster_is_fleeing(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<player>::check(L, 2);
    auto && parameter1 = LuaReference<player>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_fleeing, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.is_fleeing(parameter1));
    return 1; // 1 return values
}
static int func_monster_group_bash_skill(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to group_bash_skill, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.group_bash_skill(parameter1));
    return 1; // 1 return values
}
static int func_monster_shift(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to shift, expected only 3, got %d", lua_gettop(L));
    }
    instance.shift(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_disable_special(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to disable_special, expected only 2, got %d", lua_gettop(L));
    }
    instance.disable_special(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_hp(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hp, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_hp(parameter1);
    return 0; // 0 return values
}
static int func_monster_hear_sound(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to hear_sound, expected only 4, got %d", lua_gettop(L));
    }
    instance.hear_sound(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_monster_hasten_upgrade(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hasten_upgrade, expected only 1, got %d", lua_gettop(L));
    }
    instance.hasten_upgrade();
    return 0; // 0 return values
}
static int func_monster_drop_items_on_death(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to drop_items_on_death, expected only 1, got %d", lua_gettop(L));
    }
    instance.drop_items_on_death();
    return 0; // 0 return values
}
static int func_monster_scent_move(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to scent_move, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, instance.scent_move());
    return 1; // 1 return values
}
static int func_monster_can_move_to(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to can_move_to, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_move_to(parameter1));
    return 1; // 1 return values
}
static int func_monster_push_to(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to push_to, expected only 4, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.push_to(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int func_monster_process_triggers(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_triggers, expected only 1, got %d", lua_gettop(L));
    }
    instance.process_triggers();
    return 0; // 0 return values
}
static int func_monster_bash_skill(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bash_skill, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.bash_skill());
    return 1; // 1 return values
}
static int func_monster_add_item(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to add_item, expected only 2, got %d", lua_gettop(L));
    }
    instance.add_item(parameter1);
    return 0; // 0 return values
}
static int func_monster_footsteps(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to footsteps, expected only 2, got %d", lua_gettop(L));
    }
    instance.footsteps(parameter1);
    return 0; // 0 return values
}
static int func_monster_reset_special(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to reset_special, expected only 2, got %d", lua_gettop(L));
    }
    instance.reset_special(parameter1);
    return 0; // 0 return values
}
static int func_monster_can_upgrade(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_upgrade, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_upgrade());
    return 1; // 1 return values
}
static int func_monster_poly(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<mtype_id>::check(L, 2);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to poly, expected only 2, got %d", lua_gettop(L));
    }
    instance.poly(parameter1);
    return 0; // 0 return values
}
static int func_monster_calc_movecost(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to calc_movecost, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.calc_movecost(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_can_see(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_see, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_see());
    return 1; // 1 return values
}
static int func_monster_move_to(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(LuaType<bool>::has(L, 3)) {
        auto && parameter2 = LuaType<bool>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to move_to, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.move_to(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to move_to, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.move_to(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to move_to, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.move_to(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
}
static int func_monster_on_load(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to on_load, expected only 1, got %d", lua_gettop(L));
    }
    instance.on_load();
    return 0; // 0 return values
}
static int func_monster_name_with_armor(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to name_with_armor, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.name_with_armor());
    return 1; // 1 return values
}
static int func_monster_attack_at(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to attack_at, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.attack_at(parameter1));
    return 1; // 1 return values
}
static int func_monster_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_monster_on_unload(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to on_unload, expected only 1, got %d", lua_gettop(L));
    }
    instance.on_unload();
    return 0; // 0 return values
}
static int func_monster_move(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to move, expected only 1, got %d", lua_gettop(L));
    }
    instance.move();
    return 0; // 0 return values
}
static int func_monster_make_fungus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to make_fungus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.make_fungus());
    return 1; // 1 return values
}
static int func_monster_can_submerge(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to can_submerge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.can_submerge());
    return 1; // 1 return values
}
static int func_monster_init_from_item(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValueOrReference<item>::check(L, 2);
    auto && parameter1 = LuaValueOrReference<item>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to init_from_item, expected only 2, got %d", lua_gettop(L));
    }
    instance.init_from_item(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_dest(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dest, expected only 2, got %d", lua_gettop(L));
    }
    instance.set_dest(parameter1);
    return 0; // 0 return values
}
static int func_monster_spawn(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to spawn, expected only 2, got %d", lua_gettop(L));
    }
    instance.spawn(parameter1);
    return 0; // 0 return values
}
static int func_monster_is_dead_state(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_dead_state());
    return 1; // 1 return values
}
static int func_monster_basic_symbol_color(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to basic_symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).basic_symbol_color());
    return 1; // 1 return values
}
static int func_monster_is_fake(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_fake, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_fake());
    return 1; // 1 return values
}
static int func_monster_melee_attack(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(LuaValue<matec_id>::has(L, 4)) {
        auto && parameter3 = LuaValue<matec_id>::get(L, 4);
        if(lua_gettop(L) > 4) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 4, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2, parameter3);
        return 0; // 0 return values
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to melee_attack, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).melee_attack(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are matec_id or nothing at all");
}
static int func_monster_get_killer(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_killer, expected only 1, got %d", lua_gettop(L));
    }
    LuaReference<Creature>::push(L, static_cast<Creature&>(instance).get_killer());
    return 1; // 1 return values
}
static int func_monster_get_armor_bash(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash(parameter1));
    return 1; // 1 return values
}
static int func_monster_posx(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posx, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posx());
    return 1; // 1 return values
}
static int func_monster_hp_percentage(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hp_percentage, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).hp_percentage());
    return 1; // 1 return values
}
static int func_monster_gibType(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gibType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).gibType());
    return 1; // 1 return values
}
static int func_monster_mod_moves(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_moves(parameter1);
    return 0; // 0 return values
}
static int func_monster_bloodType(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bloodType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, static_cast<Creature&>(instance).bloodType());
    return 1; // 1 return values
}
static int func_monster_digging(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to digging, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).digging());
    return 1; // 1 return values
}
static int func_monster_pos(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to pos, expected only 1, got %d", lua_gettop(L));
    }
    LuaValue<tripoint>::push(L, static_cast<Creature&>(instance).pos());
    return 1; // 1 return values
}
static int func_monster_has_trait(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_trait, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_trait(parameter1));
    return 1; // 1 return values
}
static int func_monster_get_perceived_pain(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_perceived_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_perceived_pain());
    return 1; // 1 return values
}
static int func_monster_is_monster(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_monster, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_monster());
    return 1; // 1 return values
}
static int func_monster_get_hp(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_monster_set_armor_cut_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_env_resist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_env_resist, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_env_resist(parameter1));
    return 1; // 1 return values
}
static int func_monster_set_fake(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_fake, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_fake(parameter1);
    return 0; // 0 return values
}
static int func_monster_mod_pain(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain(parameter1);
    return 0; // 0 return values
}
static int func_monster_is_hallucination(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_hallucination, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_hallucination());
    return 1; // 1 return values
}
static int func_monster_get_throw_resist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_throw_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_throw_resist());
    return 1; // 1 return values
}
static int func_monster_get_value(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_value, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_value(parameter1));
    return 1; // 1 return values
}
static int func_monster_set_throw_resist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_throw_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_throw_resist(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_armor_cut_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_bonus());
    return 1; // 1 return values
}
static int func_monster_skin_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to skin_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).skin_name());
    return 1; // 1 return values
}
static int func_monster_get_hp_max(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaEnum<hp_part>::has(L, 2)) {
        auto && parameter1 = LuaEnum<hp_part>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_hp_max, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_hp_max());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are hp_part or nothing at all");
}
static int func_monster_set_cut_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_on_hit(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(LuaType<float>::has(L, 4)) {
            auto && parameter3 = LuaType<float>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to on_hit, expected only 3, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).on_hit(parameter1, parameter2);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are float or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to on_hit, expected only 2, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).on_hit(parameter1);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_mod_stat(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to mod_stat, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_stat(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_setpos(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to setpos, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).setpos(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_speed_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_bonus());
    return 1; // 1 return values
}
static int func_monster_get_size(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_size, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<m_size>::push(L, static_cast<Creature&>(instance).get_size());
    return 1; // 1 return values
}
static int func_monster_is_warm(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_warm, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_warm());
    return 1; // 1 return values
}
static int func_monster_process_turn(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_turn, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_turn();
    return 0; // 0 return values
}
static int func_monster_disp_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to disp_name, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, static_cast<Creature&>(instance).disp_name());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_monster_get_cut_mult(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_cut_mult());
    return 1; // 1 return values
}
static int func_monster_power_rating(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to power_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).power_rating());
    return 1; // 1 return values
}
static int func_monster_get_name(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_name, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).get_name());
    return 1; // 1 return values
}
static int func_monster_add_effect(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(LuaEnum<body_part>::has(L, 4)) {
        auto && parameter3 = LuaEnum<body_part>::get(L, 4);
        if(LuaType<bool>::has(L, 5)) {
            auto && parameter4 = LuaType<bool>::get(L, 5);
            if(LuaType<int>::has(L, 6)) {
                auto && parameter5 = LuaType<int>::get(L, 6);
                if(LuaType<bool>::has(L, 7)) {
                    auto && parameter6 = LuaType<bool>::get(L, 7);
                    if(lua_gettop(L) > 7) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 7, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
                    return 0; // 0 return values
                }
                if(lua_gettop(L) == 6) {
                    if(lua_gettop(L) > 6) {
                        return luaL_error(L, "Too many arguments to add_effect, expected only 6, got %d", lua_gettop(L));
                    }
                    static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4, parameter5);
                    return 0; // 0 return values
                }
                return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 5) {
                if(lua_gettop(L) > 5) {
                    return luaL_error(L, "Too many arguments to add_effect, expected only 5, got %d", lua_gettop(L));
                }
                static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3, parameter4);
                return 0; // 0 return values
            }
            return luaL_argerror(L, 5, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 4) {
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to add_effect, expected only 4, got %d", lua_gettop(L));
            }
            static_cast<Creature&>(instance).add_effect(parameter1, parameter2, parameter3);
            return 0; // 0 return values
        }
        return luaL_argerror(L, 4, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 3) {
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to add_effect, expected only 3, got %d", lua_gettop(L));
        }
        static_cast<Creature&>(instance).add_effect(parameter1, parameter2);
        return 0; // 0 return values
    }
    return luaL_argerror(L, 3, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_get_grab_resist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_grab_resist, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_grab_resist());
    return 1; // 1 return values
}
static int func_monster_get_effect_int(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_int, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_int(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_get_hit_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_bonus());
    return 1; // 1 return values
}
static int func_monster_is_immune_effect(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to is_immune_effect, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_immune_effect(parameter1));
    return 1; // 1 return values
}
static int func_monster_set_cut_mult(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_cut_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_cut_mult(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_num_dodges(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges());
    return 1; // 1 return values
}
static int func_monster_is_npc(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_npc, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_npc());
    return 1; // 1 return values
}
static int func_monster_set_bash_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_reset_bonuses(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_bonuses, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_bonuses();
    return 0; // 0 return values
}
static int func_monster_get_dodge_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_bonus());
    return 1; // 1 return values
}
static int func_monster_set_speed_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_hit_roll(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to hit_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).hit_roll());
    return 1; // 1 return values
}
static int func_monster_get_num_blocks(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks());
    return 1; // 1 return values
}
static int func_monster_on_dodge(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<float>::check(L, 3);
    auto && parameter2 = LuaType<float>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to on_dodge, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).on_dodge(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_get_bash_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_bash_bonus());
    return 1; // 1 return values
}
static int func_monster_process_effects(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to process_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).process_effects();
    return 0; // 0 return values
}
static int func_monster_set_dodge_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_num_dodges_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_dodges_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_dodges_bonus());
    return 1; // 1 return values
}
static int func_monster_get_dodge(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge());
    return 1; // 1 return values
}
static int func_monster_get_dodge_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_dodge_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_dodge_base());
    return 1; // 1 return values
}
static int func_monster_normalize(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to normalize, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).normalize();
    return 0; // 0 return values
}
static int func_monster_mod_bash_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_num_dodges_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_dodges_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_dodges_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_mod_hit_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_sight_range(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to sight_range, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).sight_range(parameter1));
    return 1; // 1 return values
}
static int func_monster_reset(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset();
    return 0; // 0 return values
}
static int func_monster_speed_rating(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to speed_rating, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).speed_rating());
    return 1; // 1 return values
}
static int func_monster_get_num_blocks_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_num_blocks_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_num_blocks_bonus());
    return 1; // 1 return values
}
static int func_monster_get_armor_bash_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_bash_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_base(parameter1));
    return 1; // 1 return values
}
static int func_monster_has_weapon(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_weapon, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_weapon());
    return 1; // 1 return values
}
static int func_monster_posz(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posz, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posz());
    return 1; // 1 return values
}
static int func_monster_get_armor_cut(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut(parameter1));
    return 1; // 1 return values
}
static int func_monster_reset_stats(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to reset_stats, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).reset_stats();
    return 0; // 0 return values
}
static int func_monster_set_num_blocks_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_num_blocks_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_num_blocks_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_mod_cut_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_cut_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_cut_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_has_grab_break_tec(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to has_grab_break_tec, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).has_grab_break_tec());
    return 1; // 1 return values
}
static int func_monster_mod_dodge_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_dodge_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_dodge_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_is_symbol_highlighted(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_symbol_highlighted, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_symbol_highlighted());
    return 1; // 1 return values
}
static int func_monster_move_effects(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to move_effects, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).move_effects(parameter1));
    return 1; // 1 return values
}
static int func_monster_get_hit_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit_base());
    return 1; // 1 return values
}
static int func_monster_mod_speed_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_speed_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_speed_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_cut_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_cut_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_cut_bonus());
    return 1; // 1 return values
}
static int func_monster_in_sleep_state(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to in_sleep_state, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).in_sleep_state());
    return 1; // 1 return values
}
static int func_monster_set_value(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter2 = LuaType<std::string>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_value, expected only 3, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_value(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_monster_remove_effect(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to remove_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).remove_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_sees(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaReference<Creature>::has(L, 2)) {
        auto && parameter1 = LuaReference<Creature>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaValue<point>::has(L, 2)) {
        auto && parameter1 = LuaValue<point>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
        return 1; // 1 return values
    }
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        LuaType<int>::check(L, 3);
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(LuaValue<tripoint>::has(L, 2)) {
        auto && parameter1 = LuaValue<tripoint>::get(L, 2);
        if(LuaType<bool>::has(L, 3)) {
            auto && parameter2 = LuaType<bool>::get(L, 3);
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to sees, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1, parameter2));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 2) {
            if(lua_gettop(L) > 2) {
                return luaL_error(L, "Too many arguments to sees, expected only 2, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).sees(parameter1));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 2, "Unexpected type, expected are bool or nothing at all");
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are Creature or point or int or tripoint");
}
static int func_monster_get_weight(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_weight, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_weight());
    return 1; // 1 return values
}
static int func_monster_symbol_color(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol_color, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).symbol_color());
    return 1; // 1 return values
}
static int func_monster_weight_capacity(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to weight_capacity, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).weight_capacity());
    return 1; // 1 return values
}
static int func_monster_uncanny_dodge(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to uncanny_dodge, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).uncanny_dodge());
    return 1; // 1 return values
}
static int func_monster_set_block_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_speed_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_speed_base, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_speed_base(parameter1);
    return 0; // 0 return values
}
static int func_monster_die(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to die, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).die(parameter1);
    return 0; // 0 return values
}
static int func_monster_mod_block_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_block_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_block_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_symbol(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to symbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, static_cast<Creature&>(instance).symbol());
    return 1; // 1 return values
}
static int func_monster_knock_back_from(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to knock_back_from, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).knock_back_from(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_bash_mult(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_bash_mult, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_bash_mult(parameter1);
    return 0; // 0 return values
}
static int func_monster_deal_melee_attack(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter2 = LuaType<int>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to deal_melee_attack, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).deal_melee_attack(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_avoid_trap(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter1 = LuaValue<tripoint>::get(L, 2);
    LuaReference<trap>::check(L, 3);
    auto && parameter2 = LuaReference<trap>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to avoid_trap, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).avoid_trap(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_clear_effects(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to clear_effects, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).clear_effects();
    return 0; // 0 return values
}
static int func_monster_get_bash_mult(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_bash_mult, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_bash_mult());
    return 1; // 1 return values
}
static int func_monster_get_speed(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed());
    return 1; // 1 return values
}
static int func_monster_get_block_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_block_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_block_bonus());
    return 1; // 1 return values
}
static int func_monster_get_speed_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_speed_base, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_speed_base());
    return 1; // 1 return values
}
static int func_monster_has_effect(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to has_effect, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).has_effect(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_mod_pain_noresist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to mod_pain_noresist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).mod_pain_noresist(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_armor_bash_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_armor_bash_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_armor_bash_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_moves(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_moves, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_moves(parameter1);
    return 0; // 0 return values
}
static int func_monster_add_env_effect(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    LuaType<int>::check(L, 5);
    auto && parameter4 = LuaType<int>::get(L, 5);
    if(LuaEnum<body_part>::has(L, 6)) {
        auto && parameter5 = LuaEnum<body_part>::get(L, 6);
        if(LuaType<bool>::has(L, 7)) {
            auto && parameter6 = LuaType<bool>::get(L, 7);
            if(LuaType<int>::has(L, 8)) {
                auto && parameter7 = LuaType<int>::get(L, 8);
                if(LuaType<bool>::has(L, 9)) {
                    auto && parameter8 = LuaType<bool>::get(L, 9);
                    if(lua_gettop(L) > 9) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 9, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8));
                    return 1; // 1 return values
                }
                if(lua_gettop(L) == 8) {
                    if(lua_gettop(L) > 8) {
                        return luaL_error(L, "Too many arguments to add_env_effect, expected only 8, got %d", lua_gettop(L));
                    }
                    LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7));
                    return 1; // 1 return values
                }
                return luaL_argerror(L, 8, "Unexpected type, expected are bool or nothing at all");
            }
            if(lua_gettop(L) == 7) {
                if(lua_gettop(L) > 7) {
                    return luaL_error(L, "Too many arguments to add_env_effect, expected only 7, got %d", lua_gettop(L));
                }
                LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6));
                return 1; // 1 return values
            }
            return luaL_argerror(L, 7, "Unexpected type, expected are int or nothing at all");
        }
        if(lua_gettop(L) == 6) {
            if(lua_gettop(L) > 6) {
                return luaL_error(L, "Too many arguments to add_env_effect, expected only 6, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4, parameter5));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 6, "Unexpected type, expected are bool or nothing at all");
    }
    if(lua_gettop(L) == 5) {
        if(lua_gettop(L) > 5) {
            return luaL_error(L, "Too many arguments to add_env_effect, expected only 5, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, static_cast<Creature&>(instance).add_env_effect(parameter1, parameter2, parameter3, parameter4));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 5, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_check_dead_state(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to check_dead_state, expected only 1, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).check_dead_state();
    return 0; // 0 return values
}
static int func_monster_set_melee_quiet(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<bool>::check(L, 2);
    auto && parameter1 = LuaType<bool>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_melee_quiet, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_melee_quiet(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_hit_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<float>::check(L, 2);
    auto && parameter1 = LuaType<float>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_hit_bonus, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_hit_bonus(parameter1);
    return 0; // 0 return values
}
static int func_monster_set_grab_resist(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_grab_resist, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_grab_resist(parameter1);
    return 0; // 0 return values
}
static int func_monster_fall_damage_mod(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fall_damage_mod, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).fall_damage_mod());
    return 1; // 1 return values
}
static int func_monster_get_random_body_part(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(LuaType<bool>::has(L, 2)) {
        auto && parameter1 = LuaType<bool>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 2, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to get_random_body_part, expected only 1, got %d", lua_gettop(L));
        }
        LuaEnum<body_part>::push(L, static_cast<Creature&>(instance).get_random_body_part());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are bool or nothing at all");
}
static int func_monster_get_melee(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_melee());
    return 1; // 1 return values
}
static int func_monster_is_elec_immune(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_elec_immune, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_elec_immune());
    return 1; // 1 return values
}
static int func_monster_is_on_ground(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_on_ground, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_on_ground());
    return 1; // 1 return values
}
static int func_monster_get_armor_bash_bonus(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_armor_bash_bonus, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_bash_bonus());
    return 1; // 1 return values
}
static int func_monster_is_underwater(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_underwater, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_underwater());
    return 1; // 1 return values
}
static int func_monster_stability_roll(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to stability_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).stability_roll());
    return 1; // 1 return values
}
static int func_monster_is_player(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to is_player, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).is_player());
    return 1; // 1 return values
}
static int func_monster_get_effect_dur(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaValue<efftype_id>::check(L, 2);
    auto && parameter1 = LuaValue<efftype_id>::get(L, 2);
    if(LuaEnum<body_part>::has(L, 3)) {
        auto && parameter2 = LuaEnum<body_part>::get(L, 3);
        if(lua_gettop(L) > 3) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 3, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1, parameter2));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to get_effect_dur, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<int>::push(L, static_cast<Creature&>(instance).get_effect_dur(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are body_part or nothing at all");
}
static int func_monster_apply_damage(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaReference<Creature>::check(L, 2);
    auto && parameter1 = LuaReference<Creature>::get(L, 2);
    LuaEnum<body_part>::check(L, 3);
    auto && parameter2 = LuaEnum<body_part>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter3 = LuaType<int>::get(L, 4);
    if(lua_gettop(L) > 4) {
        return luaL_error(L, "Too many arguments to apply_damage, expected only 4, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).apply_damage(parameter1, parameter2, parameter3);
    return 0; // 0 return values
}
static int func_monster_impact(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    LuaValue<tripoint>::check(L, 3);
    auto && parameter2 = LuaValue<tripoint>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to impact, expected only 3, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).impact(parameter1, parameter2));
    return 1; // 1 return values
}
static int func_monster_get_melee_quiet(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_melee_quiet, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, static_cast<Creature&>(instance).get_melee_quiet());
    return 1; // 1 return values
}
static int func_monster_remove_value(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to remove_value, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).remove_value(parameter1);
    return 0; // 0 return values
}
static int func_monster_posy(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to posy, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).posy());
    return 1; // 1 return values
}
static int func_monster_get_pain(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_pain, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_pain());
    return 1; // 1 return values
}
static int func_monster_set_pain(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter1 = LuaType<int>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to set_pain, expected only 2, got %d", lua_gettop(L));
    }
    static_cast<Creature&>(instance).set_pain(parameter1);
    return 0; // 0 return values
}
static int func_monster_get_armor_cut_base(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    LuaEnum<body_part>::check(L, 2);
    auto && parameter1 = LuaEnum<body_part>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to get_armor_cut_base, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, static_cast<Creature&>(instance).get_armor_cut_base(parameter1));
    return 1; // 1 return values
}
static int func_monster_dodge_roll(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to dodge_roll, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).dodge_roll());
    return 1; // 1 return values
}
static int func_monster_get_hit(lua_State *L) {
    monster& instance = LuaReference<monster>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_hit, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<float>::push(L, static_cast<Creature&>(instance).get_hit());
    return 1; // 1 return values
}
static int new_encumbrance_data(lua_State *L) {
    LuaValue<encumbrance_data>::check(L, 2);
    auto && parameter1 = LuaValue<encumbrance_data>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to encumbrance_data::encumbrance_data, expected only 2, got %d", lua_gettop(L));
    }
    LuaValue<encumbrance_data>::push(L, parameter1);
    return 1; // 1 return values
}
static int func_mtype_nname(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    if(LuaType<int>::has(L, 2)) {
        auto && parameter1 = LuaType<int>::get(L, 2);
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to nname, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.nname(parameter1));
        return 1; // 1 return values
    }
    if(lua_gettop(L) == 1) {
        if(lua_gettop(L) > 1) {
            return luaL_error(L, "Too many arguments to nname, expected only 1, got %d", lua_gettop(L));
        }
        LuaType<std::string>::push(L, instance.nname());
        return 1; // 1 return values
    }
    return luaL_argerror(L, 1, "Unexpected type, expected are int or nothing at all");
}
static int func_mtype_same_species(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaReference<mtype>::check(L, 2);
    auto && parameter1 = LuaReference<mtype>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to same_species, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.same_species(parameter1));
    return 1; // 1 return values
}
static int func_mtype_get_meat_itype(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to get_meat_itype, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<std::string>::push(L, instance.get_meat_itype());
    return 1; // 1 return values
}
static int func_mtype_gibType(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to gibType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.gibType());
    return 1; // 1 return values
}
static int func_mtype_made_of(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<material_id>::check(L, 2);
    auto && parameter1 = LuaValue<material_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to made_of, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.made_of(parameter1));
    return 1; // 1 return values
}
static int func_mtype_bloodType(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to bloodType, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.bloodType());
    return 1; // 1 return values
}
static int func_mtype_set_flag(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    LuaType<bool>::check(L, 3);
    auto && parameter2 = LuaType<bool>::get(L, 3);
    if(lua_gettop(L) > 3) {
        return luaL_error(L, "Too many arguments to set_flag, expected only 3, got %d", lua_gettop(L));
    }
    instance.set_flag(parameter1, parameter2);
    return 0; // 0 return values
}
static int func_mtype_in_species(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaValue<species_id>::check(L, 2);
    auto && parameter1 = LuaValue<species_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to in_species, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.in_species(parameter1));
    return 1; // 1 return values
}
static int func_mtype_in_category(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to in_category, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.in_category(parameter1));
    return 1; // 1 return values
}
static int func_mtype_has_special_attack(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_special_attack, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_special_attack(parameter1));
    return 1; // 1 return values
}
static int func_mtype_has_flag(lua_State *L) {
    mtype& instance = LuaReference<mtype>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter1 = LuaType<std::string>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to has_flag, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.has_flag(parameter1));
    return 1; // 1 return values
}
static int func_field_fieldCount(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fieldCount, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.fieldCount());
    return 1; // 1 return values
}
static int func_field_fieldSymbol(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to fieldSymbol, expected only 1, got %d", lua_gettop(L));
    }
    LuaEnum<field_id>::push(L, instance.fieldSymbol());
    return 1; // 1 return values
}
static int func_field_addField(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    LuaEnum<field_id>::check(L, 2);
    auto && parameter1 = LuaEnum<field_id>::get(L, 2);
    if(LuaType<int>::has(L, 3)) {
        auto && parameter2 = LuaType<int>::get(L, 3);
        if(LuaType<int>::has(L, 4)) {
            auto && parameter3 = LuaType<int>::get(L, 4);
            if(lua_gettop(L) > 4) {
                return luaL_error(L, "Too many arguments to addField, expected only 4, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.addField(parameter1, parameter2, parameter3));
            return 1; // 1 return values
        }
        if(lua_gettop(L) == 3) {
            if(lua_gettop(L) > 3) {
                return luaL_error(L, "Too many arguments to addField, expected only 3, got %d", lua_gettop(L));
            }
            LuaType<bool>::push(L, instance.addField(parameter1, parameter2));
            return 1; // 1 return values
        }
        return luaL_argerror(L, 3, "Unexpected type, expected are int or nothing at all");
    }
    if(lua_gettop(L) == 2) {
        if(lua_gettop(L) > 2) {
            return luaL_error(L, "Too many arguments to addField, expected only 2, got %d", lua_gettop(L));
        }
        LuaType<bool>::push(L, instance.addField(parameter1));
        return 1; // 1 return values
    }
    return luaL_argerror(L, 2, "Unexpected type, expected are int or nothing at all");
}
static int func_field_removeField(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    LuaEnum<field_id>::check(L, 2);
    auto && parameter1 = LuaEnum<field_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to removeField, expected only 2, got %d", lua_gettop(L));
    }
    LuaType<bool>::push(L, instance.removeField(parameter1));
    return 1; // 1 return values
}
static int func_field_move_cost(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    if(lua_gettop(L) > 1) {
        return luaL_error(L, "Too many arguments to move_cost, expected only 1, got %d", lua_gettop(L));
    }
    LuaType<int>::push(L, instance.move_cost());
    return 1; // 1 return values
}
static int func_field_findField(lua_State *L) {
    field& instance = LuaReference<field>::get(L, 1);
    LuaEnum<field_id>::check(L, 2);
    auto && parameter1 = LuaEnum<field_id>::get(L, 2);
    if(lua_gettop(L) > 2) {
        return luaL_error(L, "Too many arguments to findField, expected only 2, got %d", lua_gettop(L));
    }
    LuaReference<field_entry>::push(L, instance.findField(parameter1));
    return 1; // 1 return values
}
static int global_create_monster(lua_State *L) {
    LuaValue<mtype_id>::check(L, 1);
    auto && parameter1 = LuaValue<mtype_id>::get(L, 1);
    LuaValue<tripoint>::check(L, 2);
    auto && parameter2 = LuaValue<tripoint>::get(L, 2);
    LuaReference<monster>::push(L, create_monster(parameter1, parameter2));
    return 1; // 1 return values
}
static int global_rng(lua_State *L) {
    LuaType<int>::check(L, 1);
    auto && parameter1 = LuaType<int>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter2 = LuaType<int>::get(L, 2);
    LuaType<int>::push(L, rng(parameter1, parameter2));
    return 1; // 1 return values
}
static int global_distance(lua_State *L) {
    LuaType<int>::check(L, 1);
    auto && parameter1 = LuaType<int>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter2 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter3 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter4 = LuaType<int>::get(L, 4);
    LuaType<int>::push(L, rl_dist(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int global_trig_dist(lua_State *L) {
    LuaType<int>::check(L, 1);
    auto && parameter1 = LuaType<int>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter2 = LuaType<int>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter3 = LuaType<int>::get(L, 3);
    LuaType<int>::check(L, 4);
    auto && parameter4 = LuaType<int>::get(L, 4);
    LuaType<int>::push(L, trig_dist(parameter1, parameter2, parameter3, parameter4));
    return 1; // 1 return values
}
static int global_get_terrain_type(lua_State *L) {
    LuaType<int>::check(L, 1);
    auto && parameter1 = LuaType<int>::get(L, 1);
    LuaReference<ter_t>::push(L, get_terrain_type(parameter1));
    return 1; // 1 return values
}
static int global_popup(lua_State *L) {
    LuaType<std::string>::check(L, 1);
    auto && parameter1 = LuaType<std::string>::get(L, 1);
    popup_wrapper(parameter1);
    return 0; // 0 return values
}
static int global_string_input_popup(lua_State *L) {
    LuaType<std::string>::check(L, 1);
    auto && parameter1 = LuaType<std::string>::get(L, 1);
    LuaType<int>::check(L, 2);
    auto && parameter2 = LuaType<int>::get(L, 2);
    LuaType<std::string>::check(L, 3);
    auto && parameter3 = LuaType<std::string>::get(L, 3);
    LuaType<std::string>::push(L, string_input_popup(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int global_create_uimenu(lua_State *L) {
    LuaReference<uimenu>::push(L, create_uimenu());
    return 1; // 1 return values
}
static int global_add_msg(lua_State *L) {
    LuaType<std::string>::check(L, 1);
    auto && parameter1 = LuaType<std::string>::get(L, 1);
    add_msg_wrapper(parameter1);
    return 0; // 0 return values
}
static int global_add_item_to_group(lua_State *L) {
    LuaType<std::string>::check(L, 1);
    auto && parameter1 = LuaType<std::string>::get(L, 1);
    LuaType<std::string>::check(L, 2);
    auto && parameter2 = LuaType<std::string>::get(L, 2);
    LuaType<int>::check(L, 3);
    auto && parameter3 = LuaType<int>::get(L, 3);
    LuaType<bool>::push(L, item_controller->add_item_to_group(parameter1, parameter2, parameter3));
    return 1; // 1 return values
}
static int global_one_in(lua_State *L) {
    LuaType<int>::check(L, 1);
    auto && parameter1 = LuaType<int>::get(L, 1);
    LuaType<bool>::push(L, one_in(parameter1));
    return 1; // 1 return values
}
static int global_get_calendar_turn(lua_State *L) {
    LuaReference<calendar>::push(L, get_calendar_turn_wrapper());
    return 1; // 1 return values
}
template<>
const char * const LuaValue<stats*>::METATABLE_NAME = "stats_metatable";
template<>
LuaValue<stats*>::Type *LuaValue<stats*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<stats*>::FUNCTIONS[] = {
    {"reset", func_stats_reset},
    {NULL, NULL}
};
template<>
const LuaValue<stats*>::MRMap LuaValue<stats*>::READ_MEMBERS{
    {"damage_taken", get_stats_damage_taken},
    {"headshots", get_stats_headshots},
    {"damage_healed", get_stats_damage_healed},
    {"squares_walked", get_stats_squares_walked},
};
template<>
const LuaValue<stats*>::MWMap LuaValue<stats*>::WRITE_MEMBERS{
    {"damage_taken", set_stats_damage_taken},
    {"headshots", set_stats_headshots},
    {"damage_healed", set_stats_damage_healed},
    {"squares_walked", set_stats_squares_walked},
};
template<>
const char * const LuaValue<MonsterGroup*>::METATABLE_NAME = "MonsterGroup_metatable";
template<>
LuaValue<MonsterGroup*>::Type *LuaValue<MonsterGroup*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<MonsterGroup*>::FUNCTIONS[] = {
    {"IsMonsterInGroup", func_MonsterGroup_IsMonsterInGroup},
    {NULL, NULL}
};
template<>
const LuaValue<MonsterGroup*>::MRMap LuaValue<MonsterGroup*>::READ_MEMBERS{
    {"new_monster_group", get_MonsterGroup_new_monster_group},
    {"name", get_MonsterGroup_name},
    {"replace_monster_group", get_MonsterGroup_replace_monster_group},
    {"monster_group_time", get_MonsterGroup_monster_group_time},
    {"defaultMonster", get_MonsterGroup_defaultMonster},
    {"is_safe", get_MonsterGroup_is_safe},
};
template<>
const LuaValue<MonsterGroup*>::MWMap LuaValue<MonsterGroup*>::WRITE_MEMBERS{
    {"new_monster_group", set_MonsterGroup_new_monster_group},
    {"name", set_MonsterGroup_name},
    {"replace_monster_group", set_MonsterGroup_replace_monster_group},
    {"monster_group_time", set_MonsterGroup_monster_group_time},
    {"defaultMonster", set_MonsterGroup_defaultMonster},
    {"is_safe", set_MonsterGroup_is_safe},
};
template<>
const char * const LuaValue<ammotype>::METATABLE_NAME = "ammotype_metatable";
template<>
LuaValue<ammotype>::Type *LuaValue<ammotype>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ammotype>::FUNCTIONS[] = {
    {"str", func_ammotype_str},
    {"is_valid", func_ammotype_is_valid},
    {"obj", func_ammotype_obj},
    {"__call", new_ammotype},
    {"__eq", op_ammotype_eq},
    {NULL, NULL}
};
template<>
const LuaValue<ammotype>::MRMap LuaValue<ammotype>::READ_MEMBERS{
};
template<>
const LuaValue<ammotype>::MWMap LuaValue<ammotype>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<item_location>::METATABLE_NAME = "item_location_metatable";
template<>
LuaValue<item_location>::Type *LuaValue<item_location>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<item_location>::FUNCTIONS[] = {
    {"obtain", func_item_location_obtain},
    {"describe", func_item_location_describe},
    {"obtain_cost", func_item_location_obtain_cost},
    {"remove_item", func_item_location_remove_item},
    {"get_item", func_item_location_get_item},
    {NULL, NULL}
};
template<>
const LuaValue<item_location>::MRMap LuaValue<item_location>::READ_MEMBERS{
};
template<>
const LuaValue<item_location>::MWMap LuaValue<item_location>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<skill_id>::METATABLE_NAME = "skill_id_metatable";
template<>
LuaValue<skill_id>::Type *LuaValue<skill_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<skill_id>::FUNCTIONS[] = {
    {"str", func_skill_id_str},
    {"is_valid", func_skill_id_is_valid},
    {"obj", func_skill_id_obj},
    {"__call", new_skill_id},
    {"__eq", op_skill_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<skill_id>::MRMap LuaValue<skill_id>::READ_MEMBERS{
};
template<>
const LuaValue<skill_id>::MWMap LuaValue<skill_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<quality_id>::METATABLE_NAME = "quality_id_metatable";
template<>
LuaValue<quality_id>::Type *LuaValue<quality_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<quality_id>::FUNCTIONS[] = {
    {"str", func_quality_id_str},
    {"is_valid", func_quality_id_is_valid},
    {"obj", func_quality_id_obj},
    {"__call", new_quality_id},
    {"__eq", op_quality_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<quality_id>::MRMap LuaValue<quality_id>::READ_MEMBERS{
};
template<>
const LuaValue<quality_id>::MWMap LuaValue<quality_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<mtype_id>::METATABLE_NAME = "mtype_id_metatable";
template<>
LuaValue<mtype_id>::Type *LuaValue<mtype_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<mtype_id>::FUNCTIONS[] = {
    {"str", func_mtype_id_str},
    {"is_valid", func_mtype_id_is_valid},
    {"obj", func_mtype_id_obj},
    {"__call", new_mtype_id},
    {"__eq", op_mtype_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<mtype_id>::MRMap LuaValue<mtype_id>::READ_MEMBERS{
};
template<>
const LuaValue<mtype_id>::MWMap LuaValue<mtype_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<quality*>::METATABLE_NAME = "quality_metatable";
template<>
LuaValue<quality*>::Type *LuaValue<quality*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<quality*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<quality*>::MRMap LuaValue<quality*>::READ_MEMBERS{
    {"name", get_quality_name},
};
template<>
const LuaValue<quality*>::MWMap LuaValue<quality*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<map*>::METATABLE_NAME = "map_metatable";
template<>
LuaValue<map*>::Type *LuaValue<map*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<map*>::FUNCTIONS[] = {
    {"board_vehicle", func_map_board_vehicle},
    {"tername", func_map_tername},
    {"max_volume", func_map_max_volume},
    {"furn_set", func_map_furn_set},
    {"is_divable", func_map_is_divable},
    {"draw_fill_background", func_map_draw_fill_background},
    {"set_temperature", func_map_set_temperature},
    {"stored_volume", func_map_stored_volume},
    {"place_npc", func_map_place_npc},
    {"trigger_rc_items", func_map_trigger_rc_items},
    {"load", func_map_load},
    {"getmapsize", func_map_getmapsize},
    {"draw_rough_circle_ter", func_map_draw_rough_circle_ter},
    {"make_rubble", func_map_make_rubble},
    {"could_see_items", func_map_could_see_items},
    {"draw_circle_furn", func_map_draw_circle_furn},
    {"draw_square_furn", func_map_draw_square_furn},
    {"impassable", func_map_impassable},
    {"fungalize", func_map_fungalize},
    {"displace_vehicle", func_map_displace_vehicle},
    {"has_items", func_map_has_items},
    {"has_floor_or_support", func_map_has_floor_or_support},
    {"has_flag_ter", func_map_has_flag_ter},
    {"add_item_or_charges", func_map_add_item_or_charges},
    {"hit_with_fire", func_map_hit_with_fire},
    {"place_vending", func_map_place_vending},
    {"create_spores", func_map_create_spores},
    {"bash_strength", func_map_bash_strength},
    {"combined_movecost", func_map_combined_movecost},
    {"clear_traps", func_map_clear_traps},
    {"disarm_trap", func_map_disarm_trap},
    {"save", func_map_save},
    {"is_outside", func_map_is_outside},
    {"veh_part_coordinates", func_map_veh_part_coordinates},
    {"mop_spills", func_map_mop_spills},
    {"clear_path", func_map_clear_path},
    {"is_bashable", func_map_is_bashable},
    {"add_trap", func_map_add_trap},
    {"disp_name", func_map_disp_name},
    {"delete_graffiti", func_map_delete_graffiti},
    {"light_transparency", func_map_light_transparency},
    {"has_adjacent_furniture", func_map_has_adjacent_furniture},
    {"name", func_map_name},
    {"creature_on_trap", func_map_creature_on_trap},
    {"sees_some_items", func_map_sees_some_items},
    {"displace_water", func_map_displace_water},
    {"put_items_from_loc", func_map_put_items_from_loc},
    {"spawn_an_item", func_map_spawn_an_item},
    {"ter", func_map_ter},
    {"set_signage", func_map_set_signage},
    {"crush", func_map_crush},
    {"furn", func_map_furn},
    {"close_door", func_map_close_door},
    {"getlocal", func_map_getlocal},
    {"creature_in_field", func_map_creature_in_field},
    {"move_cost", func_map_move_cost},
    {"place_gas_pump", func_map_place_gas_pump},
    {"get_field_strength", func_map_get_field_strength},
    {"adjust_field_strength", func_map_adjust_field_strength},
    {"get_signage", func_map_get_signage},
    {"trans", func_map_trans},
    {"decay_fields_and_scent", func_map_decay_fields_and_scent},
    {"draw_rough_circle_furn", func_map_draw_rough_circle_furn},
    {"remove_trap", func_map_remove_trap},
    {"is_bashable_ter", func_map_is_bashable_ter},
    {"passable", func_map_passable},
    {"water_from", func_map_water_from},
    {"adjust_radiation", func_map_adjust_radiation},
    {"has_floor", func_map_has_floor},
    {"marlossify", func_map_marlossify},
    {"features", func_map_features},
    {"climb_difficulty", func_map_climb_difficulty},
    {"unboard_vehicle", func_map_unboard_vehicle},
    {"on_vehicle_moved", func_map_on_vehicle_moved},
    {"clear_spawns", func_map_clear_spawns},
    {"get_radiation", func_map_get_radiation},
    {"is_bashable_ter_furn", func_map_is_bashable_ter_furn},
    {"get_abs_sub", func_map_get_abs_sub},
    {"add_field", func_map_add_field},
    {"i_rem", func_map_i_rem},
    {"item_from", func_map_item_from},
    {"impassable_ter_furn", func_map_impassable_ter_furn},
    {"has_flag_furn", func_map_has_flag_furn},
    {"spawn_item", func_map_spawn_item},
    {"accessible_items", func_map_accessible_items},
    {"accessible_furniture", func_map_accessible_furniture},
    {"has_graffiti_at", func_map_has_graffiti_at},
    {"add_corpse", func_map_add_corpse},
    {"can_put_items", func_map_can_put_items},
    {"has_nearby_fire", func_map_has_nearby_fire},
    {"has_flag", func_map_has_flag},
    {"pl_sees", func_map_pl_sees},
    {"i_at", func_map_i_at},
    {"draw_circle_ter", func_map_draw_circle_ter},
    {"get_field_age", func_map_get_field_age},
    {"translate_radius", func_map_translate_radius},
    {"trap_set", func_map_trap_set},
    {"translate", func_map_translate},
    {"tr_at", func_map_tr_at},
    {"sees", func_map_sees},
    {"has_flag_ter_or_furn", func_map_has_flag_ter_or_furn},
    {"ter_set", func_map_ter_set},
    {"supports_above", func_map_supports_above},
    {"bash_resistance", func_map_bash_resistance},
    {"draw_line_ter", func_map_draw_line_ter},
    {"is_bashable_furn", func_map_is_bashable_furn},
    {"coord_to_angle", func_map_coord_to_angle},
    {"smash_items", func_map_smash_items},
    {"free_volume", func_map_free_volume},
    {"destroy_furn", func_map_destroy_furn},
    {"set_radiation", func_map_set_radiation},
    {"collapse_check", func_map_collapse_check},
    {"set_graffiti", func_map_set_graffiti},
    {"set_field_strength", func_map_set_field_strength},
    {"set_field_age", func_map_set_field_age},
    {"get_ter_transforms_into", func_map_get_ter_transforms_into},
    {"spawn_artifact", func_map_spawn_artifact},
    {"draw_square_ter", func_map_draw_square_ter},
    {"delete_signage", func_map_delete_signage},
    {"open_door", func_map_open_door},
    {"remove_field", func_map_remove_field},
    {"ambient_light_at", func_map_ambient_light_at},
    {"add_spawn", func_map_add_spawn},
    {"random_outdoor_tile", func_map_random_outdoor_tile},
    {"hit_with_acid", func_map_hit_with_acid},
    {"spawn_monsters", func_map_spawn_monsters},
    {"place_toilet", func_map_place_toilet},
    {"place_spawns", func_map_place_spawns},
    {"field_at", func_map_field_at},
    {"passable_ter_furn", func_map_passable_ter_furn},
    {"graffiti_at", func_map_graffiti_at},
    {"add_item", func_map_add_item},
    {"get_field", func_map_get_field},
    {"move_cost_ter_furn", func_map_move_cost_ter_furn},
    {"destroy", func_map_destroy},
    {"valid_move", func_map_valid_move},
    {"has_zlevels", func_map_has_zlevels},
    {"add_camp", func_map_add_camp},
    {"flammable_items_at", func_map_flammable_items_at},
    {"allow_camp", func_map_allow_camp},
    {"i_clear", func_map_i_clear},
    {"inbounds", func_map_inbounds},
    {"draw_line_furn", func_map_draw_line_furn},
    {"has_furn", func_map_has_furn},
    {"furnname", func_map_furnname},
    {"getabs", func_map_getabs},
    {"collapse_at", func_map_collapse_at},
    {"adjust_field_age", func_map_adjust_field_age},
    {"bash_rating", func_map_bash_rating},
    {"can_move_furniture", func_map_can_move_furniture},
    {NULL, NULL}
};
template<>
const LuaValue<map*>::MRMap LuaValue<map*>::READ_MEMBERS{
};
template<>
const LuaValue<map*>::MWMap LuaValue<map*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<trap_id>::METATABLE_NAME = "trap_id_metatable";
template<>
LuaValue<trap_id>::Type *LuaValue<trap_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<trap_id>::FUNCTIONS[] = {
    {"to_i", func_trap_id_to_i},
    {"obj", func_trap_id_obj},
    {"__call", new_trap_id},
    {"__eq", op_trap_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<trap_id>::MRMap LuaValue<trap_id>::READ_MEMBERS{
};
template<>
const LuaValue<trap_id>::MWMap LuaValue<trap_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<Creature*>::METATABLE_NAME = "Creature_metatable";
template<>
LuaValue<Creature*>::Type *LuaValue<Creature*>::get_subclass( lua_State* const S, int const i) {
    if(LuaReference<Character>::has(S, i)) {
        return &LuaReference<Character>::get( S, i );
    }
    if(LuaReference<monster>::has(S, i)) {
        return &LuaReference<monster>::get( S, i );
    }
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<Creature*>::FUNCTIONS[] = {
    {"is_dead_state", func_Creature_is_dead_state},
    {"basic_symbol_color", func_Creature_basic_symbol_color},
    {"is_fake", func_Creature_is_fake},
    {"melee_attack", func_Creature_melee_attack},
    {"get_killer", func_Creature_get_killer},
    {"get_armor_bash", func_Creature_get_armor_bash},
    {"posx", func_Creature_posx},
    {"hp_percentage", func_Creature_hp_percentage},
    {"gibType", func_Creature_gibType},
    {"mod_moves", func_Creature_mod_moves},
    {"bloodType", func_Creature_bloodType},
    {"digging", func_Creature_digging},
    {"pos", func_Creature_pos},
    {"has_trait", func_Creature_has_trait},
    {"get_perceived_pain", func_Creature_get_perceived_pain},
    {"is_monster", func_Creature_is_monster},
    {"get_hp", func_Creature_get_hp},
    {"set_armor_cut_bonus", func_Creature_set_armor_cut_bonus},
    {"get_env_resist", func_Creature_get_env_resist},
    {"set_fake", func_Creature_set_fake},
    {"mod_pain", func_Creature_mod_pain},
    {"is_hallucination", func_Creature_is_hallucination},
    {"get_throw_resist", func_Creature_get_throw_resist},
    {"get_value", func_Creature_get_value},
    {"set_throw_resist", func_Creature_set_throw_resist},
    {"get_armor_cut_bonus", func_Creature_get_armor_cut_bonus},
    {"skin_name", func_Creature_skin_name},
    {"get_hp_max", func_Creature_get_hp_max},
    {"set_cut_bonus", func_Creature_set_cut_bonus},
    {"on_hit", func_Creature_on_hit},
    {"mod_stat", func_Creature_mod_stat},
    {"setpos", func_Creature_setpos},
    {"get_speed_bonus", func_Creature_get_speed_bonus},
    {"get_size", func_Creature_get_size},
    {"is_warm", func_Creature_is_warm},
    {"process_turn", func_Creature_process_turn},
    {"disp_name", func_Creature_disp_name},
    {"get_cut_mult", func_Creature_get_cut_mult},
    {"power_rating", func_Creature_power_rating},
    {"get_name", func_Creature_get_name},
    {"add_effect", func_Creature_add_effect},
    {"get_grab_resist", func_Creature_get_grab_resist},
    {"get_effect_int", func_Creature_get_effect_int},
    {"get_hit_bonus", func_Creature_get_hit_bonus},
    {"is_immune_effect", func_Creature_is_immune_effect},
    {"set_cut_mult", func_Creature_set_cut_mult},
    {"get_num_dodges", func_Creature_get_num_dodges},
    {"is_npc", func_Creature_is_npc},
    {"set_bash_bonus", func_Creature_set_bash_bonus},
    {"reset_bonuses", func_Creature_reset_bonuses},
    {"get_dodge_bonus", func_Creature_get_dodge_bonus},
    {"set_speed_bonus", func_Creature_set_speed_bonus},
    {"hit_roll", func_Creature_hit_roll},
    {"get_num_blocks", func_Creature_get_num_blocks},
    {"on_dodge", func_Creature_on_dodge},
    {"get_bash_bonus", func_Creature_get_bash_bonus},
    {"process_effects", func_Creature_process_effects},
    {"set_dodge_bonus", func_Creature_set_dodge_bonus},
    {"get_num_dodges_bonus", func_Creature_get_num_dodges_bonus},
    {"get_dodge", func_Creature_get_dodge},
    {"get_dodge_base", func_Creature_get_dodge_base},
    {"normalize", func_Creature_normalize},
    {"mod_bash_bonus", func_Creature_mod_bash_bonus},
    {"set_num_dodges_bonus", func_Creature_set_num_dodges_bonus},
    {"mod_hit_bonus", func_Creature_mod_hit_bonus},
    {"sight_range", func_Creature_sight_range},
    {"reset", func_Creature_reset},
    {"speed_rating", func_Creature_speed_rating},
    {"get_num_blocks_bonus", func_Creature_get_num_blocks_bonus},
    {"get_armor_bash_base", func_Creature_get_armor_bash_base},
    {"has_weapon", func_Creature_has_weapon},
    {"posz", func_Creature_posz},
    {"get_armor_cut", func_Creature_get_armor_cut},
    {"reset_stats", func_Creature_reset_stats},
    {"set_num_blocks_bonus", func_Creature_set_num_blocks_bonus},
    {"mod_cut_bonus", func_Creature_mod_cut_bonus},
    {"has_grab_break_tec", func_Creature_has_grab_break_tec},
    {"mod_dodge_bonus", func_Creature_mod_dodge_bonus},
    {"is_symbol_highlighted", func_Creature_is_symbol_highlighted},
    {"move_effects", func_Creature_move_effects},
    {"get_hit_base", func_Creature_get_hit_base},
    {"mod_speed_bonus", func_Creature_mod_speed_bonus},
    {"get_cut_bonus", func_Creature_get_cut_bonus},
    {"in_sleep_state", func_Creature_in_sleep_state},
    {"set_value", func_Creature_set_value},
    {"remove_effect", func_Creature_remove_effect},
    {"sees", func_Creature_sees},
    {"get_weight", func_Creature_get_weight},
    {"symbol_color", func_Creature_symbol_color},
    {"weight_capacity", func_Creature_weight_capacity},
    {"uncanny_dodge", func_Creature_uncanny_dodge},
    {"set_block_bonus", func_Creature_set_block_bonus},
    {"set_speed_base", func_Creature_set_speed_base},
    {"die", func_Creature_die},
    {"mod_block_bonus", func_Creature_mod_block_bonus},
    {"symbol", func_Creature_symbol},
    {"knock_back_from", func_Creature_knock_back_from},
    {"set_bash_mult", func_Creature_set_bash_mult},
    {"deal_melee_attack", func_Creature_deal_melee_attack},
    {"avoid_trap", func_Creature_avoid_trap},
    {"clear_effects", func_Creature_clear_effects},
    {"get_bash_mult", func_Creature_get_bash_mult},
    {"get_speed", func_Creature_get_speed},
    {"get_block_bonus", func_Creature_get_block_bonus},
    {"get_speed_base", func_Creature_get_speed_base},
    {"has_effect", func_Creature_has_effect},
    {"mod_pain_noresist", func_Creature_mod_pain_noresist},
    {"set_armor_bash_bonus", func_Creature_set_armor_bash_bonus},
    {"set_moves", func_Creature_set_moves},
    {"add_env_effect", func_Creature_add_env_effect},
    {"check_dead_state", func_Creature_check_dead_state},
    {"set_melee_quiet", func_Creature_set_melee_quiet},
    {"set_hit_bonus", func_Creature_set_hit_bonus},
    {"set_grab_resist", func_Creature_set_grab_resist},
    {"fall_damage_mod", func_Creature_fall_damage_mod},
    {"get_random_body_part", func_Creature_get_random_body_part},
    {"get_melee", func_Creature_get_melee},
    {"is_elec_immune", func_Creature_is_elec_immune},
    {"is_on_ground", func_Creature_is_on_ground},
    {"get_armor_bash_bonus", func_Creature_get_armor_bash_bonus},
    {"is_underwater", func_Creature_is_underwater},
    {"stability_roll", func_Creature_stability_roll},
    {"is_player", func_Creature_is_player},
    {"get_effect_dur", func_Creature_get_effect_dur},
    {"apply_damage", func_Creature_apply_damage},
    {"impact", func_Creature_impact},
    {"get_melee_quiet", func_Creature_get_melee_quiet},
    {"remove_value", func_Creature_remove_value},
    {"posy", func_Creature_posy},
    {"get_pain", func_Creature_get_pain},
    {"set_pain", func_Creature_set_pain},
    {"get_armor_cut_base", func_Creature_get_armor_cut_base},
    {"dodge_roll", func_Creature_dodge_roll},
    {"get_hit", func_Creature_get_hit},
    {NULL, NULL}
};
template<>
const LuaValue<Creature*>::MRMap LuaValue<Creature*>::READ_MEMBERS{
};
template<>
const LuaValue<Creature*>::MWMap LuaValue<Creature*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<w_point*>::METATABLE_NAME = "w_point_metatable";
template<>
LuaValue<w_point*>::Type *LuaValue<w_point*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<w_point*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<w_point*>::MRMap LuaValue<w_point*>::READ_MEMBERS{
    {"temperature", get_w_point_temperature},
    {"humidity", get_w_point_humidity},
    {"pressure", get_w_point_pressure},
    {"windpower", get_w_point_windpower},
    {"acidic", get_w_point_acidic},
};
template<>
const LuaValue<w_point*>::MWMap LuaValue<w_point*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<Skill*>::METATABLE_NAME = "Skill_metatable";
template<>
LuaValue<Skill*>::Type *LuaValue<Skill*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<Skill*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<Skill*>::MRMap LuaValue<Skill*>::READ_MEMBERS{
};
template<>
const LuaValue<Skill*>::MWMap LuaValue<Skill*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<start_location_id>::METATABLE_NAME = "start_location_id_metatable";
template<>
LuaValue<start_location_id>::Type *LuaValue<start_location_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<start_location_id>::FUNCTIONS[] = {
    {"str", func_start_location_id_str},
    {"is_valid", func_start_location_id_is_valid},
    {"obj", func_start_location_id_obj},
    {"__call", new_start_location_id},
    {"__eq", op_start_location_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<start_location_id>::MRMap LuaValue<start_location_id>::READ_MEMBERS{
};
template<>
const LuaValue<start_location_id>::MWMap LuaValue<start_location_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<furn_str_id>::METATABLE_NAME = "furn_str_id_metatable";
template<>
LuaValue<furn_str_id>::Type *LuaValue<furn_str_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<furn_str_id>::FUNCTIONS[] = {
    {"str", func_furn_str_id_str},
    {"is_valid", func_furn_str_id_is_valid},
    {"id", func_furn_str_id_id},
    {"__call", new_furn_str_id},
    {"__eq", op_furn_str_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<furn_str_id>::MRMap LuaValue<furn_str_id>::READ_MEMBERS{
};
template<>
const LuaValue<furn_str_id>::MWMap LuaValue<furn_str_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<mabuff_id>::METATABLE_NAME = "mabuff_id_metatable";
template<>
LuaValue<mabuff_id>::Type *LuaValue<mabuff_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<mabuff_id>::FUNCTIONS[] = {
    {"str", func_mabuff_id_str},
    {"is_valid", func_mabuff_id_is_valid},
    {"obj", func_mabuff_id_obj},
    {"__call", new_mabuff_id},
    {"__eq", op_mabuff_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<mabuff_id>::MRMap LuaValue<mabuff_id>::READ_MEMBERS{
};
template<>
const LuaValue<mabuff_id>::MWMap LuaValue<mabuff_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<material_type*>::METATABLE_NAME = "material_type_metatable";
template<>
LuaValue<material_type*>::Type *LuaValue<material_type*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<material_type*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<material_type*>::MRMap LuaValue<material_type*>::READ_MEMBERS{
};
template<>
const LuaValue<material_type*>::MWMap LuaValue<material_type*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<player*>::METATABLE_NAME = "player_metatable";
template<>
LuaValue<player*>::Type *LuaValue<player*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<player*>::FUNCTIONS[] = {
    {"mabuff_dodge_bonus", func_player_mabuff_dodge_bonus},
    {"can_limb_block", func_player_can_limb_block},
    {"overmap_sight_range", func_player_overmap_sight_range},
    {"fall_asleep", func_player_fall_asleep},
    {"is_quiet", func_player_is_quiet},
    {"add_pain_msg", func_player_add_pain_msg},
    {"can_unwield", func_player_can_unwield},
    {"mutate", func_player_mutate},
    {"process_bionic", func_player_process_bionic},
    {"clear_destination", func_player_clear_destination},
    {"get_weapon_dispersion", func_player_get_weapon_dispersion},
    {"activate_bionic", func_player_activate_bionic},
    {"scored_crit", func_player_scored_crit},
    {"on_hurt", func_player_on_hurt},
    {"invalidate_crafting_inventory", func_player_invalidate_crafting_inventory},
    {"has_destination", func_player_has_destination},
    {"has_identified", func_player_has_identified},
    {"num_bionics", func_player_num_bionics},
    {"melee_value", func_player_melee_value},
    {"consume", func_player_consume},
    {"consume_effects", func_player_consume_effects},
    {"has_technique", func_player_has_technique},
    {"adjacent_tile", func_player_adjacent_tile},
    {"takeoff", func_player_takeoff},
    {"has_watch", func_player_has_watch},
    {"charges_of", func_player_charges_of},
    {"can_melee", func_player_can_melee},
    {"clairvoyance", func_player_clairvoyance},
    {"craft", func_player_craft},
    {"use_charges_if_avail", func_player_use_charges_if_avail},
    {"has_active_optcloak", func_player_has_active_optcloak},
    {"mutation_ok", func_player_mutation_ok},
    {"burn_move_stamina", func_player_burn_move_stamina},
    {"perform_special_attacks", func_player_perform_special_attacks},
    {"set_cat_level_rec", func_player_set_cat_level_rec},
    {"get_active_mission_target", func_player_get_active_mission_target},
    {"can_leg_block", func_player_can_leg_block},
    {"get_category_dream", func_player_get_category_dream},
    {"remove_mutation", func_player_remove_mutation},
    {"add_martialart", func_player_add_martialart},
    {"boost_skill_level", func_player_boost_skill_level},
    {"invlet_to_position", func_player_invlet_to_position},
    {"bonus_damage", func_player_bonus_damage},
    {"bodytemp_color", func_player_bodytemp_color},
    {"mabuff_tohit_bonus", func_player_mabuff_tohit_bonus},
    {"leak_level", func_player_leak_level},
    {"sleep_spot", func_player_sleep_spot},
    {"rem_morale", func_player_rem_morale},
    {"crit_chance", func_player_crit_chance},
    {"footwear_factor", func_player_footwear_factor},
    {"uninstall_bionic", func_player_uninstall_bionic},
    {"consume_item", func_player_consume_item},
    {"recalc_speed_bonus", func_player_recalc_speed_bonus},
    {"throw_range", func_player_throw_range},
    {"gunmod_remove", func_player_gunmod_remove},
    {"practice", func_player_practice},
    {"read_speed", func_player_read_speed},
    {"action_taken", func_player_action_taken},
    {"has_gun_for_ammo", func_player_has_gun_for_ammo},
    {"disp_morale", func_player_disp_morale},
    {"handle_melee_wear", func_player_handle_melee_wear},
    {"search_surroundings", func_player_search_surroundings},
    {"metabolic_rate_base", func_player_metabolic_rate_base},
    {"natural_attack_restricted_on", func_player_natural_attack_restricted_on},
    {"read", func_player_read},
    {"calc_focus_equilibrium", func_player_calc_focus_equilibrium},
    {"store", func_player_store},
    {"set_skill_level", func_player_set_skill_level},
    {"charge_power", func_player_charge_power},
    {"climbing_cost", func_player_climbing_cost},
    {"has_mission_item", func_player_has_mission_item},
    {"reach_attack", func_player_reach_attack},
    {"run_cost", func_player_run_cost},
    {"wear_item", func_player_wear_item},
    {"fine_detail_vision_mod", func_player_fine_detail_vision_mod},
    {"is_hibernating", func_player_is_hibernating},
    {"healall", func_player_healall},
    {"overmap_los", func_player_overmap_los},
    {"max_quality", func_player_max_quality},
    {"rust_rate", func_player_rust_rate},
    {"knows_trap", func_player_knows_trap},
    {"adjust_for_focus", func_player_adjust_for_focus},
    {"add_bionic", func_player_add_bionic},
    {"has_martialart", func_player_has_martialart},
    {"unarmed_attack", func_player_unarmed_attack},
    {"make_all_craft", func_player_make_all_craft},
    {"amount_worn", func_player_amount_worn},
    {"has_amount", func_player_has_amount},
    {"metabolic_rate", func_player_metabolic_rate},
    {"ma_ongethit_effects", func_player_ma_ongethit_effects},
    {"disp_info", func_player_disp_info},
    {"addiction_level", func_player_addiction_level},
    {"use", func_player_use},
    {"can_sleep", func_player_can_sleep},
    {"save_info", func_player_save_info},
    {"pick_style", func_player_pick_style},
    {"eat", func_player_eat},
    {"nutrition_for", func_player_nutrition_for},
    {"get_stamina_max", func_player_get_stamina_max},
    {"can_hear", func_player_can_hear},
    {"is_armed", func_player_is_armed},
    {"item_reload_cost", func_player_item_reload_cost},
    {"vomit_mod", func_player_vomit_mod},
    {"wield", func_player_wield},
    {"is_snuggling", func_player_is_snuggling},
    {"apply_wetness_morale", func_player_apply_wetness_morale},
    {"is_wearing_power_armor", func_player_is_wearing_power_armor},
    {"pick_technique", func_player_pick_technique},
    {"disassemble", func_player_disassemble},
    {"shout", func_player_shout},
    {"get_skill_level", func_player_get_skill_level},
    {"long_craft", func_player_long_craft},
    {"swim_speed", func_player_swim_speed},
    {"throw_dex_mod", func_player_throw_dex_mod},
    {"has_morale", func_player_has_morale},
    {"best_shield", func_player_best_shield},
    {"active_light", func_player_active_light},
    {"get_armor_fire", func_player_get_armor_fire},
    {"setx", func_player_setx},
    {"drink_from_hands", func_player_drink_from_hands},
    {"hurtall", func_player_hurtall},
    {"set_highest_cat_level", func_player_set_highest_cat_level},
    {"amount_of", func_player_amount_of},
    {"get_sick", func_player_get_sick},
    {"wear", func_player_wear},
    {"mutate_towards", func_player_mutate_towards},
    {"has_mabuff", func_player_has_mabuff},
    {"power_bionics", func_player_power_bionics},
    {"update_needs", func_player_update_needs},
    {"has_morale_to_read", func_player_has_morale_to_read},
    {"has_lower_trait", func_player_has_lower_trait},
    {"has_higher_trait", func_player_has_higher_trait},
    {"temp_equalizer", func_player_temp_equalizer},
    {"allergy_type", func_player_allergy_type},
    {"studied_all_recipes", func_player_studied_all_recipes},
    {"invoke_item", func_player_invoke_item},
    {"attack_speed", func_player_attack_speed},
    {"pick_usb", func_player_pick_usb},
    {"pause", func_player_pause},
    {"remove_child_flag", func_player_remove_child_flag},
    {"wearing_something_on", func_player_wearing_something_on},
    {"toggle_move_mode", func_player_toggle_move_mode},
    {"mabuff_speed_bonus", func_player_mabuff_speed_bonus},
    {"rooted", func_player_rooted},
    {"ma_onhit_effects", func_player_ma_onhit_effects},
    {"rem_addiction", func_player_rem_addiction},
    {"has_item_with_flag", func_player_has_item_with_flag},
    {"deactivate_bionic", func_player_deactivate_bionic},
    {"global_square_location", func_player_global_square_location},
    {"make_craft_with_command", func_player_make_craft_with_command},
    {"visibility", func_player_visibility},
    {"drench_mut_calc", func_player_drench_mut_calc},
    {"can_arm_block", func_player_can_arm_block},
    {"is_wearing_active_power_armor", func_player_is_wearing_active_power_armor},
    {"gun_value", func_player_gun_value},
    {"has_conflicting_trait", func_player_has_conflicting_trait},
    {"sees_with_infrared", func_player_sees_with_infrared},
    {"has_child_flag", func_player_has_child_flag},
    {"ma_onattack_effects", func_player_ma_onattack_effects},
    {"weapname", func_player_weapname},
    {"cough", func_player_cough},
    {"apply_persistent_morale", func_player_apply_persistent_morale},
    {"get_combat_style", func_player_get_combat_style},
    {"change_side", func_player_change_side},
    {"has_alarm_clock", func_player_has_alarm_clock},
    {"set_underwater", func_player_set_underwater},
    {"sort_armor", func_player_sort_armor},
    {"has_opposite_trait", func_player_has_opposite_trait},
    {"environmental_revert_effect", func_player_environmental_revert_effect},
    {"fire_gun", func_player_fire_gun},
    {"complete_disassemble", func_player_complete_disassemble},
    {"mabuff_block_bonus", func_player_mabuff_block_bonus},
    {"wield_contents", func_player_wield_contents},
    {"has_two_arms", func_player_has_two_arms},
    {"can_reload", func_player_can_reload},
    {"has_charges", func_player_has_charges},
    {"set_painkiller", func_player_set_painkiller},
    {"process_active_items", func_player_process_active_items},
    {"dump_memorial", func_player_dump_memorial},
    {"is_wearing_shoes", func_player_is_wearing_shoes},
    {"is_invisible", func_player_is_invisible},
    {"has_item", func_player_has_item},
    {"update_mental_focus", func_player_update_mental_focus},
    {"item_handling_cost", func_player_item_handling_cost},
    {"warmth", func_player_warmth},
    {"wake_up", func_player_wake_up},
    {"vomit", func_player_vomit},
    {"ma_onblock_effects", func_player_ma_onblock_effects},
    {"use_wielded", func_player_use_wielded},
    {"get_hit_weapon", func_player_get_hit_weapon},
    {"can_wield", func_player_can_wield},
    {"update_stamina", func_player_update_stamina},
    {"update_morale", func_player_update_morale},
    {"add_addiction", func_player_add_addiction},
    {"cancel_activity", func_player_cancel_activity},
    {"update_bodytemp", func_player_update_bodytemp},
    {"mod_painkiller", func_player_mod_painkiller},
    {"update_body_wetness", func_player_update_body_wetness},
    {"do_read", func_player_do_read},
    {"shoe_type_count", func_player_shoe_type_count},
    {"drench", func_player_drench},
    {"crossed_threshold", func_player_crossed_threshold},
    {"has_miss_recovery_tec", func_player_has_miss_recovery_tec},
    {"talk_skill", func_player_talk_skill},
    {"place_corpse", func_player_place_corpse},
    {"add_morale", func_player_add_morale},
    {"unimpaired_range", func_player_unimpaired_range},
    {"mutate_category", func_player_mutate_category},
    {"unarmed_value", func_player_unarmed_value},
    {"global_sm_location", func_player_global_sm_location},
    {"try_to_sleep", func_player_try_to_sleep},
    {"mend", func_player_mend},
    {"remove_random_bionic", func_player_remove_random_bionic},
    {"make_craft", func_player_make_craft},
    {"suffer", func_player_suffer},
    {"bonus_item_warmth", func_player_bonus_item_warmth},
    {"spores", func_player_spores},
    {"add_known_trap", func_player_add_known_trap},
    {"stomach_capacity", func_player_stomach_capacity},
    {"intimidation", func_player_intimidation},
    {"making_would_work", func_player_making_would_work},
    {"weapon_value", func_player_weapon_value},
    {"heal", func_player_heal},
    {"remove_bionic", func_player_remove_bionic},
    {"sight_impaired", func_player_sight_impaired},
    {"blossoms", func_player_blossoms},
    {"is_allergic", func_player_is_allergic},
    {"get_highest_category", func_player_get_highest_category},
    {"can_weapon_block", func_player_can_weapon_block},
    {"ma_onmove_effects", func_player_ma_onmove_effects},
    {"sety", func_player_sety},
    {"setz", func_player_setz},
    {"get_painkiller", func_player_get_painkiller},
    {"is_throw_immune", func_player_is_throw_immune},
    {"purifiable", func_player_purifiable},
    {"shift_destination", func_player_shift_destination},
    {"setID", func_player_setID},
    {"rooted_message", func_player_rooted_message},
    {"in_climate_control", func_player_in_climate_control},
    {"has_morale_to_craft", func_player_has_morale_to_craft},
    {"consume_charges", func_player_consume_charges},
    {"reduce_charges", func_player_reduce_charges},
    {"load_info", func_player_load_info},
    {"is_deaf", func_player_is_deaf},
    {"regen", func_player_regen},
    {"getID", func_player_getID},
    {"clear_miss_reasons", func_player_clear_miss_reasons},
    {"recraft", func_player_recraft},
    {"power_mutations", func_player_power_mutations},
    {"has_addiction", func_player_has_addiction},
    {"get_morale_level", func_player_get_morale_level},
    {"global_omt_location", func_player_global_omt_location},
    {"get_armor_acid", func_player_get_armor_acid},
    {"ma_static_effects", func_player_ma_static_effects},
    {"ma_ondodge_effects", func_player_ma_ondodge_effects},
    {"hearing_ability", func_player_hearing_ability},
    {"complete_craft", func_player_complete_craft},
    {"gunmod_add", func_player_gunmod_add},
    {"get_wind_resistance", func_player_get_wind_resistance},
    {"install_bionics", func_player_install_bionics},
    {"hitall", func_player_hitall},
    {"has_bionic", func_player_has_bionic},
    {"random_good_trait", func_player_random_good_trait},
    {"get_item_position", func_player_get_item_position},
    {"can_pickVolume", func_player_can_pickVolume},
    {"get_per_bonus", func_player_get_per_bonus},
    {"add_traits", func_player_add_traits},
    {"set_per_bonus", func_player_set_per_bonus},
    {"mutation_effect", func_player_mutation_effect},
    {"weight_carried", func_player_weight_carried},
    {"set_dex_bonus", func_player_set_dex_bonus},
    {"set_mutation", func_player_set_mutation},
    {"remove_weapon", func_player_remove_weapon},
    {"recalc_hp", func_player_recalc_hp},
    {"get_dex_base", func_player_get_dex_base},
    {"get_healthy_mod", func_player_get_healthy_mod},
    {"is_wearing_on_bp", func_player_is_wearing_on_bp},
    {"recalc_sight_limits", func_player_recalc_sight_limits},
    {"set_healthy_mod", func_player_set_healthy_mod},
    {"get_turn_died", func_player_get_turn_died},
    {"set_healthy", func_player_set_healthy},
    {"has_nv", func_player_has_nv},
    {"has_active_mutation", func_player_has_active_mutation},
    {"worn_with_flag", func_player_worn_with_flag},
    {"i_add_or_drop", func_player_i_add_or_drop},
    {"mutation_loss_effect", func_player_mutation_loss_effect},
    {"get_str_bonus", func_player_get_str_bonus},
    {"set_thirst", func_player_set_thirst},
    {"mod_int_bonus", func_player_mod_int_bonus},
    {"set_str_bonus", func_player_set_str_bonus},
    {"aim_per_move", func_player_aim_per_move},
    {"get_int_base", func_player_get_int_base},
    {"can_use", func_player_can_use},
    {"pick_name", func_player_pick_name},
    {"get_per_base", func_player_get_per_base},
    {"get_thirst", func_player_get_thirst},
    {"empty_skills", func_player_empty_skills},
    {"volume_carried", func_player_volume_carried},
    {"get_dex", func_player_get_dex},
    {"i_at", func_player_i_at},
    {"i_rem_keep_contents", func_player_i_rem_keep_contents},
    {"made_of", func_player_made_of},
    {"can_pickWeight", func_player_can_pickWeight},
    {"get_vision_threshold", func_player_get_vision_threshold},
    {"unset_mutation", func_player_unset_mutation},
    {"has_active_item", func_player_has_active_item},
    {"get_str", func_player_get_str},
    {"is_wearing", func_player_is_wearing},
    {"mod_per_bonus", func_player_mod_per_bonus},
    {"empty_traits", func_player_empty_traits},
    {"update_health", func_player_update_health},
    {"i_rem", func_player_i_rem},
    {"mod_stomach_food", func_player_mod_stomach_food},
    {"mod_thirst", func_player_mod_thirst},
    {"get_int", func_player_get_int},
    {"random_bad_trait", func_player_random_bad_trait},
    {"mod_dex_bonus", func_player_mod_dex_bonus},
    {"mod_str_bonus", func_player_mod_str_bonus},
    {"toggle_trait", func_player_toggle_trait},
    {"get_str_base", func_player_get_str_base},
    {"get_per", func_player_get_per},
    {"get_dex_bonus", func_player_get_dex_bonus},
    {"set_fatigue", func_player_set_fatigue},
    {"mod_hunger", func_player_mod_hunger},
    {"set_stomach_water", func_player_set_stomach_water},
    {"get_healthy", func_player_get_healthy},
    {"remove_mission_items", func_player_remove_mission_items},
    {"has_trait_flag", func_player_has_trait_flag},
    {"set_hunger", func_player_set_hunger},
    {"is_worn", func_player_is_worn},
    {"get_fatigue", func_player_get_fatigue},
    {"volume_capacity", func_player_volume_capacity},
    {"limb_color", func_player_limb_color},
    {"mod_healthy", func_player_mod_healthy},
    {"set_int_bonus", func_player_set_int_bonus},
    {"has_active_bionic", func_player_has_active_bionic},
    {"mod_fatigue", func_player_mod_fatigue},
    {"get_stomach_water", func_player_get_stomach_water},
    {"get_stomach_food", func_player_get_stomach_food},
    {"set_turn_died", func_player_set_turn_died},
    {"get_hunger", func_player_get_hunger},
    {"has_base_trait", func_player_has_base_trait},
    {"mod_healthy_mod", func_player_mod_healthy_mod},
    {"set_stomach_food", func_player_set_stomach_food},
    {"i_add", func_player_i_add},
    {"mod_stomach_water", func_player_mod_stomach_water},
    {"get_int_bonus", func_player_get_int_bonus},
    {"trait_by_invlet", func_player_trait_by_invlet},
    {"is_dead_state", func_player_is_dead_state},
    {"basic_symbol_color", func_player_basic_symbol_color},
    {"is_fake", func_player_is_fake},
    {"melee_attack", func_player_melee_attack},
    {"get_killer", func_player_get_killer},
    {"get_armor_bash", func_player_get_armor_bash},
    {"posx", func_player_posx},
    {"hp_percentage", func_player_hp_percentage},
    {"gibType", func_player_gibType},
    {"mod_moves", func_player_mod_moves},
    {"bloodType", func_player_bloodType},
    {"digging", func_player_digging},
    {"pos", func_player_pos},
    {"has_trait", func_player_has_trait},
    {"get_perceived_pain", func_player_get_perceived_pain},
    {"is_monster", func_player_is_monster},
    {"get_hp", func_player_get_hp},
    {"set_armor_cut_bonus", func_player_set_armor_cut_bonus},
    {"get_env_resist", func_player_get_env_resist},
    {"set_fake", func_player_set_fake},
    {"mod_pain", func_player_mod_pain},
    {"is_hallucination", func_player_is_hallucination},
    {"get_throw_resist", func_player_get_throw_resist},
    {"get_value", func_player_get_value},
    {"set_throw_resist", func_player_set_throw_resist},
    {"get_armor_cut_bonus", func_player_get_armor_cut_bonus},
    {"skin_name", func_player_skin_name},
    {"get_hp_max", func_player_get_hp_max},
    {"set_cut_bonus", func_player_set_cut_bonus},
    {"on_hit", func_player_on_hit},
    {"mod_stat", func_player_mod_stat},
    {"setpos", func_player_setpos},
    {"get_speed_bonus", func_player_get_speed_bonus},
    {"get_size", func_player_get_size},
    {"is_warm", func_player_is_warm},
    {"process_turn", func_player_process_turn},
    {"disp_name", func_player_disp_name},
    {"get_cut_mult", func_player_get_cut_mult},
    {"power_rating", func_player_power_rating},
    {"get_name", func_player_get_name},
    {"add_effect", func_player_add_effect},
    {"get_grab_resist", func_player_get_grab_resist},
    {"get_effect_int", func_player_get_effect_int},
    {"get_hit_bonus", func_player_get_hit_bonus},
    {"is_immune_effect", func_player_is_immune_effect},
    {"set_cut_mult", func_player_set_cut_mult},
    {"get_num_dodges", func_player_get_num_dodges},
    {"is_npc", func_player_is_npc},
    {"set_bash_bonus", func_player_set_bash_bonus},
    {"reset_bonuses", func_player_reset_bonuses},
    {"get_dodge_bonus", func_player_get_dodge_bonus},
    {"set_speed_bonus", func_player_set_speed_bonus},
    {"hit_roll", func_player_hit_roll},
    {"get_num_blocks", func_player_get_num_blocks},
    {"on_dodge", func_player_on_dodge},
    {"get_bash_bonus", func_player_get_bash_bonus},
    {"process_effects", func_player_process_effects},
    {"set_dodge_bonus", func_player_set_dodge_bonus},
    {"get_num_dodges_bonus", func_player_get_num_dodges_bonus},
    {"get_dodge", func_player_get_dodge},
    {"get_dodge_base", func_player_get_dodge_base},
    {"normalize", func_player_normalize},
    {"mod_bash_bonus", func_player_mod_bash_bonus},
    {"set_num_dodges_bonus", func_player_set_num_dodges_bonus},
    {"mod_hit_bonus", func_player_mod_hit_bonus},
    {"sight_range", func_player_sight_range},
    {"reset", func_player_reset},
    {"speed_rating", func_player_speed_rating},
    {"get_num_blocks_bonus", func_player_get_num_blocks_bonus},
    {"get_armor_bash_base", func_player_get_armor_bash_base},
    {"has_weapon", func_player_has_weapon},
    {"posz", func_player_posz},
    {"get_armor_cut", func_player_get_armor_cut},
    {"reset_stats", func_player_reset_stats},
    {"set_num_blocks_bonus", func_player_set_num_blocks_bonus},
    {"mod_cut_bonus", func_player_mod_cut_bonus},
    {"has_grab_break_tec", func_player_has_grab_break_tec},
    {"mod_dodge_bonus", func_player_mod_dodge_bonus},
    {"is_symbol_highlighted", func_player_is_symbol_highlighted},
    {"move_effects", func_player_move_effects},
    {"get_hit_base", func_player_get_hit_base},
    {"mod_speed_bonus", func_player_mod_speed_bonus},
    {"get_cut_bonus", func_player_get_cut_bonus},
    {"in_sleep_state", func_player_in_sleep_state},
    {"set_value", func_player_set_value},
    {"remove_effect", func_player_remove_effect},
    {"sees", func_player_sees},
    {"get_weight", func_player_get_weight},
    {"symbol_color", func_player_symbol_color},
    {"weight_capacity", func_player_weight_capacity},
    {"uncanny_dodge", func_player_uncanny_dodge},
    {"set_block_bonus", func_player_set_block_bonus},
    {"set_speed_base", func_player_set_speed_base},
    {"die", func_player_die},
    {"mod_block_bonus", func_player_mod_block_bonus},
    {"symbol", func_player_symbol},
    {"knock_back_from", func_player_knock_back_from},
    {"set_bash_mult", func_player_set_bash_mult},
    {"deal_melee_attack", func_player_deal_melee_attack},
    {"avoid_trap", func_player_avoid_trap},
    {"clear_effects", func_player_clear_effects},
    {"get_bash_mult", func_player_get_bash_mult},
    {"get_speed", func_player_get_speed},
    {"get_block_bonus", func_player_get_block_bonus},
    {"get_speed_base", func_player_get_speed_base},
    {"has_effect", func_player_has_effect},
    {"mod_pain_noresist", func_player_mod_pain_noresist},
    {"set_armor_bash_bonus", func_player_set_armor_bash_bonus},
    {"set_moves", func_player_set_moves},
    {"add_env_effect", func_player_add_env_effect},
    {"check_dead_state", func_player_check_dead_state},
    {"set_melee_quiet", func_player_set_melee_quiet},
    {"set_hit_bonus", func_player_set_hit_bonus},
    {"set_grab_resist", func_player_set_grab_resist},
    {"fall_damage_mod", func_player_fall_damage_mod},
    {"get_random_body_part", func_player_get_random_body_part},
    {"get_melee", func_player_get_melee},
    {"is_elec_immune", func_player_is_elec_immune},
    {"is_on_ground", func_player_is_on_ground},
    {"get_armor_bash_bonus", func_player_get_armor_bash_bonus},
    {"is_underwater", func_player_is_underwater},
    {"stability_roll", func_player_stability_roll},
    {"is_player", func_player_is_player},
    {"get_effect_dur", func_player_get_effect_dur},
    {"apply_damage", func_player_apply_damage},
    {"impact", func_player_impact},
    {"get_melee_quiet", func_player_get_melee_quiet},
    {"remove_value", func_player_remove_value},
    {"posy", func_player_posy},
    {"get_pain", func_player_get_pain},
    {"set_pain", func_player_set_pain},
    {"get_armor_cut_base", func_player_get_armor_cut_base},
    {"dodge_roll", func_player_dodge_roll},
    {"get_hit", func_player_get_hit},
    {NULL, NULL}
};
template<>
const LuaValue<player*>::MRMap LuaValue<player*>::READ_MEMBERS{
    {"oxygen", get_player_oxygen},
    {"radiation", get_player_radiation},
    {"view_offset", get_player_view_offset},
    {"grab_point", get_player_grab_point},
    {"style_selected", get_player_style_selected},
    {"tank_plut", get_player_tank_plut},
    {"blocks_left", get_player_blocks_left},
    {"power_level", get_player_power_level},
    {"last_climate_control_ret", get_player_last_climate_control_ret},
    {"volume", get_player_volume},
    {"next_climate_control_check", get_player_next_climate_control_check},
    {"scent", get_player_scent},
    {"focus_pool", get_player_focus_pool},
    {"reactor_plut", get_player_reactor_plut},
    {"start_location", get_player_start_location},
    {"stamina", get_player_stamina},
    {"recoil", get_player_recoil},
    {"controlling_vehicle", get_player_controlling_vehicle},
    {"lastconsumed", get_player_lastconsumed},
    {"stim", get_player_stim},
    {"slow_rad", get_player_slow_rad},
    {"last_batch", get_player_last_batch},
    {"max_power_level", get_player_max_power_level},
    {"dodges_left", get_player_dodges_left},
    {"move_mode", get_player_move_mode},
    {"lastrecipe", get_player_lastrecipe},
    {"keep_hands_free", get_player_keep_hands_free},
    {"movecounter", get_player_movecounter},
    {"in_vehicle", get_player_in_vehicle},
    {"cash", get_player_cash},
    {"dex_cur", get_player_dex_cur},
    {"per_max", get_player_per_max},
    {"int_max", get_player_int_max},
    {"weapon", get_player_weapon},
    {"male", get_player_male},
    {"str_cur", get_player_str_cur},
    {"int_cur", get_player_int_cur},
    {"str_max", get_player_str_max},
    {"name", get_player_name},
    {"nv_cached", get_player_nv_cached},
    {"dex_max", get_player_dex_max},
    {"per_cur", get_player_per_cur},
};
template<>
const LuaValue<player*>::MWMap LuaValue<player*>::WRITE_MEMBERS{
    {"oxygen", set_player_oxygen},
    {"radiation", set_player_radiation},
    {"view_offset", set_player_view_offset},
    {"grab_point", set_player_grab_point},
    {"style_selected", set_player_style_selected},
    {"tank_plut", set_player_tank_plut},
    {"blocks_left", set_player_blocks_left},
    {"power_level", set_player_power_level},
    {"last_climate_control_ret", set_player_last_climate_control_ret},
    {"volume", set_player_volume},
    {"next_climate_control_check", set_player_next_climate_control_check},
    {"scent", set_player_scent},
    {"focus_pool", set_player_focus_pool},
    {"reactor_plut", set_player_reactor_plut},
    {"start_location", set_player_start_location},
    {"stamina", set_player_stamina},
    {"recoil", set_player_recoil},
    {"controlling_vehicle", set_player_controlling_vehicle},
    {"lastconsumed", set_player_lastconsumed},
    {"stim", set_player_stim},
    {"slow_rad", set_player_slow_rad},
    {"last_batch", set_player_last_batch},
    {"max_power_level", set_player_max_power_level},
    {"dodges_left", set_player_dodges_left},
    {"move_mode", set_player_move_mode},
    {"lastrecipe", set_player_lastrecipe},
    {"keep_hands_free", set_player_keep_hands_free},
    {"movecounter", set_player_movecounter},
    {"in_vehicle", set_player_in_vehicle},
    {"cash", set_player_cash},
    {"dex_cur", set_player_dex_cur},
    {"per_max", set_player_per_max},
    {"int_max", set_player_int_max},
    {"weapon", set_player_weapon},
    {"male", set_player_male},
    {"str_cur", set_player_str_cur},
    {"int_cur", set_player_int_cur},
    {"str_max", set_player_str_max},
    {"name", set_player_name},
    {"nv_cached", set_player_nv_cached},
    {"dex_max", set_player_dex_max},
    {"per_cur", set_player_per_cur},
};
template<>
const char * const LuaValue<efftype_id>::METATABLE_NAME = "efftype_id_metatable";
template<>
LuaValue<efftype_id>::Type *LuaValue<efftype_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<efftype_id>::FUNCTIONS[] = {
    {"str", func_efftype_id_str},
    {"is_valid", func_efftype_id_is_valid},
    {"obj", func_efftype_id_obj},
    {"__call", new_efftype_id},
    {"__eq", op_efftype_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<efftype_id>::MRMap LuaValue<efftype_id>::READ_MEMBERS{
};
template<>
const LuaValue<efftype_id>::MWMap LuaValue<efftype_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<furn_id>::METATABLE_NAME = "furn_id_metatable";
template<>
LuaValue<furn_id>::Type *LuaValue<furn_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<furn_id>::FUNCTIONS[] = {
    {"to_i", func_furn_id_to_i},
    {"obj", func_furn_id_obj},
    {"__call", new_furn_id},
    {"__eq", op_furn_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<furn_id>::MRMap LuaValue<furn_id>::READ_MEMBERS{
};
template<>
const LuaValue<furn_id>::MWMap LuaValue<furn_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<volume>::METATABLE_NAME = "volume_metatable";
template<>
LuaValue<volume>::Type *LuaValue<volume>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<volume>::FUNCTIONS[] = {
    {"value", func_volume_value},
    {NULL, NULL}
};
template<>
const LuaValue<volume>::MRMap LuaValue<volume>::READ_MEMBERS{
};
template<>
const LuaValue<volume>::MWMap LuaValue<volume>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<game*>::METATABLE_NAME = "game_metatable";
template<>
LuaValue<game*>::Type *LuaValue<game*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<game*>::FUNCTIONS[] = {
    {"swap_critters", func_game_swap_critters},
    {"get_temperature", func_game_get_temperature},
    {"draw_critter", func_game_draw_critter},
    {"increase_kill_count", func_game_increase_kill_count},
    {"spread_fungus", func_game_spread_fungus},
    {"handle_liquid", func_game_handle_liquid},
    {"knockback", func_game_knockback},
    {"inventory_item_menu", func_game_inventory_item_menu},
    {"natural_light_level", func_game_natural_light_level},
    {"refresh_all", func_game_refresh_all},
    {"get_cur_om", func_game_get_cur_om},
    {"plswim", func_game_plswim},
    {"inv_for_flag", func_game_inv_for_flag},
    {"look_around", func_game_look_around},
    {"flashbang", func_game_flashbang},
    {"draw_hit_player", func_game_draw_hit_player},
    {"zombie", func_game_zombie},
    {"assign_faction_id", func_game_assign_faction_id},
    {"teleport", func_game_teleport},
    {"draw", func_game_draw},
    {"npc_by_id", func_game_npc_by_id},
    {"assign_mission_id", func_game_assign_mission_id},
    {"mon_at", func_game_mon_at},
    {"cancel_activity", func_game_cancel_activity},
    {"add_zombie", func_game_add_zombie},
    {"npc_at", func_game_npc_at},
    {"monster_at", func_game_monster_at},
    {"save", func_game_save},
    {"revive_corpse", func_game_revive_corpse},
    {"nuke", func_game_nuke},
    {"is_hostile_very_close", func_game_is_hostile_very_close},
    {"draw_trail_to_square", func_game_draw_trail_to_square},
    {"open_gate", func_game_open_gate},
    {"look_debug", func_game_look_debug},
    {"peek", func_game_peek},
    {"num_zombies", func_game_num_zombies},
    {"draw_sct", func_game_draw_sct},
    {"do_blast", func_game_do_blast},
    {"is_empty", func_game_is_empty},
    {"shockwave", func_game_shockwave},
    {"use_computer", func_game_use_computer},
    {"fling_creature", func_game_fling_creature},
    {"inv_for_all", func_game_inv_for_all},
    {"kill_count", func_game_kill_count},
    {"remove_zombie", func_game_remove_zombie},
    {"clear_zombies", func_game_clear_zombies},
    {"emp_blast", func_game_emp_blast},
    {"light_level", func_game_light_level},
    {"get_levz", func_game_get_levz},
    {"summon_mon", func_game_summon_mon},
    {"get_levy", func_game_get_levy},
    {"draw_ter", func_game_draw_ter},
    {"assign_npc_id", func_game_assign_npc_id},
    {"critter_at", func_game_critter_at},
    {"spawn_hallucination", func_game_spawn_hallucination},
    {"is_in_sunlight", func_game_is_in_sunlight},
    {"explosion", func_game_explosion},
    {"resonance_cascade", func_game_resonance_cascade},
    {"draw_explosion", func_game_draw_explosion},
    {"scrambler_blast", func_game_scrambler_blast},
    {"draw_hit_mon", func_game_draw_hit_mon},
    {"unload", func_game_unload},
    {"plfire", func_game_plfire},
    {"is_sheltered", func_game_is_sheltered},
    {"get_levx", func_game_get_levx},
    {"is_hostile_nearby", func_game_is_hostile_nearby},
    {NULL, NULL}
};
template<>
const LuaValue<game*>::MRMap LuaValue<game*>::READ_MEMBERS{
    {"lightning_active", get_game_lightning_active},
};
template<>
const LuaValue<game*>::MWMap LuaValue<game*>::WRITE_MEMBERS{
    {"lightning_active", set_game_lightning_active},
};
template<>
const char * const LuaValue<trap_str_id>::METATABLE_NAME = "trap_str_id_metatable";
template<>
LuaValue<trap_str_id>::Type *LuaValue<trap_str_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<trap_str_id>::FUNCTIONS[] = {
    {"str", func_trap_str_id_str},
    {"is_valid", func_trap_str_id_is_valid},
    {"id", func_trap_str_id_id},
    {"__call", new_trap_str_id},
    {"__eq", op_trap_str_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<trap_str_id>::MRMap LuaValue<trap_str_id>::READ_MEMBERS{
};
template<>
const LuaValue<trap_str_id>::MWMap LuaValue<trap_str_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<ter_str_id>::METATABLE_NAME = "ter_str_id_metatable";
template<>
LuaValue<ter_str_id>::Type *LuaValue<ter_str_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ter_str_id>::FUNCTIONS[] = {
    {"str", func_ter_str_id_str},
    {"is_valid", func_ter_str_id_is_valid},
    {"id", func_ter_str_id_id},
    {"__call", new_ter_str_id},
    {"__eq", op_ter_str_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<ter_str_id>::MRMap LuaValue<ter_str_id>::READ_MEMBERS{
};
template<>
const LuaValue<ter_str_id>::MWMap LuaValue<ter_str_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<matec_id>::METATABLE_NAME = "matec_id_metatable";
template<>
LuaValue<matec_id>::Type *LuaValue<matec_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<matec_id>::FUNCTIONS[] = {
    {"str", func_matec_id_str},
    {"is_valid", func_matec_id_is_valid},
    {"obj", func_matec_id_obj},
    {"__call", new_matec_id},
    {"__eq", op_matec_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<matec_id>::MRMap LuaValue<matec_id>::READ_MEMBERS{
};
template<>
const LuaValue<matec_id>::MWMap LuaValue<matec_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<mongroup_id>::METATABLE_NAME = "mongroup_id_metatable";
template<>
LuaValue<mongroup_id>::Type *LuaValue<mongroup_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<mongroup_id>::FUNCTIONS[] = {
    {"str", func_mongroup_id_str},
    {"is_valid", func_mongroup_id_is_valid},
    {"obj", func_mongroup_id_obj},
    {"__call", new_mongroup_id},
    {"__eq", op_mongroup_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<mongroup_id>::MRMap LuaValue<mongroup_id>::READ_MEMBERS{
};
template<>
const LuaValue<mongroup_id>::MWMap LuaValue<mongroup_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<point>::METATABLE_NAME = "point_metatable";
template<>
LuaValue<point>::Type *LuaValue<point>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<point>::FUNCTIONS[] = {
    {"__call", new_point},
    {"__eq", op_point_eq},
    {NULL, NULL}
};
template<>
const LuaValue<point>::MRMap LuaValue<point>::READ_MEMBERS{
    {"y", get_point_y},
    {"x", get_point_x},
};
template<>
const LuaValue<point>::MWMap LuaValue<point>::WRITE_MEMBERS{
    {"y", set_point_y},
    {"x", set_point_x},
};
template<>
const char * const LuaValue<calendar*>::METATABLE_NAME = "calendar_metatable";
template<>
LuaValue<calendar*>::Type *LuaValue<calendar*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<calendar*>::FUNCTIONS[] = {
    {"years", func_calendar_years},
    {"sunrise", func_calendar_sunrise},
    {"day_of_year", func_calendar_day_of_year},
    {"textify_period", func_calendar_textify_period},
    {"seconds_past_midnight", func_calendar_seconds_past_midnight},
    {"turn_of_year", func_calendar_turn_of_year},
    {"minutes", func_calendar_minutes},
    {"minutes_past_midnight", func_calendar_minutes_past_midnight},
    {"days", func_calendar_days},
    {"seconds", func_calendar_seconds},
    {"get_season", func_calendar_get_season},
    {"day_of_week", func_calendar_day_of_week},
    {"increment", func_calendar_increment},
    {"is_night", func_calendar_is_night},
    {"sunlight", func_calendar_sunlight},
    {"sunset", func_calendar_sunset},
    {"hours", func_calendar_hours},
    {"get_turn", func_calendar_get_turn},
    {"print_time", func_calendar_print_time},
    {"__call", new_calendar},
    {NULL, NULL}
};
template<>
const LuaValue<calendar*>::MRMap LuaValue<calendar*>::READ_MEMBERS{
};
template<>
const LuaValue<calendar*>::MWMap LuaValue<calendar*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<calendar>::METATABLE_NAME = "value_of_calendar_metatable";
template<>
LuaValue<calendar>::Type *LuaValue<calendar>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<calendar>::FUNCTIONS[] = {
    {"years", func_calendar_years},
    {"sunrise", func_calendar_sunrise},
    {"day_of_year", func_calendar_day_of_year},
    {"textify_period", func_calendar_textify_period},
    {"seconds_past_midnight", func_calendar_seconds_past_midnight},
    {"turn_of_year", func_calendar_turn_of_year},
    {"minutes", func_calendar_minutes},
    {"minutes_past_midnight", func_calendar_minutes_past_midnight},
    {"days", func_calendar_days},
    {"seconds", func_calendar_seconds},
    {"get_season", func_calendar_get_season},
    {"day_of_week", func_calendar_day_of_week},
    {"increment", func_calendar_increment},
    {"is_night", func_calendar_is_night},
    {"sunlight", func_calendar_sunlight},
    {"sunset", func_calendar_sunset},
    {"hours", func_calendar_hours},
    {"get_turn", func_calendar_get_turn},
    {"print_time", func_calendar_print_time},
    {"__call", new_calendar},
    {NULL, NULL}
};
template<>
const LuaValue<calendar>::MRMap LuaValue<calendar>::READ_MEMBERS{
};
template<>
const LuaValue<calendar>::MWMap LuaValue<calendar>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<ma_buff*>::METATABLE_NAME = "ma_buff_metatable";
template<>
LuaValue<ma_buff*>::Type *LuaValue<ma_buff*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ma_buff*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<ma_buff*>::MRMap LuaValue<ma_buff*>::READ_MEMBERS{
};
template<>
const LuaValue<ma_buff*>::MWMap LuaValue<ma_buff*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<uimenu*>::METATABLE_NAME = "uimenu_metatable";
template<>
LuaValue<uimenu*>::Type *LuaValue<uimenu*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<uimenu*>::FUNCTIONS[] = {
    {"show", func_uimenu_show},
    {"addentry", func_uimenu_addentry},
    {"query", func_uimenu_query},
    {NULL, NULL}
};
template<>
const LuaValue<uimenu*>::MRMap LuaValue<uimenu*>::READ_MEMBERS{
    {"title", get_uimenu_title},
    {"selected", get_uimenu_selected},
};
template<>
const LuaValue<uimenu*>::MWMap LuaValue<uimenu*>::WRITE_MEMBERS{
    {"title", set_uimenu_title},
};
template<>
const char * const LuaValue<map_stack>::METATABLE_NAME = "map_stack_metatable";
template<>
LuaValue<map_stack>::Type *LuaValue<map_stack>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<map_stack>::FUNCTIONS[] = {
    {"erase", func_map_stack_erase},
    {"cppbegin", func_map_stack_cppbegin},
    {"push_back", func_map_stack_push_back},
    {"empty", func_map_stack_empty},
    {"cppend", func_map_stack_cppend},
    {"size", func_map_stack_size},
    {NULL, NULL}
};
template<>
const LuaValue<map_stack>::MRMap LuaValue<map_stack>::READ_MEMBERS{
};
template<>
const LuaValue<map_stack>::MWMap LuaValue<map_stack>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<ter_id>::METATABLE_NAME = "ter_id_metatable";
template<>
LuaValue<ter_id>::Type *LuaValue<ter_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ter_id>::FUNCTIONS[] = {
    {"to_i", func_ter_id_to_i},
    {"obj", func_ter_id_obj},
    {"__call", new_ter_id},
    {"__eq", op_ter_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<ter_id>::MRMap LuaValue<ter_id>::READ_MEMBERS{
};
template<>
const LuaValue<ter_id>::MWMap LuaValue<ter_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<effect_type*>::METATABLE_NAME = "effect_type_metatable";
template<>
LuaValue<effect_type*>::Type *LuaValue<effect_type*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<effect_type*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<effect_type*>::MRMap LuaValue<effect_type*>::READ_MEMBERS{
};
template<>
const LuaValue<effect_type*>::MWMap LuaValue<effect_type*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<Character*>::METATABLE_NAME = "Character_metatable";
template<>
LuaValue<Character*>::Type *LuaValue<Character*>::get_subclass( lua_State* const S, int const i) {
    if(LuaReference<player>::has(S, i)) {
        return &LuaReference<player>::get( S, i );
    }
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<Character*>::FUNCTIONS[] = {
    {"has_bionic", func_Character_has_bionic},
    {"random_good_trait", func_Character_random_good_trait},
    {"get_item_position", func_Character_get_item_position},
    {"can_pickVolume", func_Character_can_pickVolume},
    {"get_per_bonus", func_Character_get_per_bonus},
    {"add_traits", func_Character_add_traits},
    {"set_per_bonus", func_Character_set_per_bonus},
    {"mutation_effect", func_Character_mutation_effect},
    {"weight_carried", func_Character_weight_carried},
    {"set_dex_bonus", func_Character_set_dex_bonus},
    {"set_mutation", func_Character_set_mutation},
    {"remove_weapon", func_Character_remove_weapon},
    {"recalc_hp", func_Character_recalc_hp},
    {"get_dex_base", func_Character_get_dex_base},
    {"get_healthy_mod", func_Character_get_healthy_mod},
    {"is_wearing_on_bp", func_Character_is_wearing_on_bp},
    {"recalc_sight_limits", func_Character_recalc_sight_limits},
    {"set_healthy_mod", func_Character_set_healthy_mod},
    {"get_turn_died", func_Character_get_turn_died},
    {"set_healthy", func_Character_set_healthy},
    {"has_nv", func_Character_has_nv},
    {"has_active_mutation", func_Character_has_active_mutation},
    {"worn_with_flag", func_Character_worn_with_flag},
    {"i_add_or_drop", func_Character_i_add_or_drop},
    {"mutation_loss_effect", func_Character_mutation_loss_effect},
    {"get_str_bonus", func_Character_get_str_bonus},
    {"set_thirst", func_Character_set_thirst},
    {"mod_int_bonus", func_Character_mod_int_bonus},
    {"set_str_bonus", func_Character_set_str_bonus},
    {"aim_per_move", func_Character_aim_per_move},
    {"get_int_base", func_Character_get_int_base},
    {"can_use", func_Character_can_use},
    {"pick_name", func_Character_pick_name},
    {"get_per_base", func_Character_get_per_base},
    {"get_thirst", func_Character_get_thirst},
    {"empty_skills", func_Character_empty_skills},
    {"volume_carried", func_Character_volume_carried},
    {"get_dex", func_Character_get_dex},
    {"i_at", func_Character_i_at},
    {"i_rem_keep_contents", func_Character_i_rem_keep_contents},
    {"made_of", func_Character_made_of},
    {"can_pickWeight", func_Character_can_pickWeight},
    {"get_vision_threshold", func_Character_get_vision_threshold},
    {"unset_mutation", func_Character_unset_mutation},
    {"has_active_item", func_Character_has_active_item},
    {"get_str", func_Character_get_str},
    {"is_wearing", func_Character_is_wearing},
    {"mod_per_bonus", func_Character_mod_per_bonus},
    {"empty_traits", func_Character_empty_traits},
    {"update_health", func_Character_update_health},
    {"i_rem", func_Character_i_rem},
    {"mod_stomach_food", func_Character_mod_stomach_food},
    {"mod_thirst", func_Character_mod_thirst},
    {"get_int", func_Character_get_int},
    {"random_bad_trait", func_Character_random_bad_trait},
    {"mod_dex_bonus", func_Character_mod_dex_bonus},
    {"mod_str_bonus", func_Character_mod_str_bonus},
    {"toggle_trait", func_Character_toggle_trait},
    {"get_str_base", func_Character_get_str_base},
    {"get_per", func_Character_get_per},
    {"get_dex_bonus", func_Character_get_dex_bonus},
    {"set_fatigue", func_Character_set_fatigue},
    {"mod_hunger", func_Character_mod_hunger},
    {"set_stomach_water", func_Character_set_stomach_water},
    {"get_healthy", func_Character_get_healthy},
    {"remove_mission_items", func_Character_remove_mission_items},
    {"has_trait_flag", func_Character_has_trait_flag},
    {"set_hunger", func_Character_set_hunger},
    {"is_worn", func_Character_is_worn},
    {"get_fatigue", func_Character_get_fatigue},
    {"volume_capacity", func_Character_volume_capacity},
    {"limb_color", func_Character_limb_color},
    {"mod_healthy", func_Character_mod_healthy},
    {"set_int_bonus", func_Character_set_int_bonus},
    {"has_active_bionic", func_Character_has_active_bionic},
    {"mod_fatigue", func_Character_mod_fatigue},
    {"get_stomach_water", func_Character_get_stomach_water},
    {"get_stomach_food", func_Character_get_stomach_food},
    {"set_turn_died", func_Character_set_turn_died},
    {"get_hunger", func_Character_get_hunger},
    {"has_base_trait", func_Character_has_base_trait},
    {"mod_healthy_mod", func_Character_mod_healthy_mod},
    {"set_stomach_food", func_Character_set_stomach_food},
    {"i_add", func_Character_i_add},
    {"mod_stomach_water", func_Character_mod_stomach_water},
    {"get_int_bonus", func_Character_get_int_bonus},
    {"trait_by_invlet", func_Character_trait_by_invlet},
    {"is_dead_state", func_Character_is_dead_state},
    {"basic_symbol_color", func_Character_basic_symbol_color},
    {"is_fake", func_Character_is_fake},
    {"melee_attack", func_Character_melee_attack},
    {"get_killer", func_Character_get_killer},
    {"get_armor_bash", func_Character_get_armor_bash},
    {"posx", func_Character_posx},
    {"hp_percentage", func_Character_hp_percentage},
    {"gibType", func_Character_gibType},
    {"mod_moves", func_Character_mod_moves},
    {"bloodType", func_Character_bloodType},
    {"digging", func_Character_digging},
    {"pos", func_Character_pos},
    {"has_trait", func_Character_has_trait},
    {"get_perceived_pain", func_Character_get_perceived_pain},
    {"is_monster", func_Character_is_monster},
    {"get_hp", func_Character_get_hp},
    {"set_armor_cut_bonus", func_Character_set_armor_cut_bonus},
    {"get_env_resist", func_Character_get_env_resist},
    {"set_fake", func_Character_set_fake},
    {"mod_pain", func_Character_mod_pain},
    {"is_hallucination", func_Character_is_hallucination},
    {"get_throw_resist", func_Character_get_throw_resist},
    {"get_value", func_Character_get_value},
    {"set_throw_resist", func_Character_set_throw_resist},
    {"get_armor_cut_bonus", func_Character_get_armor_cut_bonus},
    {"skin_name", func_Character_skin_name},
    {"get_hp_max", func_Character_get_hp_max},
    {"set_cut_bonus", func_Character_set_cut_bonus},
    {"on_hit", func_Character_on_hit},
    {"mod_stat", func_Character_mod_stat},
    {"setpos", func_Character_setpos},
    {"get_speed_bonus", func_Character_get_speed_bonus},
    {"get_size", func_Character_get_size},
    {"is_warm", func_Character_is_warm},
    {"process_turn", func_Character_process_turn},
    {"disp_name", func_Character_disp_name},
    {"get_cut_mult", func_Character_get_cut_mult},
    {"power_rating", func_Character_power_rating},
    {"get_name", func_Character_get_name},
    {"add_effect", func_Character_add_effect},
    {"get_grab_resist", func_Character_get_grab_resist},
    {"get_effect_int", func_Character_get_effect_int},
    {"get_hit_bonus", func_Character_get_hit_bonus},
    {"is_immune_effect", func_Character_is_immune_effect},
    {"set_cut_mult", func_Character_set_cut_mult},
    {"get_num_dodges", func_Character_get_num_dodges},
    {"is_npc", func_Character_is_npc},
    {"set_bash_bonus", func_Character_set_bash_bonus},
    {"reset_bonuses", func_Character_reset_bonuses},
    {"get_dodge_bonus", func_Character_get_dodge_bonus},
    {"set_speed_bonus", func_Character_set_speed_bonus},
    {"hit_roll", func_Character_hit_roll},
    {"get_num_blocks", func_Character_get_num_blocks},
    {"on_dodge", func_Character_on_dodge},
    {"get_bash_bonus", func_Character_get_bash_bonus},
    {"process_effects", func_Character_process_effects},
    {"set_dodge_bonus", func_Character_set_dodge_bonus},
    {"get_num_dodges_bonus", func_Character_get_num_dodges_bonus},
    {"get_dodge", func_Character_get_dodge},
    {"get_dodge_base", func_Character_get_dodge_base},
    {"normalize", func_Character_normalize},
    {"mod_bash_bonus", func_Character_mod_bash_bonus},
    {"set_num_dodges_bonus", func_Character_set_num_dodges_bonus},
    {"mod_hit_bonus", func_Character_mod_hit_bonus},
    {"sight_range", func_Character_sight_range},
    {"reset", func_Character_reset},
    {"speed_rating", func_Character_speed_rating},
    {"get_num_blocks_bonus", func_Character_get_num_blocks_bonus},
    {"get_armor_bash_base", func_Character_get_armor_bash_base},
    {"has_weapon", func_Character_has_weapon},
    {"posz", func_Character_posz},
    {"get_armor_cut", func_Character_get_armor_cut},
    {"reset_stats", func_Character_reset_stats},
    {"set_num_blocks_bonus", func_Character_set_num_blocks_bonus},
    {"mod_cut_bonus", func_Character_mod_cut_bonus},
    {"has_grab_break_tec", func_Character_has_grab_break_tec},
    {"mod_dodge_bonus", func_Character_mod_dodge_bonus},
    {"is_symbol_highlighted", func_Character_is_symbol_highlighted},
    {"move_effects", func_Character_move_effects},
    {"get_hit_base", func_Character_get_hit_base},
    {"mod_speed_bonus", func_Character_mod_speed_bonus},
    {"get_cut_bonus", func_Character_get_cut_bonus},
    {"in_sleep_state", func_Character_in_sleep_state},
    {"set_value", func_Character_set_value},
    {"remove_effect", func_Character_remove_effect},
    {"sees", func_Character_sees},
    {"get_weight", func_Character_get_weight},
    {"symbol_color", func_Character_symbol_color},
    {"weight_capacity", func_Character_weight_capacity},
    {"uncanny_dodge", func_Character_uncanny_dodge},
    {"set_block_bonus", func_Character_set_block_bonus},
    {"set_speed_base", func_Character_set_speed_base},
    {"die", func_Character_die},
    {"mod_block_bonus", func_Character_mod_block_bonus},
    {"symbol", func_Character_symbol},
    {"knock_back_from", func_Character_knock_back_from},
    {"set_bash_mult", func_Character_set_bash_mult},
    {"deal_melee_attack", func_Character_deal_melee_attack},
    {"avoid_trap", func_Character_avoid_trap},
    {"clear_effects", func_Character_clear_effects},
    {"get_bash_mult", func_Character_get_bash_mult},
    {"get_speed", func_Character_get_speed},
    {"get_block_bonus", func_Character_get_block_bonus},
    {"get_speed_base", func_Character_get_speed_base},
    {"has_effect", func_Character_has_effect},
    {"mod_pain_noresist", func_Character_mod_pain_noresist},
    {"set_armor_bash_bonus", func_Character_set_armor_bash_bonus},
    {"set_moves", func_Character_set_moves},
    {"add_env_effect", func_Character_add_env_effect},
    {"check_dead_state", func_Character_check_dead_state},
    {"set_melee_quiet", func_Character_set_melee_quiet},
    {"set_hit_bonus", func_Character_set_hit_bonus},
    {"set_grab_resist", func_Character_set_grab_resist},
    {"fall_damage_mod", func_Character_fall_damage_mod},
    {"get_random_body_part", func_Character_get_random_body_part},
    {"get_melee", func_Character_get_melee},
    {"is_elec_immune", func_Character_is_elec_immune},
    {"is_on_ground", func_Character_is_on_ground},
    {"get_armor_bash_bonus", func_Character_get_armor_bash_bonus},
    {"is_underwater", func_Character_is_underwater},
    {"stability_roll", func_Character_stability_roll},
    {"is_player", func_Character_is_player},
    {"get_effect_dur", func_Character_get_effect_dur},
    {"apply_damage", func_Character_apply_damage},
    {"impact", func_Character_impact},
    {"get_melee_quiet", func_Character_get_melee_quiet},
    {"remove_value", func_Character_remove_value},
    {"posy", func_Character_posy},
    {"get_pain", func_Character_get_pain},
    {"set_pain", func_Character_set_pain},
    {"get_armor_cut_base", func_Character_get_armor_cut_base},
    {"dodge_roll", func_Character_dodge_roll},
    {"get_hit", func_Character_get_hit},
    {NULL, NULL}
};
template<>
const LuaValue<Character*>::MRMap LuaValue<Character*>::READ_MEMBERS{
    {"dex_cur", get_Character_dex_cur},
    {"per_max", get_Character_per_max},
    {"int_max", get_Character_int_max},
    {"weapon", get_Character_weapon},
    {"male", get_Character_male},
    {"str_cur", get_Character_str_cur},
    {"int_cur", get_Character_int_cur},
    {"str_max", get_Character_str_max},
    {"name", get_Character_name},
    {"nv_cached", get_Character_nv_cached},
    {"dex_max", get_Character_dex_max},
    {"per_cur", get_Character_per_cur},
};
template<>
const LuaValue<Character*>::MWMap LuaValue<Character*>::WRITE_MEMBERS{
    {"dex_cur", set_Character_dex_cur},
    {"per_max", set_Character_per_max},
    {"int_max", set_Character_int_max},
    {"weapon", set_Character_weapon},
    {"male", set_Character_male},
    {"str_cur", set_Character_str_cur},
    {"int_cur", set_Character_int_cur},
    {"str_max", set_Character_str_max},
    {"name", set_Character_name},
    {"nv_cached", set_Character_nv_cached},
    {"dex_max", set_Character_dex_max},
    {"per_cur", set_Character_per_cur},
};
template<>
const char * const LuaValue<item*>::METATABLE_NAME = "item_metatable";
template<>
LuaValue<item*>::Type *LuaValue<item*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<item*>::FUNCTIONS[] = {
    {"is_watertight_container", func_item_is_watertight_container},
    {"ammo_capacity", func_item_ammo_capacity},
    {"gun_recoil", func_item_gun_recoil},
    {"flammable", func_item_flammable},
    {"on_wield", func_item_on_wield},
    {"get_quality", func_item_get_quality},
    {"is_two_handed", func_item_is_two_handed},
    {"put_in", func_item_put_in},
    {"clear_vars", func_item_clear_vars},
    {"amount_of", func_item_amount_of},
    {"gun_cycle_mode", func_item_gun_cycle_mode},
    {"is_bionic", func_item_is_bionic},
    {"is_gun", func_item_is_gun},
    {"is_salvageable", func_item_is_salvageable},
    {"color_in_inventory", func_item_color_in_inventory},
    {"get_mtype", func_item_get_mtype},
    {"is_dangerous", func_item_is_dangerous},
    {"get_env_resist", func_item_get_env_resist},
    {"count_by_charges", func_item_count_by_charges},
    {"get_property_string", func_item_get_property_string},
    {"get_var", func_item_get_var},
    {"goes_bad", func_item_goes_bad},
    {"get_thickness", func_item_get_thickness},
    {"magazine_current", func_item_magazine_current},
    {"set_mtype", func_item_set_mtype},
    {"charges_of", func_item_charges_of},
    {"conductive", func_item_conductive},
    {"brewing_time", func_item_brewing_time},
    {"merge_charges", func_item_merge_charges},
    {"gun_range", func_item_gun_range},
    {"is_ammo", func_item_is_ammo},
    {"get_remaining_chapters", func_item_get_remaining_chapters},
    {"components_to_string", func_item_components_to_string},
    {"is_magazine", func_item_is_magazine},
    {"has_rotten_away", func_item_has_rotten_away},
    {"can_holster", func_item_can_holster},
    {"inc_damage", func_item_inc_damage},
    {"color", func_item_color},
    {"is_container_empty", func_item_is_container_empty},
    {"convert", func_item_convert},
    {"is_artifact", func_item_is_artifact},
    {"already_used_by_player", func_item_already_used_by_player},
    {"mark_as_used_by_player", func_item_mark_as_used_by_player},
    {"is_corpse", func_item_is_corpse},
    {"is_food", func_item_is_food},
    {"is_book", func_item_is_book},
    {"mark_chapter_as_read", func_item_mark_chapter_as_read},
    {"calc_rot", func_item_calc_rot},
    {"gunmod_find", func_item_gunmod_find},
    {"fill_with", func_item_fill_with},
    {"is_container", func_item_is_container},
    {"ammo_current", func_item_ammo_current},
    {"melee_skill", func_item_melee_skill},
    {"set_relative_rot", func_item_set_relative_rot},
    {"is_silent", func_item_is_silent},
    {"volume", func_item_volume},
    {"add_technique", func_item_add_technique},
    {"damage", func_item_damage},
    {"get_relative_rot", func_item_get_relative_rot},
    {"craft_has_charges", func_item_craft_has_charges},
    {"ready_to_revive", func_item_ready_to_revive},
    {"on_pickup", func_item_on_pickup},
    {"is_going_bad", func_item_is_going_bad},
    {"get_side", func_item_get_side},
    {"is_armor", func_item_is_armor},
    {"gun_damage", func_item_gun_damage},
    {"get_remaining_capacity_for_liquid", func_item_get_remaining_capacity_for_liquid},
    {"acid_resist", func_item_acid_resist},
    {"is_ammo_container", func_item_is_ammo_container},
    {"bash_resist", func_item_bash_resist},
    {"load_info", func_item_load_info},
    {"get_chapters", func_item_get_chapters},
    {"serialize", func_item_serialize},
    {"get_usable_item", func_item_get_usable_item},
    {"is_null", func_item_is_null},
    {"charges_per_volume", func_item_charges_per_volume},
    {"is_emissive", func_item_is_emissive},
    {"stacks_with", func_item_stacks_with},
    {"erase_var", func_item_erase_var},
    {"set_snippet", func_item_set_snippet},
    {"get_plant_epoch", func_item_get_plant_epoch},
    {"gun_set_mode", func_item_gun_set_mode},
    {"get_storage", func_item_get_storage},
    {"has_label", func_item_has_label},
    {"deserialize", func_item_deserialize},
    {"chip_resistance", func_item_chip_resistance},
    {"symbol", func_item_symbol},
    {"is_firearm", func_item_is_firearm},
    {"get_property_long", func_item_get_property_long},
    {"is_food_container", func_item_is_food_container},
    {"add_rain_to_container", func_item_add_rain_to_container},
    {"has_flag", func_item_has_flag},
    {"is_gunmod", func_item_is_gunmod},
    {"mod_charges", func_item_mod_charges},
    {"typeId", func_item_typeId},
    {"price", func_item_price},
    {"sight_dispersion", func_item_sight_dispersion},
    {"type_name", func_item_type_name},
    {"tname", func_item_tname},
    {"covers", func_item_covers},
    {"gun_pierce", func_item_gun_pierce},
    {"weight", func_item_weight},
    {"set_var", func_item_set_var},
    {"rotten", func_item_rotten},
    {"reset_cable", func_item_reset_cable},
    {"has_quality", func_item_has_quality},
    {"process_artifact", func_item_process_artifact},
    {"has_var", func_item_has_var},
    {"gun_skill", func_item_gun_skill},
    {"on_wear", func_item_on_wear},
    {"get_coverage", func_item_get_coverage},
    {"get_free_mod_locations", func_item_get_free_mod_locations},
    {"has_property", func_item_has_property},
    {"on_takeoff", func_item_on_takeoff},
    {"ammo_remaining", func_item_ammo_remaining},
    {"needs_processing", func_item_needs_processing},
    {"mod_damage", func_item_mod_damage},
    {"getlight_emit", func_item_getlight_emit},
    {"min_damage", func_item_min_damage},
    {"is_tool", func_item_is_tool},
    {"processing_speed", func_item_processing_speed},
    {"is_power_armor", func_item_is_power_armor},
    {"make_corpse", func_item_make_corpse},
    {"magazine_integral", func_item_magazine_integral},
    {"magazine_default", func_item_magazine_default},
    {"label", func_item_label},
    {"get_rot", func_item_get_rot},
    {"get_gun_ups_drain", func_item_get_gun_ups_drain},
    {"max_damage", func_item_max_damage},
    {"made_of", func_item_made_of},
    {"gun_dispersion", func_item_gun_dispersion},
    {"is_sided", func_item_is_sided},
    {"display_name", func_item_display_name},
    {"process", func_item_process},
    {"get_layer", func_item_get_layer},
    {"ammo_required", func_item_ammo_required},
    {"is_tool_reversible", func_item_is_tool_reversible},
    {"can_revive", func_item_can_revive},
    {"ammo_data", func_item_ammo_data},
    {"is_non_resealable_container", func_item_is_non_resealable_container},
    {"get_plant_name", func_item_get_plant_name},
    {"get_warmth", func_item_get_warmth},
    {"cut_resist", func_item_cut_resist},
    {"is_container_full", func_item_is_container_full},
    {"get_encumber", func_item_get_encumber},
    {"info", func_item_info},
    {"in_its_container", func_item_in_its_container},
    {"has_technique", func_item_has_technique},
    {"destroyed_at_zero_charges", func_item_destroyed_at_zero_charges},
    {"is_seed", func_item_is_seed},
    {"ammo_type", func_item_ammo_type},
    {"attack_time", func_item_attack_time},
    {"is_melee", func_item_is_melee},
    {"fire_resist", func_item_fire_resist},
    {"__call", new_item},
    {NULL, NULL}
};
template<>
const LuaValue<item*>::MRMap LuaValue<item*>::READ_MEMBERS{
    {"charges", get_item_charges},
    {"bday", get_item_bday},
    {"active", get_item_active},
    {"poison", get_item_poison},
    {"player_id", get_item_player_id},
    {"type", get_item_type},
    {"irridation", get_item_irridation},
    {"fridge", get_item_fridge},
    {"note", get_item_note},
    {"burnt", get_item_burnt},
    {"mission_id", get_item_mission_id},
    {"item_counter", get_item_item_counter},
    {"invlet", get_item_invlet},
    {"frequency", get_item_frequency},
};
template<>
const LuaValue<item*>::MWMap LuaValue<item*>::WRITE_MEMBERS{
    {"charges", set_item_charges},
    {"bday", set_item_bday},
    {"active", set_item_active},
    {"poison", set_item_poison},
    {"player_id", set_item_player_id},
    {"type", set_item_type},
    {"irridation", set_item_irridation},
    {"fridge", set_item_fridge},
    {"note", set_item_note},
    {"burnt", set_item_burnt},
    {"mission_id", set_item_mission_id},
    {"item_counter", set_item_item_counter},
    {"invlet", set_item_invlet},
    {"frequency", set_item_frequency},
};
template<>
const char * const LuaValue<item>::METATABLE_NAME = "value_of_item_metatable";
template<>
LuaValue<item>::Type *LuaValue<item>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<item>::FUNCTIONS[] = {
    {"is_watertight_container", func_item_is_watertight_container},
    {"ammo_capacity", func_item_ammo_capacity},
    {"gun_recoil", func_item_gun_recoil},
    {"flammable", func_item_flammable},
    {"on_wield", func_item_on_wield},
    {"get_quality", func_item_get_quality},
    {"is_two_handed", func_item_is_two_handed},
    {"put_in", func_item_put_in},
    {"clear_vars", func_item_clear_vars},
    {"amount_of", func_item_amount_of},
    {"gun_cycle_mode", func_item_gun_cycle_mode},
    {"is_bionic", func_item_is_bionic},
    {"is_gun", func_item_is_gun},
    {"is_salvageable", func_item_is_salvageable},
    {"color_in_inventory", func_item_color_in_inventory},
    {"get_mtype", func_item_get_mtype},
    {"is_dangerous", func_item_is_dangerous},
    {"get_env_resist", func_item_get_env_resist},
    {"count_by_charges", func_item_count_by_charges},
    {"get_property_string", func_item_get_property_string},
    {"get_var", func_item_get_var},
    {"goes_bad", func_item_goes_bad},
    {"get_thickness", func_item_get_thickness},
    {"magazine_current", func_item_magazine_current},
    {"set_mtype", func_item_set_mtype},
    {"charges_of", func_item_charges_of},
    {"conductive", func_item_conductive},
    {"brewing_time", func_item_brewing_time},
    {"merge_charges", func_item_merge_charges},
    {"gun_range", func_item_gun_range},
    {"is_ammo", func_item_is_ammo},
    {"get_remaining_chapters", func_item_get_remaining_chapters},
    {"components_to_string", func_item_components_to_string},
    {"is_magazine", func_item_is_magazine},
    {"has_rotten_away", func_item_has_rotten_away},
    {"can_holster", func_item_can_holster},
    {"inc_damage", func_item_inc_damage},
    {"color", func_item_color},
    {"is_container_empty", func_item_is_container_empty},
    {"convert", func_item_convert},
    {"is_artifact", func_item_is_artifact},
    {"already_used_by_player", func_item_already_used_by_player},
    {"mark_as_used_by_player", func_item_mark_as_used_by_player},
    {"is_corpse", func_item_is_corpse},
    {"is_food", func_item_is_food},
    {"is_book", func_item_is_book},
    {"mark_chapter_as_read", func_item_mark_chapter_as_read},
    {"calc_rot", func_item_calc_rot},
    {"gunmod_find", func_item_gunmod_find},
    {"fill_with", func_item_fill_with},
    {"is_container", func_item_is_container},
    {"ammo_current", func_item_ammo_current},
    {"melee_skill", func_item_melee_skill},
    {"set_relative_rot", func_item_set_relative_rot},
    {"is_silent", func_item_is_silent},
    {"volume", func_item_volume},
    {"add_technique", func_item_add_technique},
    {"damage", func_item_damage},
    {"get_relative_rot", func_item_get_relative_rot},
    {"craft_has_charges", func_item_craft_has_charges},
    {"ready_to_revive", func_item_ready_to_revive},
    {"on_pickup", func_item_on_pickup},
    {"is_going_bad", func_item_is_going_bad},
    {"get_side", func_item_get_side},
    {"is_armor", func_item_is_armor},
    {"gun_damage", func_item_gun_damage},
    {"get_remaining_capacity_for_liquid", func_item_get_remaining_capacity_for_liquid},
    {"acid_resist", func_item_acid_resist},
    {"is_ammo_container", func_item_is_ammo_container},
    {"bash_resist", func_item_bash_resist},
    {"load_info", func_item_load_info},
    {"get_chapters", func_item_get_chapters},
    {"serialize", func_item_serialize},
    {"get_usable_item", func_item_get_usable_item},
    {"is_null", func_item_is_null},
    {"charges_per_volume", func_item_charges_per_volume},
    {"is_emissive", func_item_is_emissive},
    {"stacks_with", func_item_stacks_with},
    {"erase_var", func_item_erase_var},
    {"set_snippet", func_item_set_snippet},
    {"get_plant_epoch", func_item_get_plant_epoch},
    {"gun_set_mode", func_item_gun_set_mode},
    {"get_storage", func_item_get_storage},
    {"has_label", func_item_has_label},
    {"deserialize", func_item_deserialize},
    {"chip_resistance", func_item_chip_resistance},
    {"symbol", func_item_symbol},
    {"is_firearm", func_item_is_firearm},
    {"get_property_long", func_item_get_property_long},
    {"is_food_container", func_item_is_food_container},
    {"add_rain_to_container", func_item_add_rain_to_container},
    {"has_flag", func_item_has_flag},
    {"is_gunmod", func_item_is_gunmod},
    {"mod_charges", func_item_mod_charges},
    {"typeId", func_item_typeId},
    {"price", func_item_price},
    {"sight_dispersion", func_item_sight_dispersion},
    {"type_name", func_item_type_name},
    {"tname", func_item_tname},
    {"covers", func_item_covers},
    {"gun_pierce", func_item_gun_pierce},
    {"weight", func_item_weight},
    {"set_var", func_item_set_var},
    {"rotten", func_item_rotten},
    {"reset_cable", func_item_reset_cable},
    {"has_quality", func_item_has_quality},
    {"process_artifact", func_item_process_artifact},
    {"has_var", func_item_has_var},
    {"gun_skill", func_item_gun_skill},
    {"on_wear", func_item_on_wear},
    {"get_coverage", func_item_get_coverage},
    {"get_free_mod_locations", func_item_get_free_mod_locations},
    {"has_property", func_item_has_property},
    {"on_takeoff", func_item_on_takeoff},
    {"ammo_remaining", func_item_ammo_remaining},
    {"needs_processing", func_item_needs_processing},
    {"mod_damage", func_item_mod_damage},
    {"getlight_emit", func_item_getlight_emit},
    {"min_damage", func_item_min_damage},
    {"is_tool", func_item_is_tool},
    {"processing_speed", func_item_processing_speed},
    {"is_power_armor", func_item_is_power_armor},
    {"make_corpse", func_item_make_corpse},
    {"magazine_integral", func_item_magazine_integral},
    {"magazine_default", func_item_magazine_default},
    {"label", func_item_label},
    {"get_rot", func_item_get_rot},
    {"get_gun_ups_drain", func_item_get_gun_ups_drain},
    {"max_damage", func_item_max_damage},
    {"made_of", func_item_made_of},
    {"gun_dispersion", func_item_gun_dispersion},
    {"is_sided", func_item_is_sided},
    {"display_name", func_item_display_name},
    {"process", func_item_process},
    {"get_layer", func_item_get_layer},
    {"ammo_required", func_item_ammo_required},
    {"is_tool_reversible", func_item_is_tool_reversible},
    {"can_revive", func_item_can_revive},
    {"ammo_data", func_item_ammo_data},
    {"is_non_resealable_container", func_item_is_non_resealable_container},
    {"get_plant_name", func_item_get_plant_name},
    {"get_warmth", func_item_get_warmth},
    {"cut_resist", func_item_cut_resist},
    {"is_container_full", func_item_is_container_full},
    {"get_encumber", func_item_get_encumber},
    {"info", func_item_info},
    {"in_its_container", func_item_in_its_container},
    {"has_technique", func_item_has_technique},
    {"destroyed_at_zero_charges", func_item_destroyed_at_zero_charges},
    {"is_seed", func_item_is_seed},
    {"ammo_type", func_item_ammo_type},
    {"attack_time", func_item_attack_time},
    {"is_melee", func_item_is_melee},
    {"fire_resist", func_item_fire_resist},
    {"__call", new_item},
    {NULL, NULL}
};
template<>
const LuaValue<item>::MRMap LuaValue<item>::READ_MEMBERS{
    {"charges", get_item_charges},
    {"bday", get_item_bday},
    {"active", get_item_active},
    {"poison", get_item_poison},
    {"player_id", get_item_player_id},
    {"type", get_item_type},
    {"irridation", get_item_irridation},
    {"fridge", get_item_fridge},
    {"note", get_item_note},
    {"burnt", get_item_burnt},
    {"mission_id", get_item_mission_id},
    {"item_counter", get_item_item_counter},
    {"invlet", get_item_invlet},
    {"frequency", get_item_frequency},
};
template<>
const LuaValue<item>::MWMap LuaValue<item>::WRITE_MEMBERS{
    {"charges", set_item_charges},
    {"bday", set_item_bday},
    {"active", set_item_active},
    {"poison", set_item_poison},
    {"player_id", set_item_player_id},
    {"type", set_item_type},
    {"irridation", set_item_irridation},
    {"fridge", set_item_fridge},
    {"note", set_item_note},
    {"burnt", set_item_burnt},
    {"mission_id", set_item_mission_id},
    {"item_counter", set_item_item_counter},
    {"invlet", set_item_invlet},
    {"frequency", set_item_frequency},
};
template<>
const char * const LuaValue<overmap*>::METATABLE_NAME = "overmap_metatable";
template<>
LuaValue<overmap*>::Type *LuaValue<overmap*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<overmap*>::FUNCTIONS[] = {
    {"add_note", func_overmap_add_note},
    {"has_note", func_overmap_has_note},
    {"find_random_omt", func_overmap_find_random_omt},
    {"note", func_overmap_note},
    {"delete_note", func_overmap_delete_note},
    {"is_explored", func_overmap_is_explored},
    {"clear_mon_groups", func_overmap_clear_mon_groups},
    {NULL, NULL}
};
template<>
const LuaValue<overmap*>::MRMap LuaValue<overmap*>::READ_MEMBERS{
};
template<>
const LuaValue<overmap*>::MWMap LuaValue<overmap*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<martialart*>::METATABLE_NAME = "martialart_metatable";
template<>
LuaValue<martialart*>::Type *LuaValue<martialart*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<martialart*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<martialart*>::MRMap LuaValue<martialart*>::READ_MEMBERS{
};
template<>
const LuaValue<martialart*>::MWMap LuaValue<martialart*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<species_type*>::METATABLE_NAME = "species_type_metatable";
template<>
LuaValue<species_type*>::Type *LuaValue<species_type*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<species_type*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<species_type*>::MRMap LuaValue<species_type*>::READ_MEMBERS{
};
template<>
const LuaValue<species_type*>::MWMap LuaValue<species_type*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<start_location*>::METATABLE_NAME = "start_location_metatable";
template<>
LuaValue<start_location*>::Type *LuaValue<start_location*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<start_location*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<start_location*>::MRMap LuaValue<start_location*>::READ_MEMBERS{
};
template<>
const LuaValue<start_location*>::MWMap LuaValue<start_location*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<matype_id>::METATABLE_NAME = "matype_id_metatable";
template<>
LuaValue<matype_id>::Type *LuaValue<matype_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<matype_id>::FUNCTIONS[] = {
    {"str", func_matype_id_str},
    {"is_valid", func_matype_id_is_valid},
    {"obj", func_matype_id_obj},
    {"__call", new_matype_id},
    {"__eq", op_matype_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<matype_id>::MRMap LuaValue<matype_id>::READ_MEMBERS{
};
template<>
const LuaValue<matype_id>::MWMap LuaValue<matype_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<trap*>::METATABLE_NAME = "trap_metatable";
template<>
LuaValue<trap*>::Type *LuaValue<trap*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<trap*>::FUNCTIONS[] = {
    {"can_see", func_trap_can_see},
    {"get_difficulty", func_trap_get_difficulty},
    {"is_3x3_trap", func_trap_is_3x3_trap},
    {"trigger", func_trap_trigger},
    {"detect_trap", func_trap_detect_trap},
    {"is_benign", func_trap_is_benign},
    {"triggered_by_item", func_trap_triggered_by_item},
    {"is_funnel", func_trap_is_funnel},
    {"funnel_turns_per_charge", func_trap_funnel_turns_per_charge},
    {"is_null", func_trap_is_null},
    {"on_disarmed", func_trap_on_disarmed},
    {"get_visibility", func_trap_get_visibility},
    {"get_avoidance", func_trap_get_avoidance},
    {NULL, NULL}
};
template<>
const LuaValue<trap*>::MRMap LuaValue<trap*>::READ_MEMBERS{
    {"sym", get_trap_sym},
    {"name", get_trap_name},
    {"loadid", get_trap_loadid},
    {"id", get_trap_id},
    {"color", get_trap_color},
};
template<>
const LuaValue<trap*>::MWMap LuaValue<trap*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<ma_technique*>::METATABLE_NAME = "ma_technique_metatable";
template<>
LuaValue<ma_technique*>::Type *LuaValue<ma_technique*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ma_technique*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<ma_technique*>::MRMap LuaValue<ma_technique*>::READ_MEMBERS{
};
template<>
const LuaValue<ma_technique*>::MWMap LuaValue<ma_technique*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<species_id>::METATABLE_NAME = "species_id_metatable";
template<>
LuaValue<species_id>::Type *LuaValue<species_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<species_id>::FUNCTIONS[] = {
    {"str", func_species_id_str},
    {"is_valid", func_species_id_is_valid},
    {"obj", func_species_id_obj},
    {"__call", new_species_id},
    {"__eq", op_species_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<species_id>::MRMap LuaValue<species_id>::READ_MEMBERS{
};
template<>
const LuaValue<species_id>::MWMap LuaValue<species_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<mongroup*>::METATABLE_NAME = "mongroup_metatable";
template<>
LuaValue<mongroup*>::Type *LuaValue<mongroup*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<mongroup*>::FUNCTIONS[] = {
    {"inc_interest", func_mongroup_inc_interest},
    {"dec_interest", func_mongroup_dec_interest},
    {"set_interest", func_mongroup_set_interest},
    {"set_target", func_mongroup_set_target},
    {NULL, NULL}
};
template<>
const LuaValue<mongroup*>::MRMap LuaValue<mongroup*>::READ_MEMBERS{
    {"population", get_mongroup_population},
    {"radius", get_mongroup_radius},
    {"diffuse", get_mongroup_diffuse},
    {"target", get_mongroup_target},
    {"horde", get_mongroup_horde},
    {"dying", get_mongroup_dying},
    {"pos", get_mongroup_pos},
};
template<>
const LuaValue<mongroup*>::MWMap LuaValue<mongroup*>::WRITE_MEMBERS{
    {"population", set_mongroup_population},
    {"radius", set_mongroup_radius},
    {"diffuse", set_mongroup_diffuse},
    {"horde", set_mongroup_horde},
    {"dying", set_mongroup_dying},
};
template<>
const char * const LuaValue<item_stack_iterator>::METATABLE_NAME = "item_stack_iterator_metatable";
template<>
LuaValue<item_stack_iterator>::Type *LuaValue<item_stack_iterator>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<item_stack_iterator>::FUNCTIONS[] = {
    {"elem", func_item_stack_iterator_elem},
    {"inc", func_item_stack_iterator_inc},
    {"__call", new_item_stack_iterator},
    {"__eq", op_item_stack_iterator_eq},
    {NULL, NULL}
};
template<>
const LuaValue<item_stack_iterator>::MRMap LuaValue<item_stack_iterator>::READ_MEMBERS{
};
template<>
const LuaValue<item_stack_iterator>::MWMap LuaValue<item_stack_iterator>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<ter_t*>::METATABLE_NAME = "ter_t_metatable";
template<>
LuaValue<ter_t*>::Type *LuaValue<ter_t*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ter_t*>::FUNCTIONS[] = {
    {"color", func_ter_t_color},
    {"symbol", func_ter_t_symbol},
    {NULL, NULL}
};
template<>
const LuaValue<ter_t*>::MRMap LuaValue<ter_t*>::READ_MEMBERS{
    {"trap", get_ter_t_trap},
    {"roof", get_ter_t_roof},
    {"name", get_ter_t_name},
    {"close", get_ter_t_close},
    {"id", get_ter_t_id},
    {"movecost", get_ter_t_movecost},
    {"open", get_ter_t_open},
    {"transforms_into", get_ter_t_transforms_into},
};
template<>
const LuaValue<ter_t*>::MWMap LuaValue<ter_t*>::WRITE_MEMBERS{
    {"trap", set_ter_t_trap},
    {"roof", set_ter_t_roof},
    {"close", set_ter_t_close},
    {"movecost", set_ter_t_movecost},
    {"open", set_ter_t_open},
    {"transforms_into", set_ter_t_transforms_into},
};
template<>
const char * const LuaValue<field_entry*>::METATABLE_NAME = "field_entry_metatable";
template<>
LuaValue<field_entry*>::Type *LuaValue<field_entry*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<field_entry*>::FUNCTIONS[] = {
    {"isAlive", func_field_entry_isAlive},
    {"move_cost", func_field_entry_move_cost},
    {"getFieldAge", func_field_entry_getFieldAge},
    {"setFieldType", func_field_entry_setFieldType},
    {"setFieldDensity", func_field_entry_setFieldDensity},
    {"setFieldAge", func_field_entry_setFieldAge},
    {"is_dangerous", func_field_entry_is_dangerous},
    {"getFieldType", func_field_entry_getFieldType},
    {"name", func_field_entry_name},
    {"getFieldDensity", func_field_entry_getFieldDensity},
    {NULL, NULL}
};
template<>
const LuaValue<field_entry*>::MRMap LuaValue<field_entry*>::READ_MEMBERS{
};
template<>
const LuaValue<field_entry*>::MWMap LuaValue<field_entry*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<tripoint>::METATABLE_NAME = "tripoint_metatable";
template<>
LuaValue<tripoint>::Type *LuaValue<tripoint>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<tripoint>::FUNCTIONS[] = {
    {"serialize", func_tripoint_serialize},
    {"__call", new_tripoint},
    {"__eq", op_tripoint_eq},
    {NULL, NULL}
};
template<>
const LuaValue<tripoint>::MRMap LuaValue<tripoint>::READ_MEMBERS{
    {"y", get_tripoint_y},
    {"x", get_tripoint_x},
    {"z", get_tripoint_z},
};
template<>
const LuaValue<tripoint>::MWMap LuaValue<tripoint>::WRITE_MEMBERS{
    {"y", set_tripoint_y},
    {"x", set_tripoint_x},
    {"z", set_tripoint_z},
};
template<>
const char * const LuaValue<furn_t*>::METATABLE_NAME = "furn_t_metatable";
template<>
LuaValue<furn_t*>::Type *LuaValue<furn_t*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<furn_t*>::FUNCTIONS[] = {
    {"color", func_furn_t_color},
    {"symbol", func_furn_t_symbol},
    {NULL, NULL}
};
template<>
const LuaValue<furn_t*>::MRMap LuaValue<furn_t*>::READ_MEMBERS{
    {"name", get_furn_t_name},
    {"transparent", get_furn_t_transparent},
    {"movecost", get_furn_t_movecost},
    {"close", get_furn_t_close},
    {"id", get_furn_t_id},
    {"move_str_req", get_furn_t_move_str_req},
    {"open", get_furn_t_open},
    {"max_volume", get_furn_t_max_volume},
};
template<>
const LuaValue<furn_t*>::MWMap LuaValue<furn_t*>::WRITE_MEMBERS{
    {"name", set_furn_t_name},
    {"transparent", set_furn_t_transparent},
    {"movecost", set_furn_t_movecost},
    {"close", set_furn_t_close},
    {"move_str_req", set_furn_t_move_str_req},
    {"open", set_furn_t_open},
    {"max_volume", set_furn_t_max_volume},
};
template<>
const char * const LuaValue<material_id>::METATABLE_NAME = "material_id_metatable";
template<>
LuaValue<material_id>::Type *LuaValue<material_id>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<material_id>::FUNCTIONS[] = {
    {"str", func_material_id_str},
    {"is_valid", func_material_id_is_valid},
    {"obj", func_material_id_obj},
    {"__call", new_material_id},
    {"__eq", op_material_id_eq},
    {NULL, NULL}
};
template<>
const LuaValue<material_id>::MRMap LuaValue<material_id>::READ_MEMBERS{
};
template<>
const LuaValue<material_id>::MWMap LuaValue<material_id>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<itype*>::METATABLE_NAME = "itype_metatable";
template<>
LuaValue<itype*>::Type *LuaValue<itype*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<itype*>::FUNCTIONS[] = {
    {"nname", func_itype_nname},
    {"charges_to_use", func_itype_charges_to_use},
    {"has_use", func_itype_has_use},
    {"charges_default", func_itype_charges_default},
    {"maximum_charges", func_itype_maximum_charges},
    {"count_by_charges", func_itype_count_by_charges},
    {"tick", func_itype_tick},
    {"can_use", func_itype_can_use},
    {"get_item_type_string", func_itype_get_item_type_string},
    {"invoke", func_itype_invoke},
    {NULL, NULL}
};
template<>
const LuaValue<itype*>::MRMap LuaValue<itype*>::READ_MEMBERS{
    {"min_per", get_itype_min_per},
    {"description", get_itype_description},
    {"color", get_itype_color},
    {"snippet_category", get_itype_snippet_category},
    {"volume", get_itype_volume},
    {"magazine_well", get_itype_magazine_well},
    {"min_dex", get_itype_min_dex},
    {"integral_volume", get_itype_integral_volume},
    {"stack_size", get_itype_stack_size},
    {"phase", get_itype_phase},
    {"explode_in_fire", get_itype_explode_in_fire},
    {"min_int", get_itype_min_int},
    {"weight", get_itype_weight},
    {"rigid", get_itype_rigid},
    {"sym", get_itype_sym},
    {"price_post", get_itype_price_post},
    {"light_emission", get_itype_light_emission},
    {"default_container", get_itype_default_container},
    {"price", get_itype_price},
    {"min_str", get_itype_min_str},
    {"m_to_hit", get_itype_m_to_hit},
};
template<>
const LuaValue<itype*>::MWMap LuaValue<itype*>::WRITE_MEMBERS{
    {"min_per", set_itype_min_per},
    {"description", set_itype_description},
    {"color", set_itype_color},
    {"snippet_category", set_itype_snippet_category},
    {"volume", set_itype_volume},
    {"magazine_well", set_itype_magazine_well},
    {"min_dex", set_itype_min_dex},
    {"integral_volume", set_itype_integral_volume},
    {"stack_size", set_itype_stack_size},
    {"phase", set_itype_phase},
    {"explode_in_fire", set_itype_explode_in_fire},
    {"min_int", set_itype_min_int},
    {"weight", set_itype_weight},
    {"rigid", set_itype_rigid},
    {"sym", set_itype_sym},
    {"price_post", set_itype_price_post},
    {"light_emission", set_itype_light_emission},
    {"default_container", set_itype_default_container},
    {"price", set_itype_price},
    {"min_str", set_itype_min_str},
    {"m_to_hit", set_itype_m_to_hit},
};
template<>
const char * const LuaValue<monster*>::METATABLE_NAME = "monster_metatable";
template<>
LuaValue<monster*>::Type *LuaValue<monster*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<monster*>::FUNCTIONS[] = {
    {"bash_at", func_monster_bash_at},
    {"move_target", func_monster_move_target},
    {"explode", func_monster_explode},
    {"calc_climb_cost", func_monster_calc_climb_cost},
    {"attack_target", func_monster_attack_target},
    {"stumble", func_monster_stumble},
    {"made_of", func_monster_made_of},
    {"rate_target", func_monster_rate_target},
    {"reset_special_rng", func_monster_reset_special_rng},
    {"turns_to_reach", func_monster_turns_to_reach},
    {"load_info", func_monster_load_info},
    {"can_drown", func_monster_can_drown},
    {"to_item", func_monster_to_item},
    {"color_with_effects", func_monster_color_with_effects},
    {"die_in_explosion", func_monster_die_in_explosion},
    {"wander", func_monster_wander},
    {"bash_estimate", func_monster_bash_estimate},
    {"wander_to", func_monster_wander_to},
    {"unset_dest", func_monster_unset_dest},
    {"set_special", func_monster_set_special},
    {"heal", func_monster_heal},
    {"can_hear", func_monster_can_hear},
    {"make_friendly", func_monster_make_friendly},
    {"make_ally", func_monster_make_ally},
    {"is_dead", func_monster_is_dead},
    {"try_upgrade", func_monster_try_upgrade},
    {"will_reach", func_monster_will_reach},
    {"can_act", func_monster_can_act},
    {"is_fleeing", func_monster_is_fleeing},
    {"group_bash_skill", func_monster_group_bash_skill},
    {"shift", func_monster_shift},
    {"disable_special", func_monster_disable_special},
    {"set_hp", func_monster_set_hp},
    {"hear_sound", func_monster_hear_sound},
    {"hasten_upgrade", func_monster_hasten_upgrade},
    {"drop_items_on_death", func_monster_drop_items_on_death},
    {"scent_move", func_monster_scent_move},
    {"can_move_to", func_monster_can_move_to},
    {"push_to", func_monster_push_to},
    {"process_triggers", func_monster_process_triggers},
    {"bash_skill", func_monster_bash_skill},
    {"add_item", func_monster_add_item},
    {"footsteps", func_monster_footsteps},
    {"reset_special", func_monster_reset_special},
    {"can_upgrade", func_monster_can_upgrade},
    {"poly", func_monster_poly},
    {"calc_movecost", func_monster_calc_movecost},
    {"can_see", func_monster_can_see},
    {"move_to", func_monster_move_to},
    {"on_load", func_monster_on_load},
    {"name_with_armor", func_monster_name_with_armor},
    {"attack_at", func_monster_attack_at},
    {"name", func_monster_name},
    {"on_unload", func_monster_on_unload},
    {"move", func_monster_move},
    {"make_fungus", func_monster_make_fungus},
    {"can_submerge", func_monster_can_submerge},
    {"init_from_item", func_monster_init_from_item},
    {"set_dest", func_monster_set_dest},
    {"spawn", func_monster_spawn},
    {"is_dead_state", func_monster_is_dead_state},
    {"basic_symbol_color", func_monster_basic_symbol_color},
    {"is_fake", func_monster_is_fake},
    {"melee_attack", func_monster_melee_attack},
    {"get_killer", func_monster_get_killer},
    {"get_armor_bash", func_monster_get_armor_bash},
    {"posx", func_monster_posx},
    {"hp_percentage", func_monster_hp_percentage},
    {"gibType", func_monster_gibType},
    {"mod_moves", func_monster_mod_moves},
    {"bloodType", func_monster_bloodType},
    {"digging", func_monster_digging},
    {"pos", func_monster_pos},
    {"has_trait", func_monster_has_trait},
    {"get_perceived_pain", func_monster_get_perceived_pain},
    {"is_monster", func_monster_is_monster},
    {"get_hp", func_monster_get_hp},
    {"set_armor_cut_bonus", func_monster_set_armor_cut_bonus},
    {"get_env_resist", func_monster_get_env_resist},
    {"set_fake", func_monster_set_fake},
    {"mod_pain", func_monster_mod_pain},
    {"is_hallucination", func_monster_is_hallucination},
    {"get_throw_resist", func_monster_get_throw_resist},
    {"get_value", func_monster_get_value},
    {"set_throw_resist", func_monster_set_throw_resist},
    {"get_armor_cut_bonus", func_monster_get_armor_cut_bonus},
    {"skin_name", func_monster_skin_name},
    {"get_hp_max", func_monster_get_hp_max},
    {"set_cut_bonus", func_monster_set_cut_bonus},
    {"on_hit", func_monster_on_hit},
    {"mod_stat", func_monster_mod_stat},
    {"setpos", func_monster_setpos},
    {"get_speed_bonus", func_monster_get_speed_bonus},
    {"get_size", func_monster_get_size},
    {"is_warm", func_monster_is_warm},
    {"process_turn", func_monster_process_turn},
    {"disp_name", func_monster_disp_name},
    {"get_cut_mult", func_monster_get_cut_mult},
    {"power_rating", func_monster_power_rating},
    {"get_name", func_monster_get_name},
    {"add_effect", func_monster_add_effect},
    {"get_grab_resist", func_monster_get_grab_resist},
    {"get_effect_int", func_monster_get_effect_int},
    {"get_hit_bonus", func_monster_get_hit_bonus},
    {"is_immune_effect", func_monster_is_immune_effect},
    {"set_cut_mult", func_monster_set_cut_mult},
    {"get_num_dodges", func_monster_get_num_dodges},
    {"is_npc", func_monster_is_npc},
    {"set_bash_bonus", func_monster_set_bash_bonus},
    {"reset_bonuses", func_monster_reset_bonuses},
    {"get_dodge_bonus", func_monster_get_dodge_bonus},
    {"set_speed_bonus", func_monster_set_speed_bonus},
    {"hit_roll", func_monster_hit_roll},
    {"get_num_blocks", func_monster_get_num_blocks},
    {"on_dodge", func_monster_on_dodge},
    {"get_bash_bonus", func_monster_get_bash_bonus},
    {"process_effects", func_monster_process_effects},
    {"set_dodge_bonus", func_monster_set_dodge_bonus},
    {"get_num_dodges_bonus", func_monster_get_num_dodges_bonus},
    {"get_dodge", func_monster_get_dodge},
    {"get_dodge_base", func_monster_get_dodge_base},
    {"normalize", func_monster_normalize},
    {"mod_bash_bonus", func_monster_mod_bash_bonus},
    {"set_num_dodges_bonus", func_monster_set_num_dodges_bonus},
    {"mod_hit_bonus", func_monster_mod_hit_bonus},
    {"sight_range", func_monster_sight_range},
    {"reset", func_monster_reset},
    {"speed_rating", func_monster_speed_rating},
    {"get_num_blocks_bonus", func_monster_get_num_blocks_bonus},
    {"get_armor_bash_base", func_monster_get_armor_bash_base},
    {"has_weapon", func_monster_has_weapon},
    {"posz", func_monster_posz},
    {"get_armor_cut", func_monster_get_armor_cut},
    {"reset_stats", func_monster_reset_stats},
    {"set_num_blocks_bonus", func_monster_set_num_blocks_bonus},
    {"mod_cut_bonus", func_monster_mod_cut_bonus},
    {"has_grab_break_tec", func_monster_has_grab_break_tec},
    {"mod_dodge_bonus", func_monster_mod_dodge_bonus},
    {"is_symbol_highlighted", func_monster_is_symbol_highlighted},
    {"move_effects", func_monster_move_effects},
    {"get_hit_base", func_monster_get_hit_base},
    {"mod_speed_bonus", func_monster_mod_speed_bonus},
    {"get_cut_bonus", func_monster_get_cut_bonus},
    {"in_sleep_state", func_monster_in_sleep_state},
    {"set_value", func_monster_set_value},
    {"remove_effect", func_monster_remove_effect},
    {"sees", func_monster_sees},
    {"get_weight", func_monster_get_weight},
    {"symbol_color", func_monster_symbol_color},
    {"weight_capacity", func_monster_weight_capacity},
    {"uncanny_dodge", func_monster_uncanny_dodge},
    {"set_block_bonus", func_monster_set_block_bonus},
    {"set_speed_base", func_monster_set_speed_base},
    {"die", func_monster_die},
    {"mod_block_bonus", func_monster_mod_block_bonus},
    {"symbol", func_monster_symbol},
    {"knock_back_from", func_monster_knock_back_from},
    {"set_bash_mult", func_monster_set_bash_mult},
    {"deal_melee_attack", func_monster_deal_melee_attack},
    {"avoid_trap", func_monster_avoid_trap},
    {"clear_effects", func_monster_clear_effects},
    {"get_bash_mult", func_monster_get_bash_mult},
    {"get_speed", func_monster_get_speed},
    {"get_block_bonus", func_monster_get_block_bonus},
    {"get_speed_base", func_monster_get_speed_base},
    {"has_effect", func_monster_has_effect},
    {"mod_pain_noresist", func_monster_mod_pain_noresist},
    {"set_armor_bash_bonus", func_monster_set_armor_bash_bonus},
    {"set_moves", func_monster_set_moves},
    {"add_env_effect", func_monster_add_env_effect},
    {"check_dead_state", func_monster_check_dead_state},
    {"set_melee_quiet", func_monster_set_melee_quiet},
    {"set_hit_bonus", func_monster_set_hit_bonus},
    {"set_grab_resist", func_monster_set_grab_resist},
    {"fall_damage_mod", func_monster_fall_damage_mod},
    {"get_random_body_part", func_monster_get_random_body_part},
    {"get_melee", func_monster_get_melee},
    {"is_elec_immune", func_monster_is_elec_immune},
    {"is_on_ground", func_monster_is_on_ground},
    {"get_armor_bash_bonus", func_monster_get_armor_bash_bonus},
    {"is_underwater", func_monster_is_underwater},
    {"stability_roll", func_monster_stability_roll},
    {"is_player", func_monster_is_player},
    {"get_effect_dur", func_monster_get_effect_dur},
    {"apply_damage", func_monster_apply_damage},
    {"impact", func_monster_impact},
    {"get_melee_quiet", func_monster_get_melee_quiet},
    {"remove_value", func_monster_remove_value},
    {"posy", func_monster_posy},
    {"get_pain", func_monster_get_pain},
    {"set_pain", func_monster_set_pain},
    {"get_armor_cut_base", func_monster_get_armor_cut_base},
    {"dodge_roll", func_monster_dodge_roll},
    {"get_hit", func_monster_get_hit},
    {NULL, NULL}
};
template<>
const LuaValue<monster*>::MRMap LuaValue<monster*>::READ_MEMBERS{
    {"anger", get_monster_anger},
    {"type", get_monster_type},
    {"no_extra_death_drops", get_monster_no_extra_death_drops},
    {"wandf", get_monster_wandf},
    {"wander_pos", get_monster_wander_pos},
    {"friendly", get_monster_friendly},
    {"hallucination", get_monster_hallucination},
    {"last_updated", get_monster_last_updated},
    {"mission_id", get_monster_mission_id},
    {"staircount", get_monster_staircount},
    {"morale", get_monster_morale},
    {"unique_name", get_monster_unique_name},
    {"ignoring", get_monster_ignoring},
    {"no_corpse_quiet", get_monster_no_corpse_quiet},
    {"made_footstep", get_monster_made_footstep},
};
template<>
const LuaValue<monster*>::MWMap LuaValue<monster*>::WRITE_MEMBERS{
    {"anger", set_monster_anger},
    {"no_extra_death_drops", set_monster_no_extra_death_drops},
    {"wandf", set_monster_wandf},
    {"wander_pos", set_monster_wander_pos},
    {"friendly", set_monster_friendly},
    {"hallucination", set_monster_hallucination},
    {"last_updated", set_monster_last_updated},
    {"mission_id", set_monster_mission_id},
    {"staircount", set_monster_staircount},
    {"morale", set_monster_morale},
    {"unique_name", set_monster_unique_name},
    {"ignoring", set_monster_ignoring},
    {"no_corpse_quiet", set_monster_no_corpse_quiet},
    {"made_footstep", set_monster_made_footstep},
};
template<>
const char * const LuaValue<ammunition_type*>::METATABLE_NAME = "ammunition_type_metatable";
template<>
LuaValue<ammunition_type*>::Type *LuaValue<ammunition_type*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<ammunition_type*>::FUNCTIONS[] = {
    {NULL, NULL}
};
template<>
const LuaValue<ammunition_type*>::MRMap LuaValue<ammunition_type*>::READ_MEMBERS{
};
template<>
const LuaValue<ammunition_type*>::MWMap LuaValue<ammunition_type*>::WRITE_MEMBERS{
};
template<>
const char * const LuaValue<encumbrance_data>::METATABLE_NAME = "encumbrance_data_metatable";
template<>
LuaValue<encumbrance_data>::Type *LuaValue<encumbrance_data>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<encumbrance_data>::FUNCTIONS[] = {
    {"__call", new_encumbrance_data},
    {NULL, NULL}
};
template<>
const LuaValue<encumbrance_data>::MRMap LuaValue<encumbrance_data>::READ_MEMBERS{
    {"armor_encumbrance", get_encumbrance_data_armor_encumbrance},
    {"layer_penalty", get_encumbrance_data_layer_penalty},
    {"encumbrance", get_encumbrance_data_encumbrance},
};
template<>
const LuaValue<encumbrance_data>::MWMap LuaValue<encumbrance_data>::WRITE_MEMBERS{
    {"armor_encumbrance", set_encumbrance_data_armor_encumbrance},
    {"layer_penalty", set_encumbrance_data_layer_penalty},
    {"encumbrance", set_encumbrance_data_encumbrance},
};
template<>
const char * const LuaValue<mtype*>::METATABLE_NAME = "mtype_metatable";
template<>
LuaValue<mtype*>::Type *LuaValue<mtype*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<mtype*>::FUNCTIONS[] = {
    {"nname", func_mtype_nname},
    {"same_species", func_mtype_same_species},
    {"get_meat_itype", func_mtype_get_meat_itype},
    {"gibType", func_mtype_gibType},
    {"made_of", func_mtype_made_of},
    {"bloodType", func_mtype_bloodType},
    {"set_flag", func_mtype_set_flag},
    {"in_species", func_mtype_in_species},
    {"in_category", func_mtype_in_category},
    {"has_special_attack", func_mtype_has_special_attack},
    {"has_flag", func_mtype_has_flag},
    {NULL, NULL}
};
template<>
const LuaValue<mtype*>::MRMap LuaValue<mtype*>::READ_MEMBERS{
    {"melee_sides", get_mtype_melee_sides},
    {"description", get_mtype_description},
    {"armor_stab", get_mtype_armor_stab},
    {"armor_bash", get_mtype_armor_bash},
    {"melee_skill", get_mtype_melee_skill},
    {"hp", get_mtype_hp},
    {"vision_day", get_mtype_vision_day},
    {"attack_cost", get_mtype_attack_cost},
    {"half_life", get_mtype_half_life},
    {"armor_cut", get_mtype_armor_cut},
    {"armor_fire", get_mtype_armor_fire},
    {"speed", get_mtype_speed},
    {"death_drops", get_mtype_death_drops},
    {"luminance", get_mtype_luminance},
    {"size", get_mtype_size},
    {"upgrades", get_mtype_upgrades},
    {"upgrade_group", get_mtype_upgrade_group},
    {"id", get_mtype_id},
    {"sk_dodge", get_mtype_sk_dodge},
    {"armor_acid", get_mtype_armor_acid},
    {"upgrade_into", get_mtype_upgrade_into},
    {"melee_dice", get_mtype_melee_dice},
    {"phase", get_mtype_phase},
    {"def_chance", get_mtype_def_chance},
    {"sym", get_mtype_sym},
    {"vision_night", get_mtype_vision_night},
    {"morale", get_mtype_morale},
    {"agro", get_mtype_agro},
    {"difficulty", get_mtype_difficulty},
    {"color", get_mtype_color},
    {"revert_to_itype", get_mtype_revert_to_itype},
};
template<>
const LuaValue<mtype*>::MWMap LuaValue<mtype*>::WRITE_MEMBERS{
    {"melee_sides", set_mtype_melee_sides},
    {"description", set_mtype_description},
    {"armor_stab", set_mtype_armor_stab},
    {"armor_bash", set_mtype_armor_bash},
    {"melee_skill", set_mtype_melee_skill},
    {"hp", set_mtype_hp},
    {"vision_day", set_mtype_vision_day},
    {"attack_cost", set_mtype_attack_cost},
    {"half_life", set_mtype_half_life},
    {"armor_cut", set_mtype_armor_cut},
    {"armor_fire", set_mtype_armor_fire},
    {"speed", set_mtype_speed},
    {"death_drops", set_mtype_death_drops},
    {"luminance", set_mtype_luminance},
    {"size", set_mtype_size},
    {"upgrades", set_mtype_upgrades},
    {"upgrade_group", set_mtype_upgrade_group},
    {"sk_dodge", set_mtype_sk_dodge},
    {"armor_acid", set_mtype_armor_acid},
    {"upgrade_into", set_mtype_upgrade_into},
    {"melee_dice", set_mtype_melee_dice},
    {"phase", set_mtype_phase},
    {"def_chance", set_mtype_def_chance},
    {"sym", set_mtype_sym},
    {"vision_night", set_mtype_vision_night},
    {"morale", set_mtype_morale},
    {"agro", set_mtype_agro},
    {"difficulty", set_mtype_difficulty},
    {"color", set_mtype_color},
    {"revert_to_itype", set_mtype_revert_to_itype},
};
template<>
const char * const LuaValue<field*>::METATABLE_NAME = "field_metatable";
template<>
LuaValue<field*>::Type *LuaValue<field*>::get_subclass( lua_State* const S, int const i) {
    (void)S; (void)i;
    return nullptr;
}
template<>
const luaL_Reg LuaValue<field*>::FUNCTIONS[] = {
    {"fieldCount", func_field_fieldCount},
    {"fieldSymbol", func_field_fieldSymbol},
    {"addField", func_field_addField},
    {"removeField", func_field_removeField},
    {"move_cost", func_field_move_cost},
    {"findField", func_field_findField},
    {NULL, NULL}
};
template<>
const LuaValue<field*>::MRMap LuaValue<field*>::READ_MEMBERS{
};
template<>
const LuaValue<field*>::MWMap LuaValue<field*>::WRITE_MEMBERS{
};
static void load_metatables(lua_State* const L) {
    LuaValue<stats*>::load_metatable( L, nullptr );
    LuaValue<MonsterGroup*>::load_metatable( L, nullptr );
    LuaValue<ammotype>::load_metatable( L, "ammotype" );
    LuaValue<item_location>::load_metatable( L, nullptr );
    LuaValue<skill_id>::load_metatable( L, "skill_id" );
    LuaValue<quality_id>::load_metatable( L, "quality_id" );
    LuaValue<mtype_id>::load_metatable( L, "mtype_id" );
    LuaValue<quality*>::load_metatable( L, nullptr );
    LuaValue<map*>::load_metatable( L, nullptr );
    LuaValue<trap_id>::load_metatable( L, "trap_id" );
    LuaValue<Creature*>::load_metatable( L, nullptr );
    LuaValue<w_point*>::load_metatable( L, nullptr );
    LuaValue<Skill*>::load_metatable( L, nullptr );
    LuaValue<start_location_id>::load_metatable( L, "start_location_id" );
    LuaValue<furn_str_id>::load_metatable( L, "furn_str_id" );
    LuaValue<mabuff_id>::load_metatable( L, "mabuff_id" );
    LuaValue<material_type*>::load_metatable( L, nullptr );
    LuaValue<player*>::load_metatable( L, nullptr );
    LuaValue<efftype_id>::load_metatable( L, "efftype_id" );
    LuaValue<furn_id>::load_metatable( L, "furn_id" );
    LuaValue<volume>::load_metatable( L, nullptr );
    LuaValue<game*>::load_metatable( L, nullptr );
    LuaValue<trap_str_id>::load_metatable( L, "trap_str_id" );
    LuaValue<ter_str_id>::load_metatable( L, "ter_str_id" );
    LuaValue<matec_id>::load_metatable( L, "matec_id" );
    LuaValue<mongroup_id>::load_metatable( L, "mongroup_id" );
    LuaValue<point>::load_metatable( L, "point" );
    LuaValue<calendar*>::load_metatable( L, "calendar" );
    LuaValue<ma_buff*>::load_metatable( L, nullptr );
    LuaValue<uimenu*>::load_metatable( L, nullptr );
    LuaValue<map_stack>::load_metatable( L, nullptr );
    LuaValue<ter_id>::load_metatable( L, "ter_id" );
    LuaValue<effect_type*>::load_metatable( L, nullptr );
    LuaValue<Character*>::load_metatable( L, nullptr );
    LuaValue<item*>::load_metatable( L, "item" );
    LuaValue<overmap*>::load_metatable( L, nullptr );
    LuaValue<martialart*>::load_metatable( L, nullptr );
    LuaValue<species_type*>::load_metatable( L, nullptr );
    LuaValue<start_location*>::load_metatable( L, nullptr );
    LuaValue<matype_id>::load_metatable( L, "matype_id" );
    LuaValue<trap*>::load_metatable( L, nullptr );
    LuaValue<ma_technique*>::load_metatable( L, nullptr );
    LuaValue<species_id>::load_metatable( L, "species_id" );
    LuaValue<mongroup*>::load_metatable( L, nullptr );
    LuaValue<item_stack_iterator>::load_metatable( L, "item_stack_iterator" );
    LuaValue<ter_t*>::load_metatable( L, nullptr );
    LuaValue<field_entry*>::load_metatable( L, nullptr );
    LuaValue<tripoint>::load_metatable( L, "tripoint" );
    LuaValue<furn_t*>::load_metatable( L, nullptr );
    LuaValue<material_id>::load_metatable( L, "material_id" );
    LuaValue<itype*>::load_metatable( L, nullptr );
    LuaValue<monster*>::load_metatable( L, nullptr );
    LuaValue<ammunition_type*>::load_metatable( L, nullptr );
    LuaValue<encumbrance_data>::load_metatable( L, "encumbrance_data" );
    LuaValue<mtype*>::load_metatable( L, nullptr );
    LuaValue<field*>::load_metatable( L, nullptr );
}
template<>
const LuaEnum<season_type>::EMap LuaEnum<season_type>::BINDINGS = {
    {"SPRING", SPRING},
    {"SUMMER", SUMMER},
    {"AUTUMN", AUTUMN},
    {"WINTER", WINTER},
};
template<>
const LuaEnum<hp_part>::EMap LuaEnum<hp_part>::BINDINGS = {
    {"hp_head", hp_head},
    {"hp_torso", hp_torso},
    {"hp_arm_l", hp_arm_l},
    {"hp_arm_r", hp_arm_r},
    {"hp_leg_l", hp_leg_l},
    {"hp_leg_r", hp_leg_r},
    {"num_hp_parts", num_hp_parts},
};
template<>
const LuaEnum<side>::EMap LuaEnum<side>::BINDINGS = {
    {"side::BOTH", side::BOTH},
    {"side::LEFT", side::LEFT},
    {"side::RIGHT", side::RIGHT},
};
template<>
const LuaEnum<body_part>::EMap LuaEnum<body_part>::BINDINGS = {
    {"bp_torso", bp_torso},
    {"bp_head", bp_head},
    {"bp_eyes", bp_eyes},
    {"bp_mouth", bp_mouth},
    {"bp_arm_l", bp_arm_l},
    {"bp_arm_r", bp_arm_r},
    {"bp_hand_l", bp_hand_l},
    {"bp_hand_r", bp_hand_r},
    {"bp_leg_l", bp_leg_l},
    {"bp_leg_r", bp_leg_r},
    {"bp_foot_l", bp_foot_l},
    {"bp_foot_r", bp_foot_r},
    {"num_bp", num_bp},
};
template<>
const LuaEnum<field_id>::EMap LuaEnum<field_id>::BINDINGS = {
    {"fd_null", fd_null},
    {"fd_blood", fd_blood},
    {"fd_bile", fd_bile},
    {"fd_gibs_flesh", fd_gibs_flesh},
    {"fd_gibs_veggy", fd_gibs_veggy},
    {"fd_web", fd_web},
    {"fd_slime", fd_slime},
    {"fd_acid", fd_acid},
    {"fd_sap", fd_sap},
    {"fd_sludge", fd_sludge},
    {"fd_fire", fd_fire},
    {"fd_rubble", fd_rubble},
    {"fd_smoke", fd_smoke},
    {"fd_toxic_gas", fd_toxic_gas},
    {"fd_tear_gas", fd_tear_gas},
    {"fd_nuke_gas", fd_nuke_gas},
    {"fd_gas_vent", fd_gas_vent},
    {"fd_fire_vent", fd_fire_vent},
    {"fd_flame_burst", fd_flame_burst},
    {"fd_electricity", fd_electricity},
    {"fd_fatigue", fd_fatigue},
    {"fd_push_items", fd_push_items},
    {"fd_shock_vent", fd_shock_vent},
    {"fd_acid_vent", fd_acid_vent},
    {"fd_plasma", fd_plasma},
    {"fd_laser", fd_laser},
    {"fd_spotlight", fd_spotlight},
    {"fd_dazzling", fd_dazzling},
    {"fd_blood_veggy", fd_blood_veggy},
    {"fd_blood_insect", fd_blood_insect},
    {"fd_blood_invertebrate", fd_blood_invertebrate},
    {"fd_gibs_insect", fd_gibs_insect},
    {"fd_gibs_invertebrate", fd_gibs_invertebrate},
    {"fd_cigsmoke", fd_cigsmoke},
    {"fd_weedsmoke", fd_weedsmoke},
    {"fd_cracksmoke", fd_cracksmoke},
    {"fd_methsmoke", fd_methsmoke},
    {"fd_bees", fd_bees},
    {"fd_incendiary", fd_incendiary},
    {"fd_relax_gas", fd_relax_gas},
    {"fd_fungal_haze", fd_fungal_haze},
    {"fd_hot_air1", fd_hot_air1},
    {"fd_hot_air2", fd_hot_air2},
    {"fd_hot_air3", fd_hot_air3},
    {"fd_hot_air4", fd_hot_air4},
    {"fd_fungicidal_gas", fd_fungicidal_gas},
    {"num_fields", num_fields},
};
template<>
const LuaEnum<morale_type>::EMap LuaEnum<morale_type>::BINDINGS = {
    {"MORALE_NULL", MORALE_NULL},
    {"MORALE_FOOD_GOOD", MORALE_FOOD_GOOD},
    {"MORALE_FOOD_HOT", MORALE_FOOD_HOT},
    {"MORALE_MUSIC", MORALE_MUSIC},
    {"MORALE_HONEY", MORALE_HONEY},
    {"MORALE_GAME", MORALE_GAME},
    {"MORALE_MARLOSS", MORALE_MARLOSS},
    {"MORALE_MUTAGEN", MORALE_MUTAGEN},
    {"MORALE_FEELING_GOOD", MORALE_FEELING_GOOD},
    {"MORALE_SUPPORT", MORALE_SUPPORT},
    {"MORALE_PHOTOS", MORALE_PHOTOS},
    {"MORALE_CRAVING_NICOTINE", MORALE_CRAVING_NICOTINE},
    {"MORALE_CRAVING_CAFFEINE", MORALE_CRAVING_CAFFEINE},
    {"MORALE_CRAVING_ALCOHOL", MORALE_CRAVING_ALCOHOL},
    {"MORALE_CRAVING_OPIATE", MORALE_CRAVING_OPIATE},
    {"MORALE_CRAVING_SPEED", MORALE_CRAVING_SPEED},
    {"MORALE_CRAVING_COCAINE", MORALE_CRAVING_COCAINE},
    {"MORALE_CRAVING_CRACK", MORALE_CRAVING_CRACK},
    {"MORALE_CRAVING_MUTAGEN", MORALE_CRAVING_MUTAGEN},
    {"MORALE_CRAVING_DIAZEPAM", MORALE_CRAVING_DIAZEPAM},
    {"MORALE_CRAVING_MARLOSS", MORALE_CRAVING_MARLOSS},
    {"MORALE_FOOD_BAD", MORALE_FOOD_BAD},
    {"MORALE_CANNIBAL", MORALE_CANNIBAL},
    {"MORALE_VEGETARIAN", MORALE_VEGETARIAN},
    {"MORALE_MEATARIAN", MORALE_MEATARIAN},
    {"MORALE_ANTIFRUIT", MORALE_ANTIFRUIT},
    {"MORALE_LACTOSE", MORALE_LACTOSE},
    {"MORALE_ANTIJUNK", MORALE_ANTIJUNK},
    {"MORALE_ANTIWHEAT", MORALE_ANTIWHEAT},
    {"MORALE_NO_DIGEST", MORALE_NO_DIGEST},
    {"MORALE_WET", MORALE_WET},
    {"MORALE_DRIED_OFF", MORALE_DRIED_OFF},
    {"MORALE_COLD", MORALE_COLD},
    {"MORALE_HOT", MORALE_HOT},
    {"MORALE_FEELING_BAD", MORALE_FEELING_BAD},
    {"MORALE_KILLED_INNOCENT", MORALE_KILLED_INNOCENT},
    {"MORALE_KILLED_FRIEND", MORALE_KILLED_FRIEND},
    {"MORALE_KILLED_MONSTER", MORALE_KILLED_MONSTER},
    {"MORALE_MUTILATE_CORPSE", MORALE_MUTILATE_CORPSE},
    {"MORALE_MUTAGEN_ELF", MORALE_MUTAGEN_ELF},
    {"MORALE_MUTAGEN_CHIMERA", MORALE_MUTAGEN_CHIMERA},
    {"MORALE_MUTAGEN_MUTATION", MORALE_MUTAGEN_MUTATION},
    {"MORALE_MOODSWING", MORALE_MOODSWING},
    {"MORALE_BOOK", MORALE_BOOK},
    {"MORALE_COMFY", MORALE_COMFY},
    {"MORALE_SCREAM", MORALE_SCREAM},
    {"MORALE_PERM_MASOCHIST", MORALE_PERM_MASOCHIST},
    {"MORALE_PERM_HOARDER", MORALE_PERM_HOARDER},
    {"MORALE_PERM_FANCY", MORALE_PERM_FANCY},
    {"MORALE_PERM_OPTIMIST", MORALE_PERM_OPTIMIST},
    {"MORALE_PERM_BADTEMPER", MORALE_PERM_BADTEMPER},
    {"MORALE_PERM_CONSTRAINED", MORALE_PERM_CONSTRAINED},
    {"MORALE_GAME_FOUND_KITTEN", MORALE_GAME_FOUND_KITTEN},
    {"MORALE_HAIRCUT", MORALE_HAIRCUT},
    {"MORALE_SHAVE", MORALE_SHAVE},
    {"NUM_MORALE_TYPES", NUM_MORALE_TYPES},
};
template<>
const LuaEnum<m_size>::EMap LuaEnum<m_size>::BINDINGS = {
    {"MS_TINY", MS_TINY},
    {"MS_SMALL", MS_SMALL},
    {"MS_MEDIUM", MS_MEDIUM},
    {"MS_LARGE", MS_LARGE},
    {"MS_HUGE", MS_HUGE},
};
template<>
const LuaEnum<add_type>::EMap LuaEnum<add_type>::BINDINGS = {
    {"ADD_NULL", ADD_NULL},
    {"ADD_CAFFEINE", ADD_CAFFEINE},
    {"ADD_ALCOHOL", ADD_ALCOHOL},
    {"ADD_SLEEP", ADD_SLEEP},
    {"ADD_PKILLER", ADD_PKILLER},
    {"ADD_SPEED", ADD_SPEED},
    {"ADD_CIG", ADD_CIG},
    {"ADD_COKE", ADD_COKE},
    {"ADD_CRACK", ADD_CRACK},
    {"ADD_MUTAGEN", ADD_MUTAGEN},
    {"ADD_DIAZEPAM", ADD_DIAZEPAM},
    {"ADD_MARLOSS_R", ADD_MARLOSS_R},
    {"ADD_MARLOSS_B", ADD_MARLOSS_B},
    {"ADD_MARLOSS_Y", ADD_MARLOSS_Y},
};
template<>
const LuaEnum<game_message_type>::EMap LuaEnum<game_message_type>::BINDINGS = {
    {"m_good", m_good},
    {"m_bad", m_bad},
    {"m_mixed", m_mixed},
    {"m_warning", m_warning},
    {"m_info", m_info},
    {"m_neutral", m_neutral},
    {"m_debug", m_debug},
    {"m_headshot", m_headshot},
    {"m_critical", m_critical},
    {"m_grazing", m_grazing},
};
template<>
const LuaEnum<phase_id>::EMap LuaEnum<phase_id>::BINDINGS = {
    {"PNULL", PNULL},
    {"SOLID", SOLID},
    {"LIQUID", LIQUID},
    {"GAS", GAS},
    {"PLASMA", PLASMA},
};
static const struct luaL_Reg gamelib [] = {
    {"create_monster", global_create_monster},
    {"rng", global_rng},
    {"distance", global_distance},
    {"trig_dist", global_trig_dist},
    {"get_terrain_type", global_get_terrain_type},
    {"popup", global_popup},
    {"string_input_popup", global_string_input_popup},
    {"create_uimenu", global_create_uimenu},
    {"add_msg", global_add_msg},
    {"add_item_to_group", global_add_item_to_group},
    {"one_in", global_one_in},
    {"get_calendar_turn", global_get_calendar_turn},
    {NULL, NULL}
};
